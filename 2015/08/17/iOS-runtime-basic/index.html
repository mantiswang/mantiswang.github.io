<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS~runtime 基础 | 白色键盘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是Runtime
我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));
OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。
相关的定义：">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS~runtime 基础">
<meta property="og:url" content="http://yoursite.com/2015/08/17/iOS-runtime-basic/index.html">
<meta property="og:site_name" content="白色键盘">
<meta property="og:description" content="什么是Runtime
我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));
OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。
相关的定义：">
<meta property="og:updated_time" content="2015-08-17T15:44:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS~runtime 基础">
<meta name="twitter:description" content="什么是Runtime
我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));
OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。
相关的定义：">
  
    <link rel="alternative" href="/atom.xml" title="白色键盘" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">苹果</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">苹果</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">苹果</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-iOS-runtime-basic" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/17/iOS-runtime-basic/" class="article-date">
  	<time datetime="2015-08-17T15:24:59.000Z" itemprop="datePublished">2015-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS~runtime 基础
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是Runtime">什么是Runtime</h4><ul>
<li>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target doSomething];</code>会被转化<code>成objc_msgSend(target, @selector(doSomething));</code></li>
<li>OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。</li>
<li>相关的定义：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 描述类中的一个方法</span></span><br><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实例变量</span></span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 类别Category</span></span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 类中声明的属性</span></span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line">```  </span><br><span class="line">* 类在runtime中的表示</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//类在runtime中的表示<br>struct objc_class {<br>    Class isa;//指针，顾名思义，表示是一个什么，<br>    //实例的isa指向类对象，类对象的isa指向元类</p>
<p>#if !<strong>OBJC2</strong><br>    Class super_class;  //指向父类<br>    const char <em>name;  //类名<br>    long version;<br>    long info;<br>    long instance_size<br>    struct objc_ivar_list </em>ivars //成员变量列表<br>    struct objc_method_list <em>*methodLists; //方法列表<br>    struct objc_cache </em>cache;//缓存<br>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存<br>    struct objc_protocol_list *protocols //协议列表</p>
<pre><code><span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>} OBJC2_UNAVAILABLE;<br>/<em> Use <code>Class</code> instead of `struct objc_class </em>` */<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#### 获取列表</span></span><br><span class="line">有时候会有这样的需求，我们需要知道当前类中每个属性的名字（比如字典转模型，字典的Key和模型对象的属性名字不匹配）。</span><br><span class="line">我们可以通过runtime的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）。</span><br></pre></td></tr></table></figure></p>
<p>unsigned int count;<br>    //获取属性列表<br>    objc_property_t <em>propertyList = class_copyPropertyList([self class], &amp;count);<br>    for (unsigned int i=0; i&lt;count; i++) {<br>        const char </em>propertyName = property_getName(propertyList[i]);<br>        NSLog(@”property—-&gt;%@”, [NSString stringWithUTF8String:propertyName]);<br>    }</p>
<pre><code>//获取方法列表
<span class="type">Method</span> *methodList = class_copyMethodList([self class], &amp;count);
<span class="keyword">for</span> (unsigned <span class="type">int</span> i; i&lt;count; i++) {
    <span class="type">Method</span> <span class="keyword">method</span> = methodList[i];
    <span class="type">NSLog</span>(@<span class="string">"method----&gt;%@"</span>, <span class="type">NSStringFromSelector</span>(method_getName(<span class="keyword">method</span>)));
}

//获取成员变量列表
<span class="type">Ivar</span> *ivarList = class_copyIvarList([self class], &amp;count);
<span class="keyword">for</span> (unsigned <span class="type">int</span> i; i&lt;count; i++) {
    <span class="type">Ivar</span> myIvar = ivarList[i];
    <span class="keyword">const</span> <span class="type">char</span> *ivarName = ivar_getName(myIvar);
    <span class="type">NSLog</span>(@<span class="string">"Ivar----&gt;%@"</span>, [<span class="type">NSString</span> stringWithUTF8String:ivarName]);
}

//获取协议列表
__unsafe_unretained <span class="type">Protocol</span> **protocolList = class_copyProtocolList([self class], &amp;count);
<span class="keyword">for</span> (unsigned <span class="type">int</span> i; i&lt;count; i++) {
    <span class="type">Protocol</span> *myProtocal = protocolList[i];
    <span class="keyword">const</span> <span class="type">char</span> *protocolName = protocol_getName(myProtocal);
    <span class="type">NSLog</span>(@<span class="string">"protocol----&gt;%@"</span>, [<span class="type">NSString</span> stringWithUTF8String:protocolName]);
}
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在Xcode上跑一下看看输出吧，需要给你当前的类写几个属性，成员变量，方法和协议，不然获取的列表是没有东西的。</span><br><span class="line">注意，调用这些获取列表的方法别忘记导入头文件`<span class="preprocessor">#import &lt;objc/runtime.h&gt;`</span></span><br><span class="line"><span class="preprocessor">#### 方法调用</span></span><br><span class="line">让我们看一下方法调用在运行时的过程（参照前文类在runtime中的表示）</span><br><span class="line"><span class="preprocessor">##### 如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。</span></span><br><span class="line"><span class="preprocessor">##### 如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。</span></span><br><span class="line"> <span class="number">1.</span> 首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行。</span><br><span class="line"> <span class="number">2.</span> 如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行</span><br><span class="line"> <span class="number">3.</span> 如果没找到，去父类指针所指向的对象中执行<span class="number">1</span>，<span class="number">2.</span></span><br><span class="line"> <span class="number">4.</span> 以此类推，如果一直到根类还没找到，转向拦截调用。</span><br><span class="line"> <span class="number">5.</span> 如果没有重写拦截调用的方法，程序报错。</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">##### 以上的过程给我带来的启发：</span></span><br><span class="line"> </span><br><span class="line"> * 重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法后就不会再去父类中找了。</span><br><span class="line"> * 如果想调用已经重写过的方法的父类的实现，只需使用`super`这个编译器标识，它会在运行时跳过在当前的类对象中寻找方法的过程。</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#### 拦截调用</span></span><br><span class="line">在方法调用中说到了，如果没有找到方法就会转向拦截调用。</span><br><span class="line">那么什么是拦截调用呢。</span><br><span class="line">拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写`NSObject`的四个方法来处理。</span><br></pre></td></tr></table></figure>
<ul>
<li>(BOOL)resolveClassMethod:(SEL)sel;</li>
<li>(BOOL)resolveInstanceMethod:(SEL)sel;<br>//后两个方法需要转发到其他的类处理</li>
</ul>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector;</li>
<li>(void)forwardInvocation:(NSInvocation *)anInvocation;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  * 第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</span><br><span class="line">  * 第二个方法和第一个方法相似，只不过处理的是实例方法。</span><br><span class="line">  * 第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。</span><br><span class="line"><span class="label">  * 第四个方法是将你调用的不存在的方法打包成`NSInvocation`传给你。做完你自己的处理后，调用`invokeWithTarget:<span class="escape">`方</span></span>法让某个target触发这个方法。</span><br><span class="line">  </span><br><span class="line">#### 动态添加方法 </span><br><span class="line">重写了拦截调用的方法并且返回了YES，我们要怎么处理呢？</span><br><span class="line">有一个办法是根据传进来的<span class="escape">`S</span>EL<span class="escape">`类</span>型的<span class="escape">`s</span>elector<span class="escape">`动</span>态添加一个方法。</span><br><span class="line">首先从外部隐式调用一个不存在的方法：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//隐式调用方法<br>[target performSelector:@selector(resolveAdd:) withObject:@”test”];<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，在<span class="keyword">target</span>对象内部重写拦截调用的方法，动态添加方法。</span><br></pre></td></tr></table></figure></p>
<p>void runAddMethod(id self, SEL _cmd, NSString *string){<br>    NSLog(@”add C IMP “, string);<br>}</p>
<ul>
<li><p>(BOOL)resolveInstanceMethod:(SEL)sel{</p>
<p>  //给本类动态添加一个方法<br>  if ([NSStringFromSelector(sel) isEqualToString:@”resolveAdd:”]) {</p>
<pre><code>class_addMethod<span class="list">(<span class="keyword">self</span>, sel, <span class="list">(<span class="keyword">IMP</span>)</span>runAddMethod, <span class="string">"v@:*"</span>)</span><span class="comment">;</span>
</code></pre><p>  }<br>  return YES;<br>}</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 其中<span class="string">`class_addMethod`</span>的四个参数分别是：</span><br><span class="line"> <span class="number">1</span>. <span class="string">`Class cls `</span>给哪个类添加方法，本例中是<span class="keyword">self</span></span><br><span class="line"> <span class="number">2</span>. <span class="string">`SEL name `</span>添加的方法，本例中是重写的拦截调用传进来的selector。</span><br><span class="line"> <span class="number">3</span>. <span class="string">`IMP imp `</span>方法的实现，<span class="constant">C</span>方法的方法实现可以直接获得。如果是<span class="constant">OC</span>方法，可以用<span class="string">`+ (IMP)instanceMethodForSelector:(SEL)aSelector;`</span>获得方法的实现。</span><br><span class="line"> <span class="number">4</span>. <span class="string">`"v@:*"`</span>方法的签名，代表有一个参数的方法。</span><br><span class="line"> </span><br><span class="line"><span class="comment">#### 关联对象</span></span><br><span class="line">现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。</span><br><span class="line">这种情况的一般解决办法就是继承。</span><br><span class="line">但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。</span><br><span class="line">这个时候，runtime的关联属性就发挥它的作用了。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//首先定义一个全局变量，用它的地址作为关联对象的key<br>static char associatedObjectKey;<br>//设置关联对象<br>objc_setAssociatedObject(target, &amp;associatedObjectKey, @”添加的字符串属性”, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象<br>NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);<br>NSLog(@”AssociatedObject = %@”, string);<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">`o</span>bjc_setAssociatedObject<span class="escape">`的</span>四个参数：</span><br><span class="line"><span class="number">1</span>. <span class="escape">`i</span>d object<span class="escape">`给</span>谁设置关联对象。</span><br><span class="line"><span class="number">2</span>. ·const void *key·关联对象唯一的key，获取时会用到。</span><br><span class="line"><span class="number">3</span>. <span class="escape">`i</span>d value<span class="escape">`关</span>联对象。</span><br><span class="line"><span class="number">4</span>. <span class="escape">`o</span>bjc_AssociationPolicy<span class="escape">`关</span>联策略，有以下几种策略：</span><br></pre></td></tr></table></figure></p>
<p>enum {<br>    OBJC_ASSOCIATION_ASSIGN = 0,<br>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,<br>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,<br>    OBJC_ASSOCIATION_RETAIN = 01401,<br>    OBJC_ASSOCIATION_COPY = 01403<br>};<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果你熟悉OC，看名字应该知道这几种策略的意思了吧。</span><br><span class="line"><span class="escape">`o</span>bjc_getAssociatedObject<span class="escape">`的</span>两个参数。</span><br><span class="line"><span class="number">1</span>. <span class="escape">`i</span>d object<span class="escape">`获</span>取谁的关联对象。</span><br><span class="line"><span class="number">2</span>. <span class="escape">`c</span>onst void *key<span class="escape">`根</span>据这个唯一的key获取关联对象。</span><br><span class="line"></span><br><span class="line">其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。</span><br></pre></td></tr></table></figure></p>
<p>//添加关联对象</p>
<ul>
<li>(void)addAssociatedObject:(id)object{<br>  objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}<br>//获取关联对象</li>
<li>(id)getAssociatedObject{<br>  return objc_getAssociatedObject(self, _cmd);<br>}<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**注意：**这里面我们把<span class="escape">`g</span>etAssociatedObject<span class="escape">`方</span>法的地址作为唯一的<span class="escape">`k</span>ey<span class="escape">`，</span><span class="escape">`_</span>cmd<span class="escape">`代</span>表当前调用方法的地址。</span><br><span class="line"></span><br><span class="line">#### 方法交换</span><br><span class="line">方法交换，顾名思义，就是将两个方法的实现交换。例如，将<span class="literal">A</span>方法和B方法交换，调用<span class="literal">A</span>方法的时候，就会执行B方法中的代码，反之亦然。</span><br><span class="line">话不多说，这是参考Mattt大神在NSHipster上的文章自己写的代码。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#import “UIViewController+swizzling.h”</p>
<p>#import <objc runtime.h=""></objc></p>
<p>@implementation UIViewController (swizzling)</p>
<p>//load方法会在类第一次加载的时候被调用<br>//调用的时间比较靠前，适合在这个方法里做方法交换</p>
<ul>
<li><p>(void)load{<br>  //方法交换应该被保证，在程序中只会执行一次<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{</p>
<pre><code><span class="comment">//获得viewController的生命周期方法的selector</span>
SEL systemSel = @<span class="keyword">selector</span>(viewWillAppear:);
<span class="comment">//自己实现的将要被交换的方法的selector</span>
SEL swizzSel = @<span class="keyword">selector</span>(swiz_viewWillAppear:);
<span class="comment">//两个方法的Method</span>
<span class="function"><span class="keyword">Method</span> <span class="title">systemMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">([<span class="keyword">self</span> <span class="keyword">class</span>], systemSel)</span>;</span>
<span class="function"><span class="keyword">Method</span> <span class="title">swizzMethod</span> = <span class="title">class_getInstanceMethod</span><span class="params">([<span class="keyword">self</span> <span class="keyword">class</span>], swizzSel)</span>;</span>

<span class="comment">//首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span>
BOOL isAdd = class_addMethod(<span class="keyword">self</span>, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
<span class="keyword">if</span> (isAdd) <span class="comment">{
    //如果成功，说明类中不存在这个方法的实现
    //将被交换方法的实现替换到这个并不存在的实现
    class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
}</span><span class="keyword">else</span><span class="comment">{
    //否则，交换两个方法的实现
    method_exchangeImplementations(systemMethod, swizzMethod);
}</span>
</code></pre><p>  });<br>}</p>
</li>
</ul>
<ul>
<li>(void)swiz_viewWillAppear:(BOOL)animated{<br>  //这时候调用自己，看起来像是死循环<br>  //但是其实自己的实现已经被替换了<br>  [self swiz_viewWillAppear:animated];<br>  NSLog(@”swizzle”);<br>}</li>
</ul>
<p>@end<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个自己定义的viewController中重写viewWillAppear</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)viewWillAppear:(BOOL)animated{<br>  [super viewWillAppear:animated];<br>  NSLog(@”viewWillAppear”);<br>}<br>```<br>Run起来看看输出吧！</li>
</ul>
<p><strong>我的理解:</strong></p>
<ul>
<li>方法交换对于我来说更像是实现一种思想的最佳技术：AOP面向切面编程。</li>
<li>既然是切面，就一定不要忘记，交换完再调回自己。</li>
<li>一定要保证只交换一次，否则就会很乱。</li>
<li>最后，据说这个技术很危险，谨慎使用。</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/08/16/EGOCache-check-cache-expired/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">EGOCache如何检测缓存时间过期</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 苹果
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>