<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="keywords" content="键盘的记忆,iOS学习,html5,混合开发">
  
  <title>键盘的记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客,记录重要知识,iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="键盘的记忆">
<meta property="og:url" content="http://blog.onecat.cc/page/2/index.html">
<meta property="og:site_name" content="键盘的记忆">
<meta property="og:description" content="写博客,记录重要知识,iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="键盘的记忆">
<meta name="twitter:description" content="写博客,记录重要知识,iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="键盘的记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">键盘</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">键盘</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">键盘</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-详解CALayer-和-UIView的区别和联系" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/03/详解CALayer-和-UIView的区别和联系/" class="article-date">
  	<time datetime="2015-09-03T12:45:12.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/03/详解CALayer-和-UIView的区别和联系/">详解CALayer 和 UIView的区别和联系</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>前面发了一篇iOS 面试的文章，在说到 UIView 和 CALayer 的区别和联系的时候，被喵神指出没有切中要点，所以这里就 CALayer 和 UIView 这个问题重新整理了下。这里会先分条解释，最后会在文章的结尾给出概括性总结。</p>
<h4 id="1-首先UIView可以响应事件，Layer不可以-">1.首先UIView可以响应事件，Layer不可以.</h4><p>UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。</p>
<p>在 UIResponder中定义了处理各种事件和事件传递的接口, 而 CALayer直接继承 NSObject，并没有相应的处理事件的接口。</p>
<p>下面列举一些处理触摸事件的接口</p>
<ul>
<li>– touchesBegan:withEvent:</li>
<li>– touchesMoved:withEvent:</li>
<li>– touchesEnded:withEvent:</li>
<li>– touchesCancelled:withEvent:<br>其实还有一些运动和远程控制事件等等，这里就不一一列举了。</li>
</ul>
<p>下面的两篇文章详细介绍了 iOS 事件的处理和传递</p>
<p>参考链接：</p>
<ol>
<li><a href="http://blog.csdn.net/chun799/article/details/8223612" target="_blank" rel="external">http://blog.csdn.net/chun799/article/details/8223612</a></li>
<li><a href="http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html" target="_blank" rel="external">http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html</a></li>
</ol>
<h4 id="2-View和CALayer的Frame映射及View如何创建CALayer-">2.View和CALayer的Frame映射及View如何创建CALayer.</h4><p>一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属性。（PS:center有些特列）为了证明这些，我做了如下的测试。</p>
<p>首先我自定义了两个类CustomView,CustomLayer分别继承 UIView 和 CALayer</p>
<p>在 CustomView 中重写了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [CustomLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenter:(<span class="built_in">CGPoint</span>)center</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setCenter:center];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setBounds:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在 CustomLayer中同样重写这些方法。只是 <code>setCenter</code>方法改成<code>setPosition</code>方法</p>
<p>我在两个类的初始化方法中都打下了断点<img src="/images/Snip20150820_12.png" alt="image"></p>
<p>首先我们会发现，我们在 [view initWithFrame] 的时候调用私有方法【UIView _createLayerWithFrame】去创建 CALayer。</p>
<p>然后我在创建 View 的时候，在 Layer 和 View 中Frame 相关的所有方法中都加上断点，可以看到大致如下的调用顺序如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[UIView _createLayerWithFrame]</span><br><span class="line">[Layer setBounds:bounds]</span><br><span class="line">[UIView setFrame：Frame]</span><br><span class="line">[Layer setFrame:frame]</span><br><span class="line">[Layer setPosition:position]</span><br><span class="line">[Layer setBounds:bounds]</span><br></pre></td></tr></table></figure></p>
<p>我发现在创建的过程只有调用了 Layer 的设置尺寸和位置的然而并没有调用View 的 <code>SetCenter</code> 和 <code>SetBounds</code> 方法。<br>然后我发现当我修改了 view的 <code>bounds.size</code> 或者 <code>bounds.origin</code> 的时候也只会调用上边 Layer的一些方法。所以我大胆的猜一下，View 的 Center 和 Bounds 只是直接返回layer 对应的 Position 和 Bounds.</p>
<p>View中frame getter方法，bounds和center，UIView并没有做什么工作；它只是简单的各自调用它底层的CALayer的frame，bounds和position方法。</p>
<p>关于 Frame 的理解参考：<a href="http://www.cocoachina.com/industry/20131209/7498.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20131209/7498.html</a></p>
<h4 id="3-UIView主要是对显示内容的管理而_CALayer_主要侧重显示内容的绘制。">3.UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制。</h4><p>我在 UIView 和 CALayer 分别重写了父类的方法。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[UIView drawRect:rect]</span><span class="comment">//UIView    </span></span><br><span class="line"></span><br><span class="line"><span class="attr_selector">[CALayer display]</span><span class="comment">//CALayer</span></span><br></pre></td></tr></table></figure></p>
<p>然后我在上面两个方法加了断点，可以看到如下的执行。<br><img src="/images/Snip20150820_11.png" alt="image"></p>
<p>可以看到 UIView 是 CALayer 的CALayerDelegate，我猜测是在代理方法内部[UIView(CALayerDelegate) drawLayer:inContext]调用 UIView 的 DrawRect方法，从而绘制出了 UIView 的内容.</p>
<h4 id="4-在做_iOS_动画的时候，修改非_RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。">4.在做 iOS 动画的时候，修改非 RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。</h4><p>对于每一个 UIView 都有一个 layer,把这个 layer 且称作RootLayer,而不是 View 的根 Layer的叫做 非 RootLayer。我们对UIView的属性修改时时不会产生默认动画，而对单独 layer属性直接修改会，这个默认动画的时间缺省值是0.25s.<br>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对为什么会这样做出了一个解释：</p>
<blockquote>
<p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p>
</blockquote>
<p>是因为任何可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 CAAction)。</p>
<p>layer 通过向它的 delegate 发送 actionForLayer:forKey: 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>
<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。</li>
<li>它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。</li>
<li>它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。<br>当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</li>
</ol>
<p>这部分的具体内容参考：<a href="http://objccn.io/issue-12-4/" target="_blank" rel="external">http://objccn.io/issue-12-4/</a></p>
<h3 id="总结">总结</h3><p>总接来说就是如下几点：</p>
<ul>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ul>
<h4 id="参考链接">参考链接</h4><p><a href="http://blog.csdn.net/weiwangchao_/article/details/7771538" target="_blank" rel="external">http://blog.csdn.net/weiwangchao_/article/details/7771538</a></p>
<blockquote>
<p>转自 <a href="http://www.jianshu.com/p/079e5cf0f014" target="_blank" rel="external">http://www.jianshu.com/p/079e5cf0f014</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS开发之UITableView性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/31/iOS开发之UITableView性能优化/" class="article-date">
  	<time datetime="2015-08-31T15:28:25.000Z" itemprop="datePublished">2015-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/iOS开发之UITableView性能优化/">iOS开发之UITableView性能优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面已经说过UITableView中的单元格cell是在显示到用户可视区域后创建的，那么如果用户往下滚动就会继续创建显示在屏幕上的单元格，如果用户向上滚动返回到查看过的内容时同样会重新创建之前已经创建过的单元格。如此一来即使UITableView的内容不是太多，如果用户反复的上下滚动，内存也会瞬间飙升，更何况很多时候UITableView的内容是很多的（例如微博展示列表，基本向下滚动是没有底限的）。</p>
<p>前面一节中我们曾经提到过如何优化UIScrollView，当时就是利用有限的UIImageView动态切换其内容来尽可能减少资源占用。同样的，在UITableView中也可以采用类似的方式，只是这时我们不是在滚动到指定位置后更改滚动的位置而是要将当前没有显示的Cell重新显示在将要显示的Cell的位置然后更新其内容。原因就是UITableView中的Cell结构布局可能是不同的，通过重新定位是不可取的，而是需要重用已经不再界面显示的已创建过的Cell。</p>
<p>当然，听起来这么做比较复杂，其实实现起来很简单，因为UITableView已经为我们实现了这种机制。在UITableView内部有一个缓存池，初始化时使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)方法指定一个可重用标识，就可以将这个cell放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的cell然后修改cell内容即可。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark返回每行的单元格</span></span><br><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="comment">//NSIndexPath是一个对象，记录了组和行信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成单元格(组：%i,行%i)"</span>,indexPath<span class="variable">.section</span>,indexPath<span class="variable">.row</span>);</span><br><span class="line">    KCContactGroup *group=_contacts[indexPath<span class="variable">.section</span>];</span><br><span class="line">    KCContact *contact=group<span class="variable">.contacts</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于此方法调用十分频繁，cell的标示声明成静态变量有利于性能优化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier=<span class="string">@"UITableViewCellIdentifierKey1"</span>;</span><br><span class="line">    <span class="comment">//首先根据标识去缓存池取</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    <span class="comment">//如果缓存池没有到则重新创建并放到缓存池中</span></span><br><span class="line">    <span class="keyword">if</span>(!cell)&#123;</span><br><span class="line">        cell=[[<span class="built_in">UITableViewCell</span> alloc]initWithStyle:<span class="built_in">UITableViewCellStyleValue1</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span>=[contact getName];</span><br><span class="line">    cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span>=contact<span class="variable">.phoneNumber</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cell:%@"</span>,cell);</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中已经打印了cell的地址，如果大家运行测试上下滚动UITableView会发现滚动时创建的cell地址是初始化时已经创建的。</p>
<p>这里再次给大家强调两点：</p>
<ul>
<li>-(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)方法调用很频繁，无论是初始化、上下滚动、刷新都会调用此方法，所有在这里执行的操作一定要注意性能；</li>
<li>可重用标识可以有多个，如果在UITableView中有多类结构不同的Cell，可以通过这个标识进行缓存和重新；</li>
</ul>
<blockquote>
<p>转 Kenshin Cui’s Blog</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tableview优化/">tableview优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-html5-audio-使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/30/html5-audio-使用/" class="article-date">
  	<time datetime="2015-08-29T16:02:33.000Z" itemprop="datePublished">2015-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/30/html5-audio-使用/">html5 audio 使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做html5 使用到了audio，发现audio在移动设备上面不能够自动播放<code>autoplay</code>属性没用</p>
<p>求解</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-怎么成为一名黑客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/27/怎么成为一名黑客/" class="article-date">
  	<time datetime="2015-08-27T15:10:14.000Z" itemprop="datePublished">2015-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/27/怎么成为一名黑客/">怎么成为一名黑客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我有不少黑客朋友。他们有的学医，有的学数学，有的学建筑，有的做安全之前的职业是开中巴。恩，当然，也有不少是计算机科班出身的。</p>
<p>这帮人，是怎么成为黑客的？</p>
<h4 id="会动脑">会动脑</h4><ul>
<li><p>最最重要的是「逆向思维」——所谓的「黑掉你，不在你关注的那个点上」（能独立思考，不人云亦云，善挖掘，不从众，懂大众心理，还懂得利用大众心理的「漏洞」）；</p>
</li>
<li><p>在网络攻防中找案例，我顺手搜了一个「自己打自己」的案例：简单一步即可扫描360内部系统安全漏洞（扫描器攻击技巧），出处为乌云：<a href="http://t.cn/RLeNiMY；" target="_blank" rel="external">http://t.cn/RLeNiMY；</a></p>
</li>
<li><p>逆向思维不仅仅适用于「暗黑领域」。实际上，无论你学的是什么，从事的是什么职业，这种思维模式都无比珍贵，拥有它，你有机会成为任意领域的黑客；</p>
</li>
<li><p>在军事上找类比，想想「马奇诺防线」，想想「围魏救赵」，再想想「黑掉你，不在你关注的那个点上」，你是不是领悟到了点什么？</p>
</li>
<li><p>一个漫画（出自 XKCD）：<br><img src="/images/42062-c7873b7151f31d5a.png" alt="图"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安全死宅想象中，自己的安全设计固若金汤：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑加密了，咱得砸个百万美金破掉它！</span><br><span class="line">恶人乙：嚓，想得美，是 <span class="number">4096</span> 位密码耶！</span><br><span class="line">恶人甲：倒霉，认栽吧，撤！</span><br><span class="line"></span><br><span class="line">真实世界里：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑居然加密！拿五美金买个扳手，扁他。扁到他说出密码为止！</span><br><span class="line">恶人乙：好咧。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>扁到他说出密码为止！恩，这就是我最推崇的思维能力（别领会错了，不是暴力，是不受你的规则限制）。</p>
<h4 id="肯学习">肯学习</h4><ul>
<li><p>那个学医的黑客（TK）在微博上说：漏洞产业很像玉石产业。漏洞生于脑，玉石出自矿。矿里有没有玉，要挖一挖。思路可不可行，要试一试。挖出矿石是不是玉，要开窗看。Crash 能不能变成 PoC，要调一调。矿石里的玉多大、什么成色，得整个磨开。PoC 好不好利用，要写成 Exploit。而后玉石雕成器，Exploit 写成真正的工具，会再价值大增；</p>
</li>
<li><p>挖、试、看、调、磨……各位看着各种黑客大赛，几秒攻破某某系统时，有没有想过台上一分钟，台下十年功？</p>
</li>
<li><p>我从业生涯中遇到的，真正笨和天才的人很少。有不少人「以为自己比实际上聪明」地走捷径，反而绕远，不如日拱一卒走得稳健长远；</p>
</li>
<li><p>如果你问：我肯学习，但是该学什么？怎么学？请参见第一条：「会动脑」。</p>
</li>
</ul>
<h4 id="重实践">重实践</h4><ul>
<li><p>纸上得来终觉浅。绝大多数人都是「听过很多道理，依然过不好这一生」的，路要自己走，错误要自己犯，一行行代码要自己写，一个个绕过限制的奇技淫巧要自己苦思冥想。突破了，收获就是自己的；</p>
</li>
<li><p>实践的方法很多，比如长期做一个开源软件（做之前请先动脑想清楚做什么、为什么做、值不值得长期做等一系列问题）、比如写文章记录自己的学习历程、比如把历史上著名的漏洞撸一遍并分享代码和心得……</p>
</li>
</ul>
<h4 id="走正道">走正道</h4><ul>
<li><p>玩黑客攻防这个行当，脑洞一旦开了，很容易发现不少地方可以快速挣钱。但「伸手」之前，请想清楚：会上瘾！尝过轻松来钱的滋味后，再想踏实做事就难了。</p>
</li>
<li><p>常在河边走，哪有不湿鞋。</p>
</li>
</ul>
<blockquote>
<p>转 <a href="http://www.jianshu.com/p/611b32c50fa2" target="_blank" rel="external">http://www.jianshu.com/p/611b32c50fa2</a></p>
</blockquote>
<p>最近一直想破机附近的wifi密码 ^_^</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-AVFoundation和-GPUImage初探" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/26/AVFoundation和-GPUImage初探/" class="article-date">
  	<time datetime="2015-08-26T15:21:58.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/26/AVFoundation和-GPUImage初探/">AVFoundation和 GPUImage初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>
<h4 id="AVFoundation的一些基本概念">AVFoundation的一些基本概念</h4><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。<br><img src="/images/ba81ca29gw1evcbinsawmj20qj0go0tt.jpg" alt="ba81ca29gw1evcbinsawmj20qj0go0tt"></p>
<h4 id="相关类">相关类</h4><ul>
<li>AVAsset</li>
<li>AVAssetTrack</li>
<li>AVComposition</li>
<li>AVVideoComposition</li>
<li>AVAudioMix</li>
<li>AVMutableAudioMixInputParameter</li>
<li>AVMutableVideoCompositionInstrution</li>
<li>AVMutableVideoCompositionLayerInstrution<br>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录<br>制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</li>
</ul>
<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。<br><img src="/images/ba81ca29gw1evcbjm927vj20jm0hsmzv.jpg" alt="ba81ca29gw1evcbjm927vj20jm0hsmzv"><br>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>
<p>typedef struct<br>{<br>CMTimeValue value;<br>CMTimeScale timescale;<br>CMTimeFlags flags;<br>CMTimeEpoch epoch;<br>} CMTime;<br>通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看这里。</p>
<h3 id="进阶">进阶</h3><h4 id="视频的录制">视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、<br>AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。<br><img src="capture.png"><br>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *<span class="keyword">array</span> = [output.metadta mutableCopy];</span><br><span class="line">AVMutableMetadataItem *<span class="literal">item</span> = [[AVMutableMetadataItem alloc] init];</span><br><span class="line"><span class="literal">item</span>.keyspace = ...;</span><br><span class="line"><span class="literal">item</span>.key = ...;</span><br><span class="line"><span class="literal">item</span>.<span class="keyword">value</span> = ...;</span><br><span class="line">[<span class="keyword">array</span> addObject:item];</span><br><span class="line">output.metadata = <span class="keyword">array</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">    session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[session beginConfiguration]</span>;</span><br><span class="line"><span class="comment">//移除某个输入源</span></span><br><span class="line"><span class="comment">//再添加某个输入源</span></span><br><span class="line"><span class="comment">//再为新添加的输入源进行必要的相关设置</span></span><br><span class="line"><span class="comment">//...其他操作</span></span><br><span class="line"><span class="attr_selector">[session commitConfiguration]</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现 captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput<span class="variable">.videoSettings</span> = newSettings;</span><br></pre></td></tr></table></figure>
<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span></span><br><span class="line">- (<span class="keyword">void</span>)yourCustomMethodName&#123;</span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">            session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(session canAddInput:input)&#123;</span><br><span class="line">        [session addInput:input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span>(session canAddOutput:output)&#123;</span><br><span class="line">        [session addOutput:output];</span><br><span class="line">    &#125;</span><br><span class="line">    output<span class="variable">.videoSettings</span> =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">    <span class="comment">//设置帧率(FPS),每秒15帧</span></span><br><span class="line">    output<span class="variable">.minFrameDuration</span> = CMTimeMake(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"CustomQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue)</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用来显示录制的实时画面</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:captureVideoPreviewLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户是否允许启用摄像头</span></span><br><span class="line">    [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Granted access to mediaType</span></span><br><span class="line">            [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">            [session startRunning];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span></span><br><span class="line">                                        message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span></span><br><span class="line">                                       delegate:<span class="keyword">self</span></span><br><span class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></span><br><span class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                    [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];</span><br><span class="line">NSURL *fileURL = ...;    <span class="comment">//存放位置</span></span><br><span class="line"><span class="comment">//指定代理</span></span><br><span class="line">[aMovieFileOutput <span class="string">startRecordingToOutputFileURL:</span>fileURL <span class="string">recordingDelegate:</span>delete];</span><br><span class="line"><span class="comment">//也可以为其指定outputSettings</span></span><br><span class="line">同样代理必须实现协议方法<span class="string">captureOutput:</span><span class="string">didFinishRecordingToOutputFileAtURL:</span><span class="string">fromConnections:</span><span class="string">error:</span>,</span><br></pre></td></tr></table></figure></p>
<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到更多。</p>
<h4 id="视频的剪辑">视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图<br><img src="/images/ba81ca29gw1evcblhcl2ej20p50eyjvj.jpg" alt="ba81ca29gw1evcblhcl2ej20p50eyjvj"></p>
<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。<br>关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见这里。</p>
<p>其中图中1，2，3用到的方法为<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[1]</span></span><br><span class="line"><span class="title">[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]</span></span><br><span class="line"><span class="title">[2]</span></span><br><span class="line"><span class="title">[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]</span><span class="comment">;`</span></span><br><span class="line"><span class="title">[3]</span></span><br><span class="line"><span class="title">[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]</span></span><br></pre></td></tr></table></figure></p>
<p>关于视频的剪辑的代码可以参见苹果给出的官方Demo以及Raywendrich上的两篇文章1,2。</p>
<h3 id="GPUImage">GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<h4 id="分段录制">分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Add</span> audio capture to the session. <span class="type">Adding</span> inputs <span class="keyword">and</span> outputs freezes </span><br><span class="line">//the capture session momentarily, so you can use this <span class="keyword">method</span> to add </span><br><span class="line">//the audio inputs <span class="keyword">and</span> outputs early, <span class="keyword">if</span> you’re going to <span class="type">set</span> the </span><br><span class="line">//audioEncodingTarget later. <span class="type">Returns</span> <span class="type">YES</span> <span class="keyword">is</span> the audio inputs <span class="keyword">and</span> </span><br><span class="line">//outputs were added, <span class="keyword">or</span> <span class="type">NO</span> <span class="keyword">if</span> they had already been added.</span><br><span class="line"></span><br><span class="line">-(<span class="type">BOOL</span>)addAudioInputsAndOutputs;</span><br></pre></td></tr></table></figure>
<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>
<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你分段录制的实现,GPUImageExtend。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>
<h4 id="所见即所得">所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>
<pre><code><span class="number">1.</span>使用GPUImageCropFilter,通过设置其cropRegion来裁出中间<span class="number">540</span>x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在<span class="number">0.0</span>~<span class="number">1.0</span>范围内,比如<span class="number">960</span>x540裁剪至中间<span class="number">540</span>x540部分则cropRegion为(<span class="number">0</span>,((<span class="number">960</span>-<span class="number">540</span>)/<span class="number">2</span>)/<span class="number">960</span>,<span class="number">1</span>,<span class="number">540</span>/<span class="number">960</span>)
<span class="number">2.</span>改变videoComposition的perferTransfom使其只显示中间的<span class="number">540</span>x540。
</code></pre><p>这样就完成了所见即所得。</p>
<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个issue和一些解决办法。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>
<h4 id="总结">总结</h4><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-UIButton-UIEdgeinsets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/UIButton-UIEdgeinsets/" class="article-date">
  	<time datetime="2015-08-25T15:51:55.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/UIButton-UIEdgeinsets/">UIButton中的三个UIEdgeInsets属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UIEdgeInsets是什么</p>
<p><code>UIEdgeInsets</code>是什么？我们点进去看一下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct UIEdgeInsets &#123;</span><br><span class="line">    CGFloat <span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>;  <span class="comment">// specify amount to inset (positive) for each of the edges. values can be negative to 'outset'</span></span><br><span class="line">&#125; UIEdgeInsets;</span><br><span class="line">UIEdgeInsets是个结构体类型。里面有四个参数，分别是：<span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</span><br></pre></td></tr></table></figure>
<p>哪三个UIEdgeInsets属性</p>
<p>不知道大家发现没有，UIButton里面有三个UIEdgeInsets属性，分别是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> contentEdgeInsets <span class="built_in">UI_APPEARANCE_SELECTOR</span>; <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure></p>
<p>contentEdgeInsets后面有个UI_APPEARANCE_SELECTOR是什么意思呢？</p>
<blockquote>
<p>提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。<br>举例，设置UIButton的contentEdgeInsets属性，可以直接调用：<br><code>[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> titleEdgeInsets;                <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> imageEdgeInsets;                <span class="comment">//default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-谁让APP工程师产生了泡沫？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/谁让APP工程师产生了泡沫？/" class="article-date">
  	<time datetime="2015-08-25T14:54:56.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/谁让APP工程师产生了泡沫？/">谁让APP工程师产生了泡沫？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两年移动互联网比较火，移动APP的开发人员也是比较紧缺。</p>
<p>面试了一个做APP的，能力很一般，态度也比较傲慢。最后感觉肯定不会用这个人了，但是出于验证自己想法的目的，还是很诚恳地以一个决定录取他的态度，和他交谈。</p>
<p>“刚才我问了你一些问题，可能比较偏，或者不是你所擅长的。我也是本着为公司负责的态度，问一些我们经常用到的问题。这一点请见谅。”，我说。</p>
<p>他说：“没事的，问的确实有点偏。实际工作中，根本用不到，用到了现查就行，网上好多例子，复制粘贴都能搞定！”。</p>
<p>我说，我们企业招一个人，你入职一个企业，是一个相互选择的事情。我问完你了，你对我们公司有什么想了解的。</p>
<p>他有点发楞，停顿了一会。我提示他，公司的业务发展，个人的提升空间，你的职业规划？</p>
<p>他说，噢，咱们公司是做什么的？</p>
<p>我回答道，我们主业务是做基于社区的O2O平台的，现在业务有几块，深度垂直做上门推拿服务，打通商家上下游做云商供应链，最终将打造一个庞大的社区服务生态体系。</p>
<p>他似乎没有听懂，依然发楞。</p>
<p>“还有什么想问的吗？”我问。</p>
<p>他似乎早想问，一直不好意思问，但是又不想在这浪费时间了，问道：“公司都有什么福利，年终奖是多少，加班费怎么算……”。</p>
<p>我都一一回答了。</p>
<p>沉默了一会。</p>
<p>我问道：“你能接受的最低待遇是多少？”</p>
<p>他说，就是简历上写的那些。</p>
<p>我死死地盯着他：“如果我给你降一千你愿意吗？”</p>
<p>他摇了摇头。</p>
<p>“降五百呢？”</p>
<p>他回答说：“我已经面试了四五家公司了，他们都要我，我也答应了。现在就是再面试几家，看看哪家更高。所以，我没必要……”，他向我耸肩，然后不说了。</p>
<p>我说，你要的这个数，在我们公司不算高，好多人都拿的比这个多呢。你去过的那几家公司，多少人？</p>
<p>他说，也得有，差不多，估计一百多人吧。</p>
<p>我问，做APP的多少人？</p>
<p>他回答，一两个，有的没有，我去了是第一个。</p>
<p>谁面试的你，我问。</p>
<p>有的是经理，有的是老板，都很希望我能快点入职。</p>
<p>我说，好的，我们会把你面试的情况和你做的作品评估一下，然后再联系你。</p>
<p>他走了。</p>
<p>这不是个例。</p>
<p>大多数年轻人都差不多这样。</p>
<p>他们没房没车没压力，以单纯的收入高低作为亲友间的炫耀和比较的资本。</p>
<p>让我陷入沉思的是，为什么一个近乎只能称得上操作和修理工的人，却顶着一个工程师的名号，可以到处要高价，而且还真有公司愿意给。享受能力所不匹配的东西，这显然是一种病态，结果必定可悲。谁赋予了他们这样的优厚际遇？或者，谁成心想害他们？</p>
<p>答案是这个飞速发展时代和无可奈何的企业。</p>
<p>移动互联网，这五个字可谓炙手可热。互联网+，又让这热度增上三分。好多公司都想搭上这艘船，捞一桶金，弄不巧还会成就一番霸业。</p>
<p>怎么搞？好多人都觉得移动互联网就是个APP。想踏入移动互联网，首先要搞一个APP出来，拿出去好说话嘛！这种想法就像是，我研发个POS机有一家银行了能做金融了一样。你的POS机之所以能刷卡转移资金，是因为后面还有一个银行体系支撑，来了钱给谁，扣的钱从哪里出，是有一套服务做支撑的。这套服务，相比一个POS机而言，大象和蚂蚁的关系。还不明白的话，去五金店买一个淋浴头，在太阳下试试会不会喷水，那个淋浴头就是业务中的APP。</p>
<p>好多小企业老板很明白政治和经济局势，但是不明白技术，他们觉得第一步先需要APP，其他的根据需求再说。于是，他们老板甚至亲自面试，随便聊聊天，要多少给多少就招进来了，先有人开个头再说呗。最后，发现不是这么一回事，有了淋浴头了还需要水管才能喷水，自己建供水系统太大，在小区建使用人群太少，连接卫生间的水管，跟自己又没啥关系。命长公司的干上半年，招的人也不专业，凑合随便弄一个出来，员工感觉老板瞎弄没有成就感，老板也感觉看错了人不出成绩。于是，一拍两散。</p>
<p>出来的这人再换工作，感觉自己没有被完全发挥出来，现在工作经验也涨了，薪水肯定也得涨。于是，又找到一个公司，老板一看，这人以前待遇都那么高，那老板肯定不傻，做了那么久了也有成果，我这又急需要人，再涨一段吧。这个公司干半年，和上一个公司一样循环，直到一个顶点。</p>
<p>这就造成了，个人技术没有实质提高，待遇却虚高。公司支出增加了，回报却没有增加。</p>
<p>这就是泡沫啊，在慢慢膨胀的泡沫。这泡沫在小企业中很明显，在中型以上企业中不明显。第一，因为中型企业都有专业的人才，这些人能判断和规划整个业务体系，不至于盲目。第二，也正是由于规范和专业，所以吸引了很多更看良性成长环境的有志之士。</p>
<p>泡沫，毕竟是泡沫，终有爆破的那一天。这个时间不会很长，3到5年。随着新技术慢慢变旧（当Android和IOS变成和C语言一样老），随着大批量的人才涌入和一些公司退出（十万开发者面对一千岗位），随着很多老板慢慢发现原理和真相（APP真的只是个终端）。我们再来设定一下，曾经那些在小公司频繁蹦来跳去的人，和那些在成熟部门茁壮成长的人，他们命运是不是会发生颠覆性的改变。</p>
<p>互联网行业不同于传统行业，不存在第二。最终的局面是巨头垄断和精细化小企业填补的局面。</p>
<p>其实公司和人历程都一样，都会遇到千奇百怪的事情，但是殊途同归平淡是真，最终都要踏实笃行。你一步一步地走，你眼看别人起高楼，你眼看别人宴宾客，你也眼看别人楼倒塌。</p>
<p>你也可以心想自己建起一座壁垒，固若金汤，经久不衰，称为经典。</p>
<blockquote>
<p>转 <a href="http://www.cnblogs.com/yinrq/p/4745784.html" target="_blank" rel="external">http://www.cnblogs.com/yinrq/p/4745784.html</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-减小iOS应用程序的大小" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/24/减小iOS应用程序的大小/" class="article-date">
  	<time datetime="2015-08-24T15:17:57.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/减小iOS应用程序的大小/">减小iOS应用程序的大小</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195" target="_blank" rel="external">Reducing the size of my App</a></p>
<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>
<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(减小iOS应用程序升级时所需下载的大小)(这与第一次安装使用的工作原理有所不同)。</p>
<h4 id="检查应用程序">检查应用程序</h4><p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>
<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>
<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这不同于升级)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>
<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>
<p>当让我们也可以通过使用: <code>Xcode的Archive命令来构造出.ipa文件——该文件与提交到App Store上的格式基本一致</code>。</p>
<h4 id="检查-ipa文件">检查<code>.ipa</code>文件</h4><p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>
<h4 id="iOS_App_Store相关因素">iOS App Store相关因素</h4><p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>
<blockquote>
<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>
<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>
</blockquote>
<h3 id="Build_Settings">Build Settings</h3><h4 id="编译选项">编译选项</h4><p>将build setting中的<code>Optimization Level</code>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，<code>Fastest, Smallest [-Os]</code>; 将<code>build setting</code> 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>
<blockquote>
<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>
</blockquote>
<h4 id="Target针对较少的CPUs">Target针对较少的CPUs</h4><p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>
<p>要想只设定特定类型的CPUs，可以修改<code>build setting</code>中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>
<h3 id="Assets">Assets</h3><h4 id="对应用程序做一个完整性检查">对应用程序做一个完整性检查</h4><p>利用<code>Inspecting Your App</code>中介绍的流程，对<code>.app bundle</code>做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>
<h4 id="将数据从代码中剥离出来">将数据从代码中剥离出来</h4><p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考iOS App Store Specific Considerations中的完整介绍。)</p>
<h3 id="Image_Assets">Image Assets</h3><h4 id="尽量使用8-bit图片">尽量使用8-bit图片</h4><p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>
<h4 id="针对32-bit的图片尽量使用高压缩的比率">针对32-bit的图片尽量使用高压缩的比率</h4><p>利用Adobe Photoshop的Save For Web可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用pngcrush来压缩.png图片。</p>
<h3 id="Audio_Assets">Audio Assets</h3><h4 id="音频的压缩">音频的压缩</h4><p>参考WWDC中的Audio Development for Games，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
<blockquote>
<p>转自 <a href="http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/" target="_blank" rel="external">破船之家</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS异步图片加载优化与常用开源库分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/" class="article-date">
  	<time datetime="2015-08-23T01:05:05.000Z" itemprop="datePublished">2015-08-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/">iOS异步图片加载优化与常用开源库分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="网络图片显示大体步骤:">网络图片显示大体步骤:</h4><ol>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐</li>
<li>CoreAnimation渲染解压缩过的位图<blockquote>
<p>以上4，5，6，7，8步是在UIImageView的setImage时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一些优化思路：</p>
<ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如SDWebImage使用category）</li>
<li>Core Data vs 文件存储</li>
<li>图片预下载</li>
</ul>
</li>
</ol>
<h4 id="2-1_关于异步图片下载:">2.1 关于异步图片下载:</h4><p><code>fastImageCache</code>主要针对于从磁盘文件读取并展示图片的极端优化，所以并没有集成异步图片下载的功能。这里主要来看看SDWebImage(AFNetWorking的基本类似)的实现方案：</p>
<h5 id="tableView中，异步图片下载任务的管理:">tableView中，异步图片下载任务的管理:</h5><p>我们知道，tableViewCell是有重用机制的，也就是说，内存中只有当前可见的cell数目的实例，滑动的时候，新显示cell会重用被滑出的cell对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<h5 id="SDWebImage提供的UIImageView扩展的解决方案：">SDWebImage提供的UIImageView扩展的解决方案：</h5><p>imageView对象会关联一个下载列表（列表是给AnimationImages用的，这个时候会下载多张图片），当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</p>
<p>同时，SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取<code>LIFO</code>策略的，具体是在添加下载任务的时候，将上次添加的下载任务添加依赖为新添加的下载任务。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">wself.downloadQueue</span> addOperation:operation]<span class="comment">;</span></span><br><span class="line">if <span class="list">(<span class="keyword">wself.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder)</span> &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation<span class="variable">'s</span> dependency</span><br><span class="line">    <span class="list">[<span class="keyword">wself.lastAddedOperation</span> addDependency:operation]<span class="comment">;</span></span><br><span class="line">    wself.lastAddedOperation = operation<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
</blockquote>
<h5 id="另外一种解决方案是：">另外一种解决方案是：</h5><p>imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。</p>
<p>同时，仍然管理一个执行队列，为了避免占用太多的资源，通常会对执行队列设置一个最大的并发量。此外，为了保证LIFO的下载策略，可以自己维持一个等待队列，每次下载任务开始的时候，将后进入的下载任务插入到等待队列的前面。</p>
<p>iOS异步任务一般有3种实现方式:</p>
<ul>
<li>NSOperationQueue</li>
<li>GCD</li>
<li>NSThread<br>这几种方式就不细说了，SDWebImage是通过自定义NSOperation来抽象下载任务的，并结合了GCD来做一些主线程与子线程的切换。具体异步下载的实现，AFNetworking与SDWebImage都是十分优秀的代码，有兴趣的可以深入看看源码。<h4 id="2-2_关于图片解压缩:">2.2 关于图片解压缩:</h4><blockquote>
<p>图片来源 针对app自带的图片，xcode在编译的时候会对png图片进行<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fartori.us%2Foptimized-png-in-xcode%2F" target="_blank" rel="external">优化</a>（据说是通过<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>这个开源的工具来优化），这样在显示的时候就会有一些比较好的体验。 对于从internet上面下载的图片，多数情况下，是需要做解压缩后，才能渲染到屏幕上的。</p>
</blockquote>
</li>
</ul>
<h5 id="通用的解压缩方案">通用的解压缩方案</h5><blockquote>
<p>主体的思路是在子线程，将原始的图片渲染成一张的新的可以字节显示的图片，来获取一个解压缩过的图片</p>
</blockquote>
<p>基本上比较流行的一些开源库都先后支持了在异步线程完成图片的解压缩，并对解压缩过后的图片进行缓存。</p>
<p>这么做的优点是在<code>setImage</code>的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。<br>比如1张50<em>50像素的图片，在<code>retina</code>的屏幕下所占用的空间为`100 </em> 100 * 4 ~ 40KB`</p>
<p>下面的代码是<code>SDWebImage</code>的解决方案:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (image<span class="variable">.images</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not decode animated images</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef));</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = imageSize&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> infoMask = (bitmapInfo &amp; k<span class="built_in">CGBitmapAlphaInfoMask</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> anyNonAlpha = (infoMask == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGBitmapContextCreate doesn't support kCGImageAlphaNone with RGB.</span></span><br><span class="line">    <span class="comment">// https://developer.apple.com/library/mac/#qa/qa1037/_index.html</span></span><br><span class="line">    <span class="keyword">if</span> (infoMask == k<span class="built_in">CGImageAlphaNone</span> &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set noneSkipFirst.</span></span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaNoneSkipFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// Some PNGs tell us they have alpha but only 3 components. Odd.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!anyNonAlpha &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaPremultipliedFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It calculates the bytes-per-row based on the bitsPerComponent and width arguments.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">            imageSize<span class="variable">.width</span>,</span><br><span class="line">            imageSize<span class="variable">.height</span>,</span><br><span class="line">            <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            colorSpace,</span><br><span class="line">            bitmapInfo);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If failed, return undecompressed image</span></span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *decompressedImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:decompressedImageRef scale:image<span class="variable">.scale</span> orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</span><br><span class="line">    <span class="keyword">return</span> decompressedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3_关于字节对齐">2.3 关于字节对齐</h5><p>SDWebImage与AFNetworking都没有对第7点做优化，FastImageCache相对与其他的开源库，则对第5点与第7点做了优化。这里我们谈谈第七点，关于图片数据的字节对齐。</p>
<blockquote>
<p>Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
</blockquote>
<p><img src="1.png"></p>
<p>从代码上来看，主要是在创建上图解码的过程中，<code>CGBitmapContextCreate</code>函数的<code>bytesPerRow</code>参数必须传64的倍数。</p>
<p>比较各个开源框架的代码，可以看到SDWebImage与AFNetworking的该参数都传的是0，即让系统自动来计算该值（那为何系统自动计算的时候不让图片数据字节就字节对齐呢？）。</p>
<h5 id="2-4_关于第3，4点，内存级别拷贝">2.4 关于第3，4点，内存级别拷贝</h5><p>以上3个开源库中，FastImageCache对这一点做了很大的优化，其他的2个开源库则未关注这一点。这一块木有深入研究，就引用一下FastImageCache团队对该点的一些说明。有能力的可以去看看原文章(英文): <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">here</a></p>
<blockquote>
<p>内存映射<br>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高</p>
</blockquote>
<h5 id="2-5_关于第二步图片处理（裁剪，边框等）">2.5 关于第二步图片处理（裁剪，边框等）</h5><p>一般情况下，对于下载下来的图片我们可能想要做一些处理，比如说做一些缩放，裁剪，或者添加圆角等等。</p>
<p>对于比较通用的缩放，或者圆角等功能，可以集成到控件本身。不过，提供一个接口出来，让使用者能够有机会对下载下来的图片做一些其他的特殊处理是有必要的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** SDWebImage</span><br><span class="line"> * Allows <span class="keyword">to</span> transform <span class="keyword">the</span> image immediately <span class="keyword">after</span> <span class="keyword">it</span> has been downloaded <span class="keyword">and</span> just <span class="keyword">before</span> <span class="keyword">to</span> cache <span class="keyword">it</span> <span class="function_start"><span class="keyword">on</span></span> disk <span class="keyword">and</span> memory.</span><br><span class="line"> * NOTE: This method <span class="keyword">is</span> called <span class="keyword">from</span> a <span class="keyword">global</span> queue <span class="keyword">in</span> order <span class="keyword">to</span> <span class="keyword">not</span> <span class="keyword">to</span> block <span class="keyword">the</span> main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param image        The image <span class="keyword">to</span> transform</span><br><span class="line"> * @param imageURL     The url <span class="keyword">of</span> <span class="keyword">the</span> image <span class="keyword">to</span> transform</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> The transformed image object.</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h5 id="2-6_其他（诸如图片预下载，gif支持等等,下载进度条）">2.6 其他（诸如图片预下载，gif支持等等,下载进度条）</h5><p>待补充</p>
<ol>
<li>常用的开源库对比</li>
</ol>
<table>
<thead>
<tr>
<th>tip</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">AFNetworking</th>
<th style="text-align:right">FastImageCache</th>
</tr>
</thead>
<tbody>
<tr>
<td>异步下载图片</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>子线程解压缩</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>子线程图片处理(缩放，圆角等)</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>存储解压缩后的位图</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>内存级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>磁盘级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>UIImageView category</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>减少内存级别的拷贝</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>接口易用性</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:right">*</td>
</tr>
</tbody>
</table>
<p>参考资料<br><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache-github</a><br><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage-github</a><br><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking-github</a><br><a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">File System vs Core Data: the image cache test</a><br><a href="https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/" target="_blank" rel="external">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a><br><a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a><br><a href="http://blog.cnbang.net/tech/2578/?utm_source=tuicool" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-Cell-图片异步加载优化，缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/" class="article-date">
  	<time datetime="2015-08-22T13:45:29.000Z" itemprop="datePublished">2015-08-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/">iOS Cell 图片异步加载优化，缓存机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了防止图片多次下载，我们需要对图片做缓存，缓存分为<code>内存缓存</code> <code>沙盒缓存</code>，我们当然两种都要实现。<br>由于<code>tableViewCell</code>是有重用机制的，也就是说，内存中只有当前可见的<code>cell</code>数目的实例，滑动的时候，新显示<code>cell</code>会重用被滑出的<code>cell</code>对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<p><code>所以在我们向下滑动tableview的时候我们需要手动去取消掉下载操作，当用户停止滑动，再去执行下载操作</code>。</p>
<blockquote>
<p>SDWebImage采用的也是这种策略。</p>
</blockquote>
<p>很简单我们只需要监听ScrollView的代理方法(tableview继承自Scrollview)。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户开始拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewWillBeginDragging</span>:(UIScrollView *)<span class="tag">scrollView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 暂停下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:YES]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户停止拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewDidEndDragging</span>:(UIScrollView *)<span class="tag">scrollView</span> <span class="tag">willDecelerate</span>:(BOOL)<span class="tag">decelerate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 恢复下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:NO]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而SDWebImage采用的就是这种方式,所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
<p>下面介绍一下具体的思路。<br>异步下载图片我们用的是NSOperation，并且创建一个全局的queue来管理下载图片的操作。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载操作的队列</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSOperationQueue* queue;</span></span><br></pre></td></tr></table></figure></p>
<p>另外需要两个字典operations、images<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有的下载操作（url是key，operation对象是value）</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* operations;</span></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载完成的图片，用于内存缓存，同样用Url为key</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* images;</span></span><br></pre></td></tr></table></figure></p>
<p>在把图片显示到Cell上之前<br>先判断内存中(images字典中)有没有图片，<br>如果有，则取出url对应的图片来显示，<br>如果没有，再去沙盒缓存中查看，当然存到沙盒中都是NSData。<br>如果沙盒缓存中有，我们取出对应的数据给Cell去显示<br>如果沙盒中也没有图片，我们先显示占位图片。再创建operation去执行下载操作了。<br>当然在创建operation之前，我们要判断这个operation操作是否存在<br>这个时候就用到我们operations这个字典了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出当前URL对应的下载操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span>* operation = <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>];</span><br></pre></td></tr></table></figure></p>
<p>如果没有下载操作，我们才需要真正的去创建operation执行下载。<br>创建好下载操作之后应该把该操作存放到全局队列中去异步执行，同时吧操作放入operations字典中记录下来。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加操作到队列中</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line"><span class="comment">//添加到字典中</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>] = operation;</span><br></pre></td></tr></table></figure></p>
<p>下载完成之后：<br>把下载好的图片放到内存中、同时存到沙盒缓存中<br>下面存放到沙盒中的代码可以定义成宏，具体可以下载后面的demo</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (image) &#123; <span class="comment">//防止下载失败为空赋值造成崩溃</span></span><br><span class="line">  vc<span class="variable">.images</span>[app<span class="variable">.icon</span>] = image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下载完成的图片存入沙盒中                    </span></span><br><span class="line">  <span class="comment">// UIImage --&gt; NSData --&gt; File（文件）</span></span><br><span class="line">     <span class="built_in">NSData</span>* ImageData = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSString</span>* CachesPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">     <span class="built_in">NSString</span>* filePath = [CachesPath stringByAppendingPathComponent:[app<span class="variable">.icon</span> lastPathComponent]];</span><br><span class="line"></span><br><span class="line">     [ImageData writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的操作之后回到主线程刷新表格，<br>从operations字典中移除下载操作(防止operations越来越大，同时保证下载失败后，能重新下载)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新当前行的图片数据</span></span><br><span class="line">  self.tableView <span class="string">reloadRowsAtIndexPaths:</span>@[indexPath] <span class="string">withRowAnimation:</span>UITableViewRowAnimationNone];</span><br></pre></td></tr></table></figure></p>
<p>这里我们不用[self.tableView reloadata]，因为会刷新整个cell，浪费性能。</p>
<p>当然如果你的下载操作里面需要做的事情很多的时候，可以考虑自定义operation。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 键盘
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>