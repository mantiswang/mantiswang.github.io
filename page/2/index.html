<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>键盘的记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客,记录重要知识,iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="键盘的记忆">
<meta property="og:url" content="http://blog.onecat.cc/page/2/index.html">
<meta property="og:site_name" content="键盘的记忆">
<meta property="og:description" content="写博客,记录重要知识,iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="键盘的记忆">
<meta name="twitter:description" content="写博客,记录重要知识,iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="键盘的记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">键盘</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">键盘</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">键盘</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-减小iOS应用程序的大小" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/24/减小iOS应用程序的大小/" class="article-date">
  	<time datetime="2015-08-24T15:17:57.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/减小iOS应用程序的大小/">减小iOS应用程序的大小</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195" target="_blank" rel="external">Reducing the size of my App</a></p>
<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>
<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(减小iOS应用程序升级时所需下载的大小)(这与第一次安装使用的工作原理有所不同)。</p>
<h4 id="检查应用程序">检查应用程序</h4><p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>
<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>
<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这不同于升级)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>
<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>
<p>当让我们也可以通过使用: <code>Xcode的Archive命令来构造出.ipa文件——该文件与提交到App Store上的格式基本一致</code>。</p>
<h4 id="检查-ipa文件">检查<code>.ipa</code>文件</h4><p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>
<h4 id="iOS_App_Store相关因素">iOS App Store相关因素</h4><p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>
<blockquote>
<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>
<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>
</blockquote>
<h3 id="Build_Settings">Build Settings</h3><h4 id="编译选项">编译选项</h4><p>将build setting中的<code>Optimization Level</code>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，<code>Fastest, Smallest [-Os]</code>; 将<code>build setting</code> 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>
<blockquote>
<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>
</blockquote>
<h4 id="Target针对较少的CPUs">Target针对较少的CPUs</h4><p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>
<p>要想只设定特定类型的CPUs，可以修改<code>build setting</code>中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>
<h3 id="Assets">Assets</h3><h4 id="对应用程序做一个完整性检查">对应用程序做一个完整性检查</h4><p>利用<code>Inspecting Your App</code>中介绍的流程，对<code>.app bundle</code>做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>
<h4 id="将数据从代码中剥离出来">将数据从代码中剥离出来</h4><p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考iOS App Store Specific Considerations中的完整介绍。)</p>
<h3 id="Image_Assets">Image Assets</h3><h4 id="尽量使用8-bit图片">尽量使用8-bit图片</h4><p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>
<h4 id="针对32-bit的图片尽量使用高压缩的比率">针对32-bit的图片尽量使用高压缩的比率</h4><p>利用Adobe Photoshop的Save For Web可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用pngcrush来压缩.png图片。</p>
<h3 id="Audio_Assets">Audio Assets</h3><h4 id="音频的压缩">音频的压缩</h4><p>参考WWDC中的Audio Development for Games，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
<blockquote>
<p>转自 <a href="http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/" target="_blank" rel="external">破船之家</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS异步图片加载优化与常用开源库分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/" class="article-date">
  	<time datetime="2015-08-23T01:05:05.000Z" itemprop="datePublished">2015-08-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/">iOS异步图片加载优化与常用开源库分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="网络图片显示大体步骤:">网络图片显示大体步骤:</h4><ol>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐</li>
<li>CoreAnimation渲染解压缩过的位图<blockquote>
<p>以上4，5，6，7，8步是在UIImageView的setImage时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一些优化思路：</p>
<ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如SDWebImage使用category）</li>
<li>Core Data vs 文件存储</li>
<li>图片预下载</li>
</ul>
</li>
</ol>
<h4 id="2-1_关于异步图片下载:">2.1 关于异步图片下载:</h4><p><code>fastImageCache</code>主要针对于从磁盘文件读取并展示图片的极端优化，所以并没有集成异步图片下载的功能。这里主要来看看SDWebImage(AFNetWorking的基本类似)的实现方案：</p>
<h5 id="tableView中，异步图片下载任务的管理:">tableView中，异步图片下载任务的管理:</h5><p>我们知道，tableViewCell是有重用机制的，也就是说，内存中只有当前可见的cell数目的实例，滑动的时候，新显示cell会重用被滑出的cell对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<h5 id="SDWebImage提供的UIImageView扩展的解决方案：">SDWebImage提供的UIImageView扩展的解决方案：</h5><p>imageView对象会关联一个下载列表（列表是给AnimationImages用的，这个时候会下载多张图片），当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</p>
<p>同时，SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取<code>LIFO</code>策略的，具体是在添加下载任务的时候，将上次添加的下载任务添加依赖为新添加的下载任务。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">wself.downloadQueue</span> addOperation:operation]<span class="comment">;</span></span><br><span class="line">if <span class="list">(<span class="keyword">wself.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder)</span> &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation<span class="variable">'s</span> dependency</span><br><span class="line">    <span class="list">[<span class="keyword">wself.lastAddedOperation</span> addDependency:operation]<span class="comment">;</span></span><br><span class="line">    wself.lastAddedOperation = operation<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
</blockquote>
<h5 id="另外一种解决方案是：">另外一种解决方案是：</h5><p>imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。</p>
<p>同时，仍然管理一个执行队列，为了避免占用太多的资源，通常会对执行队列设置一个最大的并发量。此外，为了保证LIFO的下载策略，可以自己维持一个等待队列，每次下载任务开始的时候，将后进入的下载任务插入到等待队列的前面。</p>
<p>iOS异步任务一般有3种实现方式:</p>
<ul>
<li>NSOperationQueue</li>
<li>GCD</li>
<li>NSThread<br>这几种方式就不细说了，SDWebImage是通过自定义NSOperation来抽象下载任务的，并结合了GCD来做一些主线程与子线程的切换。具体异步下载的实现，AFNetworking与SDWebImage都是十分优秀的代码，有兴趣的可以深入看看源码。<h4 id="2-2_关于图片解压缩:">2.2 关于图片解压缩:</h4><blockquote>
<p>图片来源 针对app自带的图片，xcode在编译的时候会对png图片进行<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fartori.us%2Foptimized-png-in-xcode%2F" target="_blank" rel="external">优化</a>（据说是通过<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>这个开源的工具来优化），这样在显示的时候就会有一些比较好的体验。 对于从internet上面下载的图片，多数情况下，是需要做解压缩后，才能渲染到屏幕上的。</p>
</blockquote>
</li>
</ul>
<h5 id="通用的解压缩方案">通用的解压缩方案</h5><blockquote>
<p>主体的思路是在子线程，将原始的图片渲染成一张的新的可以字节显示的图片，来获取一个解压缩过的图片</p>
</blockquote>
<p>基本上比较流行的一些开源库都先后支持了在异步线程完成图片的解压缩，并对解压缩过后的图片进行缓存。</p>
<p>这么做的优点是在<code>setImage</code>的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。<br>比如1张50<em>50像素的图片，在<code>retina</code>的屏幕下所占用的空间为`100 </em> 100 * 4 ~ 40KB`</p>
<p>下面的代码是<code>SDWebImage</code>的解决方案:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (image<span class="variable">.images</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not decode animated images</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef));</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = imageSize&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> infoMask = (bitmapInfo &amp; k<span class="built_in">CGBitmapAlphaInfoMask</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> anyNonAlpha = (infoMask == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGBitmapContextCreate doesn't support kCGImageAlphaNone with RGB.</span></span><br><span class="line">    <span class="comment">// https://developer.apple.com/library/mac/#qa/qa1037/_index.html</span></span><br><span class="line">    <span class="keyword">if</span> (infoMask == k<span class="built_in">CGImageAlphaNone</span> &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set noneSkipFirst.</span></span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaNoneSkipFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// Some PNGs tell us they have alpha but only 3 components. Odd.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!anyNonAlpha &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaPremultipliedFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It calculates the bytes-per-row based on the bitsPerComponent and width arguments.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">            imageSize<span class="variable">.width</span>,</span><br><span class="line">            imageSize<span class="variable">.height</span>,</span><br><span class="line">            <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            colorSpace,</span><br><span class="line">            bitmapInfo);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If failed, return undecompressed image</span></span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *decompressedImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:decompressedImageRef scale:image<span class="variable">.scale</span> orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</span><br><span class="line">    <span class="keyword">return</span> decompressedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3_关于字节对齐">2.3 关于字节对齐</h5><p>SDWebImage与AFNetworking都没有对第7点做优化，FastImageCache相对与其他的开源库，则对第5点与第7点做了优化。这里我们谈谈第七点，关于图片数据的字节对齐。</p>
<blockquote>
<p>Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
</blockquote>
<p><img src="1.png"></p>
<p>从代码上来看，主要是在创建上图解码的过程中，<code>CGBitmapContextCreate</code>函数的<code>bytesPerRow</code>参数必须传64的倍数。</p>
<p>比较各个开源框架的代码，可以看到SDWebImage与AFNetworking的该参数都传的是0，即让系统自动来计算该值（那为何系统自动计算的时候不让图片数据字节就字节对齐呢？）。</p>
<h5 id="2-4_关于第3，4点，内存级别拷贝">2.4 关于第3，4点，内存级别拷贝</h5><p>以上3个开源库中，FastImageCache对这一点做了很大的优化，其他的2个开源库则未关注这一点。这一块木有深入研究，就引用一下FastImageCache团队对该点的一些说明。有能力的可以去看看原文章(英文): <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">here</a></p>
<blockquote>
<p>内存映射<br>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高</p>
</blockquote>
<h5 id="2-5_关于第二步图片处理（裁剪，边框等）">2.5 关于第二步图片处理（裁剪，边框等）</h5><p>一般情况下，对于下载下来的图片我们可能想要做一些处理，比如说做一些缩放，裁剪，或者添加圆角等等。</p>
<p>对于比较通用的缩放，或者圆角等功能，可以集成到控件本身。不过，提供一个接口出来，让使用者能够有机会对下载下来的图片做一些其他的特殊处理是有必要的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** SDWebImage</span><br><span class="line"> * Allows <span class="keyword">to</span> transform <span class="keyword">the</span> image immediately <span class="keyword">after</span> <span class="keyword">it</span> has been downloaded <span class="keyword">and</span> just <span class="keyword">before</span> <span class="keyword">to</span> cache <span class="keyword">it</span> <span class="function_start"><span class="keyword">on</span></span> disk <span class="keyword">and</span> memory.</span><br><span class="line"> * NOTE: This method <span class="keyword">is</span> called <span class="keyword">from</span> a <span class="keyword">global</span> queue <span class="keyword">in</span> order <span class="keyword">to</span> <span class="keyword">not</span> <span class="keyword">to</span> block <span class="keyword">the</span> main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param image        The image <span class="keyword">to</span> transform</span><br><span class="line"> * @param imageURL     The url <span class="keyword">of</span> <span class="keyword">the</span> image <span class="keyword">to</span> transform</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> The transformed image object.</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h5 id="2-6_其他（诸如图片预下载，gif支持等等,下载进度条）">2.6 其他（诸如图片预下载，gif支持等等,下载进度条）</h5><p>待补充</p>
<ol>
<li>常用的开源库对比</li>
</ol>
<table>
<thead>
<tr>
<th>tip</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">AFNetworking</th>
<th style="text-align:right">FastImageCache</th>
</tr>
</thead>
<tbody>
<tr>
<td>异步下载图片</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>子线程解压缩</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>子线程图片处理(缩放，圆角等)</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>存储解压缩后的位图</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>内存级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>磁盘级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>UIImageView category</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>减少内存级别的拷贝</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>接口易用性</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:right">*</td>
</tr>
</tbody>
</table>
<p>参考资料<br><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache-github</a><br><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage-github</a><br><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking-github</a><br><a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">File System vs Core Data: the image cache test</a><br><a href="https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/" target="_blank" rel="external">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a><br><a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a><br><a href="http://blog.cnbang.net/tech/2578/?utm_source=tuicool" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-Cell-图片异步加载优化，缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/" class="article-date">
  	<time datetime="2015-08-22T13:45:29.000Z" itemprop="datePublished">2015-08-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/">iOS Cell 图片异步加载优化，缓存机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了防止图片多次下载，我们需要对图片做缓存，缓存分为<code>内存缓存</code> <code>沙盒缓存</code>，我们当然两种都要实现。<br>由于<code>tableViewCell</code>是有重用机制的，也就是说，内存中只有当前可见的<code>cell</code>数目的实例，滑动的时候，新显示<code>cell</code>会重用被滑出的<code>cell</code>对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<p><code>所以在我们向下滑动tableview的时候我们需要手动去取消掉下载操作，当用户停止滑动，再去执行下载操作</code>。</p>
<blockquote>
<p>SDWebImage采用的也是这种策略。</p>
</blockquote>
<p>很简单我们只需要监听ScrollView的代理方法(tableview继承自Scrollview)。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户开始拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewWillBeginDragging</span>:(UIScrollView *)<span class="tag">scrollView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 暂停下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:YES]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户停止拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewDidEndDragging</span>:(UIScrollView *)<span class="tag">scrollView</span> <span class="tag">willDecelerate</span>:(BOOL)<span class="tag">decelerate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 恢复下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:NO]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而SDWebImage采用的就是这种方式,所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
<p>下面介绍一下具体的思路。<br>异步下载图片我们用的是NSOperation，并且创建一个全局的queue来管理下载图片的操作。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载操作的队列</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSOperationQueue* queue;</span></span><br></pre></td></tr></table></figure></p>
<p>另外需要两个字典operations、images<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有的下载操作（url是key，operation对象是value）</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* operations;</span></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载完成的图片，用于内存缓存，同样用Url为key</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* images;</span></span><br></pre></td></tr></table></figure></p>
<p>在把图片显示到Cell上之前<br>先判断内存中(images字典中)有没有图片，<br>如果有，则取出url对应的图片来显示，<br>如果没有，再去沙盒缓存中查看，当然存到沙盒中都是NSData。<br>如果沙盒缓存中有，我们取出对应的数据给Cell去显示<br>如果沙盒中也没有图片，我们先显示占位图片。再创建operation去执行下载操作了。<br>当然在创建operation之前，我们要判断这个operation操作是否存在<br>这个时候就用到我们operations这个字典了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出当前URL对应的下载操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span>* operation = <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>];</span><br></pre></td></tr></table></figure></p>
<p>如果没有下载操作，我们才需要真正的去创建operation执行下载。<br>创建好下载操作之后应该把该操作存放到全局队列中去异步执行，同时吧操作放入operations字典中记录下来。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加操作到队列中</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line"><span class="comment">//添加到字典中</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>] = operation;</span><br></pre></td></tr></table></figure></p>
<p>下载完成之后：<br>把下载好的图片放到内存中、同时存到沙盒缓存中<br>下面存放到沙盒中的代码可以定义成宏，具体可以下载后面的demo</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (image) &#123; <span class="comment">//防止下载失败为空赋值造成崩溃</span></span><br><span class="line">  vc<span class="variable">.images</span>[app<span class="variable">.icon</span>] = image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下载完成的图片存入沙盒中                    </span></span><br><span class="line">  <span class="comment">// UIImage --&gt; NSData --&gt; File（文件）</span></span><br><span class="line">     <span class="built_in">NSData</span>* ImageData = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSString</span>* CachesPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">     <span class="built_in">NSString</span>* filePath = [CachesPath stringByAppendingPathComponent:[app<span class="variable">.icon</span> lastPathComponent]];</span><br><span class="line"></span><br><span class="line">     [ImageData writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的操作之后回到主线程刷新表格，<br>从operations字典中移除下载操作(防止operations越来越大，同时保证下载失败后，能重新下载)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新当前行的图片数据</span></span><br><span class="line">  self.tableView <span class="string">reloadRowsAtIndexPaths:</span>@[indexPath] <span class="string">withRowAnimation:</span>UITableViewRowAnimationNone];</span><br></pre></td></tr></table></figure></p>
<p>这里我们不用[self.tableView reloadata]，因为会刷新整个cell，浪费性能。</p>
<p>当然如果你的下载操作里面需要做的事情很多的时候，可以考虑自定义operation。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-GCD实现单一资源的多读写" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/21/GCD实现单一资源的多读写/" class="article-date">
  	<time datetime="2015-08-21T13:17:58.000Z" itemprop="datePublished">2015-08-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/21/GCD实现单一资源的多读写/">GCD实现单一资源的多读写</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在多线程编程中，最常见的场景是如何保证线程安全，比如你可能经常遇到多线程访问某个dic（又或者是array或其他）造成的crash。<br>这篇文章里，我们讨论下如何使用GCD实现多线程读者与写者问题，也即单一资源的线程安全问题。</p>
</blockquote>
<p>首先，还是先将示例代码放出来好了，后面会有一些我遇到过的问题及改进介绍。如果你只想得到一个解决方案，只需要看第一节就OK，当然，也许你也有兴趣看看后面的部分。</p>
<h3 id="解决方案与原理">解决方案与原理</h3><h4 id="ARC版本">ARC版本</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(<span class="string">"ioQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要创建一个私有的队列来处理读写操作。在这里不推荐使用<code>globe_queue</code>, 因为我们通过<code>dispatch_barrier_async</code>来保证写操作的互斥，我们当然不希望写操作阻塞住<code>globe_queue</code>中的其他不相关任务，我们只希望在写的同时，不会有其他的写操作或者读操作。</p>
<blockquote>
<p>同时，也不推荐给队列设置优先级，多数情况下使用default就可以了。而改变优先级往往会造成一些无法预料的问题，比如优先级反转(具体的可以参看参考文献)。</p>
</blockquote>
<p><img src="dispatch_barrier.png"><br>图片来自参考文献<br><code>dispatch_barrier_async</code>的block运行时机是，在它之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行。注意在<code>barrier</code>执行的时候，队列本质上如同一个串行队列，其执行完以后才会恢复到并行队列。</p>
<p>另外一个值得注意的问题是，在写操作的时候，我们使用<code>dispatch_async</code>，而在读操作的时候我们使用<code>dispatch_sync</code>。很明显，这2个操作一个是异步的，一个是同步的。我们不需要使每次程序执行的时候都等待写操作完成，所以写操作异步执行，但是我们需要同步的执行读操作来保证程序能够立刻得到它想要的值。</p>
<p>使用sync的时候需要极其的小心，因为稍不注意，就有可能产生死锁，这可能造成灾难性的后果。你肯定也注意到了在写操作的时候对key进行了copy, 关于此处的解释，插入一段来自参考文献的引用:</p>
<blockquote>
<p>函数调用者可以自由传递一个NSMutableString的key，并且能够在函数返回后修改它。因此我们必须对传入的字符串使用copy操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的NSString类型），调用copy基本上是个空操作。</p>
</blockquote>
<p>到这里整个基本示例代码已经完成，一般情况下能够满足我们的需要。下面来看看在MRC过程中我遇到的一些问题。</p>
<h4 id="关于死锁">关于死锁</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queueA<span class="comment">; // 串行队列</span></span><br><span class="line">dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;    </span><br><span class="line">    dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;        </span><br><span class="line">        foo<span class="list">()</span><span class="comment">;    </span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>造成死锁比较常见的情况可以简化成上面这段代码。<br><code>dispatch_sync</code>会同步的提交工作并在返回前等待其完成。第一个<code>dispatch_sync</code>正在运行并等待它的block完成，但是block不能够完成，它调用了第二个dispatch_sync，而第二个<code>dispatch_sync</code>会等待串行队列中已经存在的第一个任务完成，很明显这个任务无法完成，造成死锁。</p>
<blockquote>
<p>值得注意的是main_queue就是一个串行队列。</p>
</blockquote>
<h3 id="MRC下容易遇到的问题与解决方案">MRC下容易遇到的问题与解决方案</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    [key release];</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看看上面这段代码，基本就是ARC版本转换过来的，看起来没问题。那么究竟是不是真的没问题，我们跑段代码试试看：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//版本一</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;             </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [self getSafeObjectForKey:<span class="type">KEY</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test执行后，很快就会发生crash，读操作的result会发生野指针。<br>如果你有经验的话，可能会发现问题:<br>如果某个线程a刚取出了result值，这次线程b开始执行写操作，造成线程a中的result值成为了一份过期的数据，如果正好线程b的runloop结束，很有可能旧的result内存地址被释放掉,这时线程a中的result就会发生野指针crash。<br>这时候，你可能会采取这样子的修改，代码如下: </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//版本二</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;             </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [[self getSafeObjectForKey:<span class="type">KEY</span>] retain];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">        [<span class="literal">result</span> release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后会发现，仍然会crash，其实问题和上面一样，我们的改动没有真正的解决问题。最好的解决方案是在读操作之前就已经retain住了，看看最终版的代码吧:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//最终版</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [[_dic objectForKey:key] retain];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">result</span> autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意retain过一定要释放掉，不然或造成内存泄露。</p>
</blockquote>
<p>再次验证后发现，程序不会crash了，恭喜。</p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-多线程-GCD" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/iOS-多线程-GCD/" class="article-date">
  	<time datetime="2015-08-20T14:59:25.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/iOS-多线程-GCD/">iOS 多线程-GCD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GCD">GCD</h3><blockquote>
<ul>
<li>全称是Grand Central Dispatch，“伟大的中枢调度器”</li>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>纯C语言，提供了非常多强大的函数</li>
</ul>
</blockquote>
<h4 id="优势">优势</h4><ol>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ol>
<h4 id="基本概念">基本概念</h4><h5 id="任务和队列">任务和队列</h5><p><code>GCD中有2个核心概念</code></p>
<ol>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定制任务:确定想做的事情</span></span><br><span class="line"><span class="comment">// 2.将任务添加到队列中:GCD会自动将队列中的任务取出，放到对应的线程中执行。</span></span><br><span class="line">Tips：任务的取出遵循队列的FIFO原则：先进先出，后进后出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="任务">任务</h4><h5 id="一、执行任务">一、执行任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">queue</span>：队列</span><br><span class="line"> - block：任务</span><br><span class="line"><span class="comment">// 1.用同步的方式执行任务</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用异步的方式执行任务</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.GCD中还有个用来执行任务的函数</span></span><br><span class="line"><span class="comment">// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>注意:<br><code>同步</code>：只能在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</p>
<h4 id="队列">队列</h4><h5 id="一、并发队列（Concurrent_Dispatch_Queue）">一、并发队列（Concurrent Dispatch Queue）</h5><ul>
<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>
<li>并发功能只有在异步（dispatch_async）函数下才有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="comment">// 队列名称 </span></span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr); <span class="comment">// 队列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用dispatch_get_global_queue函数获得全局的并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">dispatch_queue_priority_t</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// dispatch_queue_priority_t priority(队列的优先级 )</span></span><br><span class="line"><span class="comment">// unsigned long flags( 此参数暂时无用，用0即可 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获得全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.全局并发队列的优先级</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span> <span class="comment">// 高</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span> <span class="comment">// 默认（中）</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>) <span class="comment">// 低</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN <span class="comment">// 后台</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="二、串行队列（Serial_Dispatch_Queue）">二、串行队列（Serial Dispatch Queue）</h5><ul>
<li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建串行队列</span></span><br><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用dispatch_get_main_queue()获得主队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="三、各种队列的执行效果">三、各种队列的执行效果</h5><p><img src="123.png"><br><code>特别注意</code>：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 (线程卡死)</p>
<h4 id="新手易混淆">新手易混淆</h4><blockquote>
<p>有4个术语比较容易混淆：<code>同步</code>、<code>异步</code>、<code>并发</code>、<code>串行</code></p>
<ol>
<li>同步和异步主要影响：能不能开启新的线程<br><code>同步</code>：只是在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</li>
<li>并发和串行主要影响：任务的执行方式<br><code>并发</code>：多个任务并发（同时）执行<br><code>串行</code>：一个任务执行完毕后，再执行下一个任务</li>
</ol>
</blockquote>
<h4 id="GCD运用">GCD运用</h4><h5 id="一、线程间通信">一、线程间通信</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从子线程回到主线程</span><br><span class="line"><span class="tag">dispatch_async</span>(</span><br><span class="line"><span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行耗时的异步操作...</span></span><br><span class="line">      <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="comment">// 回到主线程，执行UI刷新操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="二、延时执行">二、延时执行</h5><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after<span class="params">(dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2.0</span> * NSEC_PER_SEC)</span>)</span>, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">    // <span class="number">2</span>秒后异步执行这里的代码...</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="三、一次性代码">三、一次性代码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="四、快速迭代">四、快速迭代</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_apply函数能进行快速迭代遍历</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">    <span class="comment">// 执行10次代码，index顺序不确定</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="五、队列组">五、队列组</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Objective-C-Code-guide" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/Objective-C-Code-guide/" class="article-date">
  	<time datetime="2015-08-19T23:16:41.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/Objective-C-Code-guide/">Objective-C 编码规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录">目录</h3><ul>
<li>语言</li>
<li>代码组织</li>
<li>空格</li>
<li>注释</li>
<li>命名<ul>
<li>下划线</li>
</ul>
</li>
<li>方法</li>
<li>变量</li>
<li>属性特性</li>
<li>点符号语法</li>
<li>字面值</li>
<li>常量</li>
<li>枚举类型</li>
<li>Case语句</li>
<li>私有属性</li>
<li>布尔值</li>
<li>条件语句<ul>
<li>三元操作符</li>
</ul>
</li>
<li>Init方法</li>
<li>类构造方法</li>
<li>CGRect函数</li>
<li>黄金路径</li>
<li>错误处理</li>
<li>单例模式</li>
<li>换行符</li>
<li>Xcode工程</li>
</ul>
<h4 id="语言">语言</h4><p>应该使用US英语.<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>代码组织<br>在函数分组和<code>protocol/delegate</code>实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Lifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (instancetype)<span class="tag">init</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewWillAppear</span>:(BOOL)<span class="tag">animated</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">didReceiveMemoryWarning</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Custom</span> <span class="tag">Accessors</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">setCustomProperty</span>:(id)<span class="tag">value</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">customProperty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">IBActions</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">submitData</span>:(id)<span class="tag">sender</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Public</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">publicMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Private</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">privateMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Protocol</span> <span class="tag">conformance</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITextFieldDelegate</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDataSource</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSCopying</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">copyWithZone</span>:(NSZone *)<span class="tag">zone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (NSString *)<span class="tag">description</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><ul>
<li>缩进使用4个空格，确保在Xcode偏好设置来设置。(<a href="http://www.raywenderlich.com]使用2个空格" target="_blank" rel="external">raywenderlich.com</a></li>
<li>方法大括号和其他大括号(<code>if/else/switch/while</code> 等.)总是在同一行语句打开但在新行中关闭。<br>应该:<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用<code>auto-synthesis</code>。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。<br>应该:<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure></p>
<h4 id="注释">注释</h4><p>当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。例外：这不应用在生成文档的注释</p>
<h4 id="命名">命名</h4><p>Apple命名规则尽可能坚持，特别是与这些相关的memory management rules (NARC)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p>应该:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *<span class="built_in">set</span>But;</span><br></pre></td></tr></table></figure></p>
<p>三个字符前缀应该经常用在类和常量命名，但在<code>Core Data</code>的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p>应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure></p>
<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用<code>auto-synthesis</code>，而不是手动编写<code>@ synthesize</code>语句，除非你有一个好的理由。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> varnm;</span><br></pre></td></tr></table></figure></p>
<h3 id="下划线">下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h4 id="方法">方法</h4><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p>应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setExampleText:<span class="params">(NSString *)</span><span class="built_in">text</span> image:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector to:<span class="params">(id)</span>anObject forAllCells:<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>viewWithTag:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width height:<span class="params">(CGFloat)</span>height;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(void)</span>setT:<span class="params">(NSString *)</span><span class="built_in">text</span> i:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector :<span class="params">(id)</span>anObject :<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>taggedView:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width andHeight:<span class="params">(CGFloat)</span>height;</span><br><span class="line">- <span class="params">(instancetype)</span>initWith:<span class="params">(int)</span>width and:<span class="params">(int)</span>height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="变量">变量</h4><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， NSString <em>text 既不是 NSString</em> text 也不是 NSString * text，除了一些特殊情况下常量。</p>
<p><a href="#">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>i</code>nitWithCoder:`, 等…)，dealloc 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里</p>
<p>应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">  NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性特性">属性特性</h4><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<h4 id="点符号语法">点符号语法</h4><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里</p>
<p>点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span><span class="variable">.array</span> count];</span><br><span class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span><span class="variable">.array</span><span class="variable">.count</span>;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span><span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="字面值">字面值</h4><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致<code>crash</code>。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="常量">常量</h4><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine CompanyName @<span class="string">"RayWenderlich.com"</span></span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine thumbnailHeight <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="枚举类型">枚举类型</h4><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain,</span><br><span class="line">  RWTLeftMenuTopItemShows,</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123;</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeM<span class="keyword">in</span> = <span class="number">1</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeMax = <span class="number">5</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountM<span class="keyword">in</span> = <span class="number">100</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>旧的k-style常量定义应该避免除非编写Core Foundation C的代码。</p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">  kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">  kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Case语句">Case语句</h4><p>大括号在<code>case</code>语句中并不是必须的，除非编译器强制要求。当一个<code>case</code>语句包含多行代码时，大括号应该加上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Multi-line example using braces</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多次，当相同代码被多个<code>cases</code>使用时，一个<code>fall-through</code>应该被使用。一个<code>fall-through</code>就是在<code>case</code>最后移除<code>break</code>语句，这样就能够允许执行流程跳转到下一个<code>case</code>值。为了代码更加清晰，一个<code>fall-through</code>需要注释一下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ** fall-through! **</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当在<code>switch</code>使用枚举类型时，<code>default</code>是不需要的。例如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="私有属性">私有属性</h4><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="布尔值">布尔值</h4><p>Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1和一个BOOL能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == <span class="literal">true</span>)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, getter=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文字和例子从这里引用Cocoa Naming Guidelines</p>
</blockquote>
<h4 id="条件语句">条件语句</h4><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p>应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="constant">return</span> success;</span><br></pre></td></tr></table></figure></p>
<h4 id="三元操作符">三元操作符</h4><p>当需要提高代码的清晰性和简洁性时，三元操作符?:才会使用。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p>应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="literal">result</span> = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> isHorizontal = <span class="type">YES</span>;</span><br><span class="line"><span class="literal">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span> = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure></p>
<h4 id="Init方法">Init方法</h4><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用instancetype而不是id<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看关于instancetype的文章Class Constructor Methods</p>
<h4 id="类构造方法">类构造方法</h4><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Airplane</span><br><span class="line">+ (instancetype)airplaneWithType:(RWTAirplaneType)<span class="class"><span class="keyword">type</span>;</span></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>关于更多instancetype信息，请查看NSHipster.com</p>
<h4 id="CGRect函数">CGRect函数</h4><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry:</p>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="黄金路径">黄金路径</h4><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">someMethod</span> &#123;</span><br><span class="line">  <span class="tag">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="错误处理">错误处理</h4><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<h4 id="单例模式">单例模式</h4><p>单例对象应该使用线程安全模式来创建共享实例。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会防止possible and sometimes prolific crashes.</p>
<h4 id="换行符">换行符</h4><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br><span class="line">一行很长的代码应该分成两行代码，下一行用两个空格隔开。</span><br><span class="line"></span><br><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Xcode工程">Xcode工程</h4><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下additional warnings。如果你需要忽略特殊的警告，使用 Clang’s pragma feature。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NSString-tips" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/NSString-tips/" class="article-date">
  	<time datetime="2015-08-19T23:00:20.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/NSString-tips/">NSString 实用技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>首字母大写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首字母大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"ligang"</span>;</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,[<span class="built_in">string</span> capitalizedString]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分割字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割字符串</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is a iOSDevTip"</span>;</span><br><span class="line">NSArray *<span class="built_in">array</span> = [<span class="built_in">string</span> componentsSeparatedByString:@<span class="string">"a"</span>];</span><br><span class="line">NSString *string1 = [<span class="built_in">array</span> objectAtIndex:<span class="number">0</span>];</span><br><span class="line">NSString *string2 = [<span class="built_in">array</span> objectAtIndex:<span class="number">1</span>];</span><br><span class="line">NSLog(@<span class="string">"string1:%@  string2:%@"</span>,string1,string2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加字符串</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//追加字符串</span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithStrin<span class="variable">g:</span>@<span class="string">"I Love "</span>];</span><br><span class="line">[<span class="built_in">string</span> appendStrin<span class="variable">g:</span>@<span class="string">"China"</span>];</span><br><span class="line">NSLog(@<span class="string">"string:%@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I China"</span>];</span><br><span class="line">[<span class="built_in">string</span> insertString:@<span class="string">"Love "</span> atIndex:<span class="number">2</span>];</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I love China"</span>];</span><br><span class="line">[<span class="built_in">string</span> deleteCharactersInRange:NSMakeRange(<span class="number">2</span>, <span class="number">4</span>)];</span><br><span class="line">NSLog(@<span class="string">"String1: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否包含前后缀</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否包含前后缀</span></span><br><span class="line"><span class="constant">NSString *string</span> = @<span class="string">"I love China"</span>;</span><br><span class="line"><span class="constant">BOOL isHasI</span> = [<span class="built_in">string</span> hasPrefix:@<span class="string">"I"</span>];</span><br><span class="line"><span class="constant">BOOL isHasChina</span> = [<span class="built_in">string</span> hasSuffix:@<span class="string">"China"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"I love China"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *replaceString = [string stringByReplacingOccurrencesOfString:<span class="string">@"love"</span> withString:<span class="string">@"like"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"replaceString:  %@"</span>,replaceString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除字符串首尾的空格和换行符</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除字符串首尾的空格和换行符</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@" I love China "</span>;</span><br><span class="line"><span class="built_in">NSString</span> *text = [string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text:%@"</span>,text);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字符串是否包含另一个字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string1 = <span class="string">@"This is a iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="string">@"iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [string1 rangeOfString:string2];</span><br><span class="line"><span class="built_in">NSInteger</span> location = range<span class="variable">.location</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> length = range<span class="variable">.length</span>;</span><br><span class="line"><span class="built_in">NSString</span> *logString = [[<span class="built_in">NSString</span> alloc] initWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Location:%ld,Leight:%ld"</span>,location,length]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"logString:%@"</span>,logString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取字符串</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">NSString</span> *<span class="keyword">string </span>= <span class="comment">@"This is a operation string!";</span></span><br><span class="line">//<span class="keyword">substringToIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subToString </span>= [<span class="keyword">string </span><span class="keyword">substringToIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringFromIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subFromString </span>= [<span class="keyword">string </span><span class="keyword">substringFromIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringWithRange截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *rangeString = [<span class="keyword">string </span><span class="keyword">substringWithRange:NSMakeRange(6, </span><span class="number">3</span>)]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写转大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> lowercaseString];</span><br><span class="line"></span><br><span class="line"><span class="comment">//大写转小写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> uppercaseString];</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串比较</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//isEqualToString方法比较</span><br><span class="line"><span class="type">NSString</span> *stingOne = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">NSString</span> *stringTwo = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne isEqualToString:stringTwo];</span><br><span class="line">//compare方法比较</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne compare:stringTwo] == <span class="type">NSOrderedSame</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>typedef NS_ENUM(NSInteger, NSComparisonResult) {<br>    NSOrderedAscending = -1L,<br>    NSOrderedSame,<br>    NSOrderedDescending<br>};</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-maths" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/19/iOS-maths/" class="article-date">
  	<time datetime="2015-08-19T15:05:34.000Z" itemprop="datePublished">2015-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/19/iOS-maths/">iOS 开发中常用的数学函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在iOS开发当中。。。我们往往会涉及到一些算法。。。为了节省一些时间。。。让APP很快地被开发出来。。。我们需要对各类函数有一定的了解。。。接下来。。。我把部分常用函数分享出来。。。希望能帮到大家。。。</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rand</span><span class="params">()</span></span> ----随机数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">abs</span><span class="params">()</span></span> / <span class="function"><span class="title">labs</span><span class="params">()</span></span> ----整数绝对值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fabs</span><span class="params">()</span></span> / <span class="function"><span class="title">fabsf</span><span class="params">()</span></span> / <span class="function"><span class="title">fabsl</span><span class="params">()</span></span> ----浮点数绝对值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">floor</span><span class="params">()</span></span> / <span class="function"><span class="title">floorf</span><span class="params">()</span></span> / <span class="function"><span class="title">floorl</span><span class="params">()</span></span> ----向下取整</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ceil</span><span class="params">()</span></span> / <span class="function"><span class="title">ceilf</span><span class="params">()</span></span> / <span class="function"><span class="title">ceill</span><span class="params">()</span></span> ----向上取整</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">round</span><span class="params">()</span></span> / <span class="function"><span class="title">roundf</span><span class="params">()</span></span> / <span class="function"><span class="title">roundl</span><span class="params">()</span></span> ----四舍五入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sqrt</span><span class="params">()</span></span> / <span class="function"><span class="title">sqrtf</span><span class="params">()</span></span> / <span class="function"><span class="title">sqrtl</span><span class="params">()</span></span> ----求平方根</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmax</span><span class="params">()</span></span> / <span class="function"><span class="title">fmaxf</span><span class="params">()</span></span> / <span class="function"><span class="title">fmaxl</span><span class="params">()</span></span> ----求最大值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmin</span><span class="params">()</span></span> / <span class="function"><span class="title">fminf</span><span class="params">()</span></span> / <span class="function"><span class="title">fminl</span><span class="params">()</span></span> ----求最小值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hypot</span><span class="params">()</span></span> / <span class="function"><span class="title">hypotf</span><span class="params">()</span></span> / <span class="function"><span class="title">hypotl</span><span class="params">()</span></span> ----求直角三角形斜边的长度</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmod</span><span class="params">()</span></span> / <span class="function"><span class="title">fmodf</span><span class="params">()</span></span> / <span class="function"><span class="title">fmodl</span><span class="params">()</span></span> ----求两数整除后的余数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">modf</span><span class="params">()</span></span> / <span class="function"><span class="title">modff</span><span class="params">()</span></span> / <span class="function"><span class="title">modfl</span><span class="params">()</span></span> ----浮点数分解为整数和小数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">frexp</span><span class="params">()</span></span> / <span class="function"><span class="title">frexpf</span><span class="params">()</span></span> / <span class="function"><span class="title">frexpl</span><span class="params">()</span></span> ----浮点数分解尾数和二为底的指数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sin</span><span class="params">()</span></span> / <span class="function"><span class="title">sinf</span><span class="params">()</span></span> / <span class="function"><span class="title">sinl</span><span class="params">()</span></span> ----求正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sinh</span><span class="params">()</span></span> / <span class="function"><span class="title">sinhf</span><span class="params">()</span></span> / <span class="function"><span class="title">sinhl</span><span class="params">()</span></span> ----求双曲正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cos</span><span class="params">()</span></span> / <span class="function"><span class="title">cosf</span><span class="params">()</span></span> / <span class="function"><span class="title">cosl</span><span class="params">()</span></span> ----求余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cosh</span><span class="params">()</span></span> / <span class="function"><span class="title">coshf</span><span class="params">()</span></span> / <span class="function"><span class="title">coshl</span><span class="params">()</span></span> ----求双曲余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">tan</span><span class="params">()</span></span> / <span class="function"><span class="title">tanf</span><span class="params">()</span></span> / <span class="function"><span class="title">tanl</span><span class="params">()</span></span> ----求正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">tanh</span><span class="params">()</span></span> / <span class="function"><span class="title">tanhf</span><span class="params">()</span></span> / <span class="function"><span class="title">tanhl</span><span class="params">()</span></span> ----求双曲正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">asin</span><span class="params">()</span></span> / <span class="function"><span class="title">asinf</span><span class="params">()</span></span> / <span class="function"><span class="title">asinl</span><span class="params">()</span></span> ----求反正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">asinh</span><span class="params">()</span></span> / <span class="function"><span class="title">asinhf</span><span class="params">()</span></span> / <span class="function"><span class="title">asinhl</span><span class="params">()</span></span> ----求反双曲正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">acos</span><span class="params">()</span></span> / <span class="function"><span class="title">acosf</span><span class="params">()</span></span> / <span class="function"><span class="title">acosl</span><span class="params">()</span></span> ----求反余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">acosh</span><span class="params">()</span></span> / <span class="function"><span class="title">acoshf</span><span class="params">()</span></span> / <span class="function"><span class="title">acoshl</span><span class="params">()</span></span> ----求反双曲余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atan</span><span class="params">()</span></span> / <span class="function"><span class="title">atanf</span><span class="params">()</span></span> / <span class="function"><span class="title">atanl</span><span class="params">()</span></span> ----求反正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atan2</span><span class="params">()</span></span> / <span class="function"><span class="title">atan2f</span><span class="params">()</span></span> / <span class="function"><span class="title">atan2l</span><span class="params">()</span></span> ----求坐标值的反正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atanh</span><span class="params">()</span></span> / <span class="function"><span class="title">atanhf</span><span class="params">()</span></span> / <span class="function"><span class="title">atanhl</span><span class="params">()</span></span> ----求反双曲正切值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>转自 简书 <a href="http://www.jianshu.com/p/0ca725ecf7f7" target="_blank" rel="external">http://www.jianshu.com/p/0ca725ecf7f7</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-github-iOS-top-100" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/19/github-iOS-top-100/" class="article-date">
  	<time datetime="2015-08-19T15:03:05.000Z" itemprop="datePublished">2015-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/19/github-iOS-top-100/">GitHub iOS Top 100 简介</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GitHub_Top_100_简介">GitHub Top 100 简介</h2><p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p>
<p><strong>若有任何疑问可通过微博<a href="http://weibo.com/jinfali" target="_blank" rel="external">@李锦发</a>联系我</strong></p>
<table>
<thead>
<tr>
<th>项目名称</th>
<th>项目信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></td>
<td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td>
</tr>
<tr>
<td>2. <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a></td>
<td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a href="http://stackoverflow.com/users/19679/brad-larson" target="_blank" rel="external">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td>
</tr>
<tr>
<td>3. <a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a></td>
<td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td>
</tr>
<tr>
<td>4. <a href="https://github.com/RestKit/RestKit" target="_blank" rel="external">RestKit</a></td>
<td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td>
</tr>
<tr>
<td>5. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a></td>
<td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a href="http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction" target="_blank" rel="external">文章</a></td>
</tr>
<tr>
<td>6. <a href="https://github.com/facebookarchive/three20" target="_blank" rel="external">three20</a></td>
<td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a href="https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269" target="_blank" rel="external">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="external">Nimbus</a>, 算是 three20 的一个替代品</td>
</tr>
<tr>
<td>7. <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">MBProgressHUD</a></td>
<td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td>
</tr>
<tr>
<td>8. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">MagicalRecord</a></td>
<td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td>
</tr>
<tr>
<td>9. <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a></td>
<td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td>
</tr>
<tr>
<td>10. <a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a></td>
<td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td>
</tr>
<tr>
<td>11. <a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="external">FlatUIKit</a></td>
<td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td>
</tr>
<tr>
<td>12. <a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="external">ASIHTTPRequest</a></td>
<td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td>
</tr>
<tr>
<td>13. <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache</a></td>
<td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td>
</tr>
<tr>
<td>14. <a href="https://github.com/Masonry/Masonry" target="_blank" rel="external">Masonry</a></td>
<td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td>
</tr>
<tr>
<td>15. <a href="https://github.com/facebook/Shimmer" target="_blank" rel="external">Shimmer</a></td>
<td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td>
</tr>
<tr>
<td>16. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" rel="external">SVProgressHUD</a></td>
<td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td>
</tr>
<tr>
<td>17. <a href="https://github.com/jigish/slate" target="_blank" rel="external">Slate</a></td>
<td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td>
</tr>
<tr>
<td>18. <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">JSONKit</a></td>
<td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td>
</tr>
<tr>
<td>19. <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="external">Nimbus</a></td>
<td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td>
</tr>
<tr>
<td>20. <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">CocoaLumberjack</a></td>
<td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td>
</tr>
<tr>
<td>21. <a href="https://github.com/facebook/facebook-ios-sdk" target="_blank" rel="external">Facebook SDK for iOS</a></td>
<td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td>
</tr>
<tr>
<td>22. <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a></td>
<td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td>
</tr>
<tr>
<td>23. <a href="https://github.com/supermarin/Alcatraz" target="_blank" rel="external">Alcatraz</a></td>
<td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td>
</tr>
<tr>
<td>24. <a href="https://github.com/Inferis/ViewDeck" target="_blank" rel="external">ViewDeck</a></td>
<td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td>
</tr>
<tr>
<td>25. <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a></td>
<td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td>
</tr>
<tr>
<td>26. <a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a></td>
<td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td>
</tr>
<tr>
<td>27. <a href="https://github.com/facebook/xctool" target="_blank" rel="external">Xctool</a></td>
<td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a href="https://travis-ci.org" target="_blank" rel="external">Travis CI</a>, <a href="http://oclint.org" target="_blank" rel="external">OCLint</a> 等测试工具</td>
</tr>
<tr>
<td>28. <a href="https://github.com/OpenEmu/OpenEmu" target="_blank" rel="external">OpenEmu</a></td>
<td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td>
</tr>
<tr>
<td>29. <a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a></td>
<td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td>
</tr>
<tr>
<td>30. <a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="external">RESideMenu</a></td>
<td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td>
</tr>
<tr>
<td>321 <a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a></td>
<td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td>
</tr>
<tr>
<td>31.2<a href="https://github.com/square/PonyDebugger" target="_blank" rel="external">PonyDebugger</a></td>
<td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td>
</tr>
<tr>
<td>33. <a href="https://github.com/jverdi/JVFloatLabeledTextField" target="_blank" rel="external">JVFloatLabeledTextField</a></td>
<td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td>
</tr>
<tr>
<td>34. <a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">SWTableViewCell</a></td>
<td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td>
</tr>
<tr>
<td>35. <a href="https://github.com/levey/AwesomeMenu" target="_blank" rel="external">AwesomeMenu</a></td>
<td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td>
</tr>
<tr>
<td>36. <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a></td>
<td>Reachablity 是用于检测 iOS 设备网络环境的库</td>
</tr>
<tr>
<td>37. <a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter-Xcode</a></td>
<td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td>
</tr>
<tr>
<td>38. <a href="https://github.com/google/physical-web" target="_blank" rel="external">The Physical Web</a></td>
<td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td>
</tr>
<tr>
<td>39. <a href="https://github.com/samuelclay/NewsBlur" target="_blank" rel="external">NewsBlur</a></td>
<td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td>
</tr>
<tr>
<td>40. <a href="https://github.com/cocos2d/cocos2d-spritebuilder" target="_blank" rel="external">Cocos2D-SpriteBuilder</a></td>
<td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td>
</tr>
<tr>
<td>41. <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a></td>
<td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td>
</tr>
<tr>
<td>42. <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">CocoaAsyncSocket</a></td>
<td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td>
</tr>
<tr>
<td>43. <a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="external">TapkuLibrary</a></td>
<td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td>
</tr>
<tr>
<td>44. <a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="external">Canvas</a></td>
<td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td>
</tr>
<tr>
<td>45. <a href="https://github.com/square/SocketRocket" target="_blank" rel="external">SocketRocket</a></td>
<td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td>
</tr>
<tr>
<td>46. <a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="external">ECSlidingViewController</a></td>
<td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td>
</tr>
<tr>
<td>47. <a href="https://github.com/stig/json-framework" target="_blank" rel="external">Json Framework</a></td>
<td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td>
</tr>
<tr>
<td>48. <a href="https://github.com/facebook/Tweaks" target="_blank" rel="external">Tweaks</a></td>
<td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td>
</tr>
<tr>
<td>49. <a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">realm-cocoa</a></td>
<td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td>
</tr>
<tr>
<td>50. <a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="external">BlocksKit</a></td>
<td>一个开源的与 Cocoa 紧密集合的基础性框架</td>
</tr>
<tr>
<td>51. <a href="https://github.com/arashpayan/appirater" target="_blank" rel="external">Appirater</a></td>
<td>一款用于提醒用户给你的 App 打分的工具</td>
</tr>
<tr>
<td>52. <a href="https://github.com/kif-framework/KIF" target="_blank" rel="external">KIF</a></td>
<td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td>
</tr>
<tr>
<td>53. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" rel="external">SlackTextViewController</a></td>
<td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td>
</tr>
<tr>
<td>54. <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">JazzHands</a></td>
<td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td>
</tr>
<tr>
<td>55. <a href="https://github.com/BoltsFramework/Bolts-iOS" target="_blank" rel="external">Bolts-iOS</a></td>
<td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td>
</tr>
<tr>
<td>56. <a href="https://github.com/eczarny/spectacle" target="_blank" rel="external">Spectacle</a></td>
<td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td>
</tr>
<tr>
<td>57. <a href="https://github.com/tombenner/nui" target="_blank" rel="external">nui</a></td>
<td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td>
</tr>
<tr>
<td>58. <a href="https://github.com/Induction/Induction" target="_blank" rel="external">Induction</a></td>
<td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td>
</tr>
<tr>
<td>59. <a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="external">JSONModel</a></td>
<td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td>
</tr>
<tr>
<td>60. <a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="external">DTCoreText</a></td>
<td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td>
</tr>
<tr>
<td>61. <a href="https://github.com/schneiderandre/popping" target="_blank" rel="external">Popping</a></td>
<td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td>
</tr>
<tr>
<td>62. <a href="https://github.com/KrauseFx/TSMessages" target="_blank" rel="external">TSMessages</a></td>
<td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td>
</tr>
<tr>
<td>63. <a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a></td>
<td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td>
</tr>
<tr>
<td>64. <a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="external">MWPhotoBrowser</a></td>
<td>一款简单的 iOS 照片浏览控件</td>
</tr>
<tr>
<td>65. <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">MMDrawerController</a></td>
<td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td>
</tr>
<tr>
<td>66. <a href="https://github.com/escoz/QuickDialog" target="_blank" rel="external">QuickDialog</a></td>
<td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td>
</tr>
<tr>
<td>67. <a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="external">SVPullToRefresh</a></td>
<td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td>
</tr>
<tr>
<td>68. <a href="https://github.com/nothingmagical/cheddar-ios" target="_blank" rel="external">cheddar-ios</a></td>
<td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td>
</tr>
<tr>
<td>69. <a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">XVim</a></td>
<td>一款在 Xcode 上实现了 Vim 功能的插件</td>
</tr>
<tr>
<td>70. <a href="https://github.com/enormego/EGOTableViewPullRefresh" target="_blank" rel="external">EGOTableViewPullRefresh</a></td>
<td>一款提供下拉刷新的控件, 最后更新时间是一年前</td>
</tr>
<tr>
<td>71. <a href="https://github.com/gimenete/iOS-boilerplate" target="_blank" rel="external">iOS-boilerplate</a></td>
<td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td>
</tr>
<tr>
<td>72. <a href="https://github.com/gotosleep/JASidePanels" target="_blank" rel="external">JASidePanels</a></td>
<td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td>
</tr>
<tr>
<td>73. <a href="https://github.com/mattt/FormatterKit" target="_blank" rel="external">FormatterKit</a></td>
<td>收集了很多构思优秀的 NSFormatter 子类</td>
</tr>
<tr>
<td>74. <a href="https://github.com/erichoracek/MSDynamicsDrawerViewController" target="_blank" rel="external">MSDynamicsDrawerViewController</a></td>
<td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td>
</tr>
<tr>
<td>75. <a href="https://github.com/boctor/idev-recipes" target="_blank" rel="external">idev-recipes</a></td>
<td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td>
</tr>
<tr>
<td>76. <a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="external">XMPPFramework</a></td>
<td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td>
</tr>
<tr>
<td>77. <a href="https://github.com/MacGapProject/MacGap1" target="_blank" rel="external">MacGap1</a></td>
<td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td>
</tr>
<tr>
<td>78. <a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">FXBlurView</a></td>
<td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td>
</tr>
<tr>
<td>79. <a href="https://github.com/shu223/iOS7-Sampler" target="_blank" rel="external">iOS7-Sampler</a></td>
<td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>80. <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="external">PromiseKit</a></td>
<td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td>
</tr>
<tr>
<td>81. <a href="https://github.com/facebook/origami" target="_blank" rel="external">Origami</a></td>
<td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td>
</tr>
<tr>
<td>82. <a href="https://github.com/fpillet/NSLogger" target="_blank" rel="external">NSLogger</a></td>
<td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td>
</tr>
<tr>
<td>83. <a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">KSImageNamed-Xcode</a></td>
<td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td>
</tr>
<tr>
<td>84. <a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">PureLayout</a></td>
<td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td>
</tr>
<tr>
<td>85. <a href="https://github.com/tomaz/appledoc" target="_blank" rel="external">AppleDoc</a></td>
<td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td>
</tr>
<tr>
<td>86. <a href="https://github.com/gnachman/iTerm2" target="_blank" rel="external">iTerm2</a></td>
<td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td>
</tr>
<tr>
<td>87. <a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="external">Kiwi</a></td>
<td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td>
</tr>
<tr>
<td>88. <a href="https://github.com/alloy/terminal-notifier" target="_blank" rel="external">terminal-notifier</a></td>
<td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td>
</tr>
<tr>
<td>89. <a href="https://github.com/uranusjr/macdown" target="_blank" rel="external">MacDown</a></td>
<td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td>
</tr>
<tr>
<td>90. <a href="https://github.com/twitter/twui" target="_blank" rel="external">TwUI</a></td>
<td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td>
</tr>
<tr>
<td>91. <a href="https://github.com/honcheng/PaperFold-for-iOS" target="_blank" rel="external">PaperFold for iOS</a></td>
<td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td>
</tr>
<tr>
<td>92. <a href="https://github.com/vfr/Reader" target="_blank" rel="external">Reader</a></td>
<td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td>
</tr>
<tr>
<td>93. <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></td>
<td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td>
</tr>
<tr>
<td>94. <a href="https://github.com/shu223/iOS8-Sampler" target="_blank" rel="external">iOS8-Sampler</a></td>
<td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>95. <a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="external">CocoaHTTPServer</a></td>
<td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td>
</tr>
<tr>
<td>96. <a href="https://github.com/rsms/kod" target="_blank" rel="external">Kod</a></td>
<td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td>
</tr>
<tr>
<td>97. <a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="external">TPKeyboardAvoiding</a></td>
<td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td>
</tr>
<tr>
<td>98. <a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="external">MKNetworkKit</a></td>
<td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td>
</tr>
<tr>
<td>99. <a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="external">PKRevealController</a></td>
<td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td>
</tr>
<tr>
<td>00. <a href="https://github.com/AlanQuatermain/AQGridView" target="_blank" rel="external">AQGridView</a></td>
<td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td>
</tr>
</tbody>
</table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-Photo-album" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/18/iOS-Photo-album/" class="article-date">
  	<time datetime="2015-08-18T14:15:53.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/iOS-Photo-album/">iOS 开发只保存照片到系统相册</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>保存照片到系统相册这个功能很多社交类的APP都有的，今天我们简单讲解一下，如何将图片保存到系统相册（Photo Album）。</p>
<h4 id="创建UIImageView">创建UIImageView</h4><p>创建<code>UIImageView</code>是为了将照片展示出来，我们是要把<code>UIImage</code>保存到系统相册（Photo Album）:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define SCREEN [UIScreen mainScreen].bounds.size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"iOSDevTip"</span>];</span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((SCREEN<span class="variable">.width</span> - <span class="number">300</span>) / <span class="number">2</span>, <span class="number">70</span>, <span class="number">300</span>, <span class="number">150</span>)];</span><br><span class="line">imageView<span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.image</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br></pre></td></tr></table></figure></p>
<h4 id="创建UIButton">创建UIButton</h4><p>创建<code>UIButton</code>并绑定<code>actionClick:</code>事件:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UIButton *button = [[UIButton alloc] init];</span><br><span class="line">button.frame = CGRectMake( <span class="number">100</span>, <span class="number">300</span>, SCREEN.width - <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">[button <span class="string">addTarget:</span>self <span class="string">action:</span><span class="annotation">@selector</span>(<span class="string">actionClick:</span>) <span class="string">forControlEvents:</span>UIControlEventTouchUpInside];</span><br><span class="line">[button <span class="string">setTitleColor:</span>[UIColor blueColor] <span class="string">forState:</span>UIControlStateNormal];</span><br><span class="line">[button <span class="string">setBackgroundColor:</span>[UIColor orangeColor]];</span><br><span class="line">[button <span class="string">setTitle:</span>@<span class="string">"SavePhoto"</span> <span class="string">forState:</span>UIControlStateNormal];</span><br><span class="line">[self.view <span class="string">addSubview:</span>button];</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">actionClick:</span>(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="保存照片到系统相册（Photo_Album）">保存照片到系统相册（Photo Album）</h4><p>在<code>actionClick:</code>方法里调用：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImageWriteToSavedPhotosAlbum<span class="list">(<span class="keyword">self</span>.image, self, @selector<span class="list">(<span class="keyword">image</span><span class="keyword">:didFinishSavingWithError</span><span class="keyword">:contextInfo</span>:)</span>, NULL)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们想知道保存是否成功，所以需要指定回掉方法</p>
<blockquote>
<p>这是SDK提供的默认指定回调方法<br>// Adds a photo to the saved photos album.  The optional completionSelector should have the form:<br>//  - (void)image:(UIImage <em>)image didFinishSavingWithError:(NSError </em>)error contextInfo:(void <em>)contextInfo;<br>UIKIT_EXTERN void UIImageWriteToSavedPhotosAlbum(UIImage </em>image, id completionTarget, SEL completionSelector, void *contextInfo);</p>
</blockquote>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定回调方法</span></span><br><span class="line">- <span class="params">(void)</span>image:<span class="params">(UIImage *)</span>image didFinishSavingWithError:<span class="params">(NSError *)</span>error contextInfo:<span class="params">(void *)</span>contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(!error)</span>&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"save success"</span>)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"save failed"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，我们就知道照片是否保存成功。然后，根据需求来刷新UI线程。demo地址: <a href="https://github.com/worldligang/iOSStrongDemo" target="_blank" rel="external">https://github.com/worldligang/iOSStrongDemo</a> </p>
<blockquote>
<p>本文转自微信号<code>iOSDevTip</code></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 键盘
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>