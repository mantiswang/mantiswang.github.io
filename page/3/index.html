<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="keywords" content="键盘的记忆,iOS学习,html5,混合开发">
  
  <title>键盘的记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客,记录重要知识,iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="键盘的记忆">
<meta property="og:url" content="http://blog.onecat.cc/page/3/index.html">
<meta property="og:site_name" content="键盘的记忆">
<meta property="og:description" content="写博客,记录重要知识,iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="键盘的记忆">
<meta name="twitter:description" content="写博客,记录重要知识,iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="键盘的记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">键盘</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">键盘</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">键盘</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-iOS-多线程-GCD" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/iOS-多线程-GCD/" class="article-date">
  	<time datetime="2015-08-20T14:59:25.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/iOS-多线程-GCD/">iOS 多线程-GCD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GCD">GCD</h3><blockquote>
<ul>
<li>全称是Grand Central Dispatch，“伟大的中枢调度器”</li>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>纯C语言，提供了非常多强大的函数</li>
</ul>
</blockquote>
<h4 id="优势">优势</h4><ol>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ol>
<h4 id="基本概念">基本概念</h4><h5 id="任务和队列">任务和队列</h5><p><code>GCD中有2个核心概念</code></p>
<ol>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定制任务:确定想做的事情</span></span><br><span class="line"><span class="comment">// 2.将任务添加到队列中:GCD会自动将队列中的任务取出，放到对应的线程中执行。</span></span><br><span class="line">Tips：任务的取出遵循队列的FIFO原则：先进先出，后进后出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="任务">任务</h4><h5 id="一、执行任务">一、执行任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">queue</span>：队列</span><br><span class="line"> - block：任务</span><br><span class="line"><span class="comment">// 1.用同步的方式执行任务</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用异步的方式执行任务</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.GCD中还有个用来执行任务的函数</span></span><br><span class="line"><span class="comment">// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>注意:<br><code>同步</code>：只能在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</p>
<h4 id="队列">队列</h4><h5 id="一、并发队列（Concurrent_Dispatch_Queue）">一、并发队列（Concurrent Dispatch Queue）</h5><ul>
<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>
<li>并发功能只有在异步（dispatch_async）函数下才有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="comment">// 队列名称 </span></span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr); <span class="comment">// 队列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用dispatch_get_global_queue函数获得全局的并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">dispatch_queue_priority_t</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// dispatch_queue_priority_t priority(队列的优先级 )</span></span><br><span class="line"><span class="comment">// unsigned long flags( 此参数暂时无用，用0即可 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获得全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.全局并发队列的优先级</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span> <span class="comment">// 高</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span> <span class="comment">// 默认（中）</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>) <span class="comment">// 低</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN <span class="comment">// 后台</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="二、串行队列（Serial_Dispatch_Queue）">二、串行队列（Serial Dispatch Queue）</h5><ul>
<li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建串行队列</span></span><br><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用dispatch_get_main_queue()获得主队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="三、各种队列的执行效果">三、各种队列的执行效果</h5><p><img src="123.png"><br><code>特别注意</code>：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 (线程卡死)</p>
<h4 id="新手易混淆">新手易混淆</h4><blockquote>
<p>有4个术语比较容易混淆：<code>同步</code>、<code>异步</code>、<code>并发</code>、<code>串行</code></p>
<ol>
<li>同步和异步主要影响：能不能开启新的线程<br><code>同步</code>：只是在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</li>
<li>并发和串行主要影响：任务的执行方式<br><code>并发</code>：多个任务并发（同时）执行<br><code>串行</code>：一个任务执行完毕后，再执行下一个任务</li>
</ol>
</blockquote>
<h4 id="GCD运用">GCD运用</h4><h5 id="一、线程间通信">一、线程间通信</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从子线程回到主线程</span><br><span class="line"><span class="tag">dispatch_async</span>(</span><br><span class="line"><span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行耗时的异步操作...</span></span><br><span class="line">      <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="comment">// 回到主线程，执行UI刷新操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="二、延时执行">二、延时执行</h5><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after<span class="params">(dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2.0</span> * NSEC_PER_SEC)</span>)</span>, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">    // <span class="number">2</span>秒后异步执行这里的代码...</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="三、一次性代码">三、一次性代码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="四、快速迭代">四、快速迭代</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_apply函数能进行快速迭代遍历</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">    <span class="comment">// 执行10次代码，index顺序不确定</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="五、队列组">五、队列组</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Objective-C-Code-guide" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/Objective-C-Code-guide/" class="article-date">
  	<time datetime="2015-08-19T23:16:41.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/Objective-C-Code-guide/">Objective-C 编码规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录">目录</h3><ul>
<li>语言</li>
<li>代码组织</li>
<li>空格</li>
<li>注释</li>
<li>命名<ul>
<li>下划线</li>
</ul>
</li>
<li>方法</li>
<li>变量</li>
<li>属性特性</li>
<li>点符号语法</li>
<li>字面值</li>
<li>常量</li>
<li>枚举类型</li>
<li>Case语句</li>
<li>私有属性</li>
<li>布尔值</li>
<li>条件语句<ul>
<li>三元操作符</li>
</ul>
</li>
<li>Init方法</li>
<li>类构造方法</li>
<li>CGRect函数</li>
<li>黄金路径</li>
<li>错误处理</li>
<li>单例模式</li>
<li>换行符</li>
<li>Xcode工程</li>
</ul>
<h4 id="语言">语言</h4><p>应该使用US英语.<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>代码组织<br>在函数分组和<code>protocol/delegate</code>实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Lifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (instancetype)<span class="tag">init</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewWillAppear</span>:(BOOL)<span class="tag">animated</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">didReceiveMemoryWarning</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Custom</span> <span class="tag">Accessors</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">setCustomProperty</span>:(id)<span class="tag">value</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">customProperty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">IBActions</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">submitData</span>:(id)<span class="tag">sender</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Public</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">publicMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Private</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">privateMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Protocol</span> <span class="tag">conformance</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITextFieldDelegate</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDataSource</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSCopying</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">copyWithZone</span>:(NSZone *)<span class="tag">zone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (NSString *)<span class="tag">description</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><ul>
<li>缩进使用4个空格，确保在Xcode偏好设置来设置。(<a href="http://www.raywenderlich.com]使用2个空格" target="_blank" rel="external">raywenderlich.com</a></li>
<li>方法大括号和其他大括号(<code>if/else/switch/while</code> 等.)总是在同一行语句打开但在新行中关闭。<br>应该:<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用<code>auto-synthesis</code>。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。<br>应该:<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure></p>
<h4 id="注释">注释</h4><p>当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。例外：这不应用在生成文档的注释</p>
<h4 id="命名">命名</h4><p>Apple命名规则尽可能坚持，特别是与这些相关的memory management rules (NARC)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p>应该:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *<span class="built_in">set</span>But;</span><br></pre></td></tr></table></figure></p>
<p>三个字符前缀应该经常用在类和常量命名，但在<code>Core Data</code>的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p>应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure></p>
<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用<code>auto-synthesis</code>，而不是手动编写<code>@ synthesize</code>语句，除非你有一个好的理由。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> varnm;</span><br></pre></td></tr></table></figure></p>
<h3 id="下划线">下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h4 id="方法">方法</h4><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p>应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setExampleText:<span class="params">(NSString *)</span><span class="built_in">text</span> image:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector to:<span class="params">(id)</span>anObject forAllCells:<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>viewWithTag:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width height:<span class="params">(CGFloat)</span>height;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(void)</span>setT:<span class="params">(NSString *)</span><span class="built_in">text</span> i:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector :<span class="params">(id)</span>anObject :<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>taggedView:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width andHeight:<span class="params">(CGFloat)</span>height;</span><br><span class="line">- <span class="params">(instancetype)</span>initWith:<span class="params">(int)</span>width and:<span class="params">(int)</span>height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="变量">变量</h4><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， NSString <em>text 既不是 NSString</em> text 也不是 NSString * text，除了一些特殊情况下常量。</p>
<p><a href="#">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>i</code>nitWithCoder:`, 等…)，dealloc 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里</p>
<p>应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">  NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性特性">属性特性</h4><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<h4 id="点符号语法">点符号语法</h4><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里</p>
<p>点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span><span class="variable">.array</span> count];</span><br><span class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span><span class="variable">.array</span><span class="variable">.count</span>;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span><span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="字面值">字面值</h4><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致<code>crash</code>。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="常量">常量</h4><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine CompanyName @<span class="string">"RayWenderlich.com"</span></span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine thumbnailHeight <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="枚举类型">枚举类型</h4><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain,</span><br><span class="line">  RWTLeftMenuTopItemShows,</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123;</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeM<span class="keyword">in</span> = <span class="number">1</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeMax = <span class="number">5</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountM<span class="keyword">in</span> = <span class="number">100</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>旧的k-style常量定义应该避免除非编写Core Foundation C的代码。</p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">  kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">  kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Case语句">Case语句</h4><p>大括号在<code>case</code>语句中并不是必须的，除非编译器强制要求。当一个<code>case</code>语句包含多行代码时，大括号应该加上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Multi-line example using braces</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多次，当相同代码被多个<code>cases</code>使用时，一个<code>fall-through</code>应该被使用。一个<code>fall-through</code>就是在<code>case</code>最后移除<code>break</code>语句，这样就能够允许执行流程跳转到下一个<code>case</code>值。为了代码更加清晰，一个<code>fall-through</code>需要注释一下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ** fall-through! **</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当在<code>switch</code>使用枚举类型时，<code>default</code>是不需要的。例如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="私有属性">私有属性</h4><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="布尔值">布尔值</h4><p>Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1和一个BOOL能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == <span class="literal">true</span>)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, getter=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文字和例子从这里引用Cocoa Naming Guidelines</p>
</blockquote>
<h4 id="条件语句">条件语句</h4><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p>应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="constant">return</span> success;</span><br></pre></td></tr></table></figure></p>
<h4 id="三元操作符">三元操作符</h4><p>当需要提高代码的清晰性和简洁性时，三元操作符?:才会使用。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p>应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="literal">result</span> = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> isHorizontal = <span class="type">YES</span>;</span><br><span class="line"><span class="literal">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span> = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure></p>
<h4 id="Init方法">Init方法</h4><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用instancetype而不是id<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看关于instancetype的文章Class Constructor Methods</p>
<h4 id="类构造方法">类构造方法</h4><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Airplane</span><br><span class="line">+ (instancetype)airplaneWithType:(RWTAirplaneType)<span class="class"><span class="keyword">type</span>;</span></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>关于更多instancetype信息，请查看NSHipster.com</p>
<h4 id="CGRect函数">CGRect函数</h4><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry:</p>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="黄金路径">黄金路径</h4><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">someMethod</span> &#123;</span><br><span class="line">  <span class="tag">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="错误处理">错误处理</h4><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<h4 id="单例模式">单例模式</h4><p>单例对象应该使用线程安全模式来创建共享实例。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会防止possible and sometimes prolific crashes.</p>
<h4 id="换行符">换行符</h4><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br><span class="line">一行很长的代码应该分成两行代码，下一行用两个空格隔开。</span><br><span class="line"></span><br><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Xcode工程">Xcode工程</h4><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下additional warnings。如果你需要忽略特殊的警告，使用 Clang’s pragma feature。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NSString-tips" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/NSString-tips/" class="article-date">
  	<time datetime="2015-08-19T23:00:20.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/NSString-tips/">NSString 实用技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>首字母大写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首字母大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"ligang"</span>;</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,[<span class="built_in">string</span> capitalizedString]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分割字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割字符串</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is a iOSDevTip"</span>;</span><br><span class="line">NSArray *<span class="built_in">array</span> = [<span class="built_in">string</span> componentsSeparatedByString:@<span class="string">"a"</span>];</span><br><span class="line">NSString *string1 = [<span class="built_in">array</span> objectAtIndex:<span class="number">0</span>];</span><br><span class="line">NSString *string2 = [<span class="built_in">array</span> objectAtIndex:<span class="number">1</span>];</span><br><span class="line">NSLog(@<span class="string">"string1:%@  string2:%@"</span>,string1,string2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加字符串</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//追加字符串</span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithStrin<span class="variable">g:</span>@<span class="string">"I Love "</span>];</span><br><span class="line">[<span class="built_in">string</span> appendStrin<span class="variable">g:</span>@<span class="string">"China"</span>];</span><br><span class="line">NSLog(@<span class="string">"string:%@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I China"</span>];</span><br><span class="line">[<span class="built_in">string</span> insertString:@<span class="string">"Love "</span> atIndex:<span class="number">2</span>];</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I love China"</span>];</span><br><span class="line">[<span class="built_in">string</span> deleteCharactersInRange:NSMakeRange(<span class="number">2</span>, <span class="number">4</span>)];</span><br><span class="line">NSLog(@<span class="string">"String1: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否包含前后缀</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否包含前后缀</span></span><br><span class="line"><span class="constant">NSString *string</span> = @<span class="string">"I love China"</span>;</span><br><span class="line"><span class="constant">BOOL isHasI</span> = [<span class="built_in">string</span> hasPrefix:@<span class="string">"I"</span>];</span><br><span class="line"><span class="constant">BOOL isHasChina</span> = [<span class="built_in">string</span> hasSuffix:@<span class="string">"China"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"I love China"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *replaceString = [string stringByReplacingOccurrencesOfString:<span class="string">@"love"</span> withString:<span class="string">@"like"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"replaceString:  %@"</span>,replaceString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除字符串首尾的空格和换行符</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除字符串首尾的空格和换行符</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@" I love China "</span>;</span><br><span class="line"><span class="built_in">NSString</span> *text = [string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text:%@"</span>,text);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字符串是否包含另一个字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string1 = <span class="string">@"This is a iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="string">@"iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [string1 rangeOfString:string2];</span><br><span class="line"><span class="built_in">NSInteger</span> location = range<span class="variable">.location</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> length = range<span class="variable">.length</span>;</span><br><span class="line"><span class="built_in">NSString</span> *logString = [[<span class="built_in">NSString</span> alloc] initWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Location:%ld,Leight:%ld"</span>,location,length]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"logString:%@"</span>,logString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取字符串</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">NSString</span> *<span class="keyword">string </span>= <span class="comment">@"This is a operation string!";</span></span><br><span class="line">//<span class="keyword">substringToIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subToString </span>= [<span class="keyword">string </span><span class="keyword">substringToIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringFromIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subFromString </span>= [<span class="keyword">string </span><span class="keyword">substringFromIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringWithRange截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *rangeString = [<span class="keyword">string </span><span class="keyword">substringWithRange:NSMakeRange(6, </span><span class="number">3</span>)]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写转大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> lowercaseString];</span><br><span class="line"></span><br><span class="line"><span class="comment">//大写转小写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> uppercaseString];</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串比较</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//isEqualToString方法比较</span><br><span class="line"><span class="type">NSString</span> *stingOne = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">NSString</span> *stringTwo = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne isEqualToString:stringTwo];</span><br><span class="line">//compare方法比较</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne compare:stringTwo] == <span class="type">NSOrderedSame</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>typedef NS_ENUM(NSInteger, NSComparisonResult) {<br>    NSOrderedAscending = -1L,<br>    NSOrderedSame,<br>    NSOrderedDescending<br>};</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-maths" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/19/iOS-maths/" class="article-date">
  	<time datetime="2015-08-19T15:05:34.000Z" itemprop="datePublished">2015-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/19/iOS-maths/">iOS 开发中常用的数学函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在iOS开发当中。。。我们往往会涉及到一些算法。。。为了节省一些时间。。。让APP很快地被开发出来。。。我们需要对各类函数有一定的了解。。。接下来。。。我把部分常用函数分享出来。。。希望能帮到大家。。。</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rand</span><span class="params">()</span></span> ----随机数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">abs</span><span class="params">()</span></span> / <span class="function"><span class="title">labs</span><span class="params">()</span></span> ----整数绝对值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fabs</span><span class="params">()</span></span> / <span class="function"><span class="title">fabsf</span><span class="params">()</span></span> / <span class="function"><span class="title">fabsl</span><span class="params">()</span></span> ----浮点数绝对值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">floor</span><span class="params">()</span></span> / <span class="function"><span class="title">floorf</span><span class="params">()</span></span> / <span class="function"><span class="title">floorl</span><span class="params">()</span></span> ----向下取整</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ceil</span><span class="params">()</span></span> / <span class="function"><span class="title">ceilf</span><span class="params">()</span></span> / <span class="function"><span class="title">ceill</span><span class="params">()</span></span> ----向上取整</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">round</span><span class="params">()</span></span> / <span class="function"><span class="title">roundf</span><span class="params">()</span></span> / <span class="function"><span class="title">roundl</span><span class="params">()</span></span> ----四舍五入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sqrt</span><span class="params">()</span></span> / <span class="function"><span class="title">sqrtf</span><span class="params">()</span></span> / <span class="function"><span class="title">sqrtl</span><span class="params">()</span></span> ----求平方根</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmax</span><span class="params">()</span></span> / <span class="function"><span class="title">fmaxf</span><span class="params">()</span></span> / <span class="function"><span class="title">fmaxl</span><span class="params">()</span></span> ----求最大值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmin</span><span class="params">()</span></span> / <span class="function"><span class="title">fminf</span><span class="params">()</span></span> / <span class="function"><span class="title">fminl</span><span class="params">()</span></span> ----求最小值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hypot</span><span class="params">()</span></span> / <span class="function"><span class="title">hypotf</span><span class="params">()</span></span> / <span class="function"><span class="title">hypotl</span><span class="params">()</span></span> ----求直角三角形斜边的长度</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fmod</span><span class="params">()</span></span> / <span class="function"><span class="title">fmodf</span><span class="params">()</span></span> / <span class="function"><span class="title">fmodl</span><span class="params">()</span></span> ----求两数整除后的余数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">modf</span><span class="params">()</span></span> / <span class="function"><span class="title">modff</span><span class="params">()</span></span> / <span class="function"><span class="title">modfl</span><span class="params">()</span></span> ----浮点数分解为整数和小数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">frexp</span><span class="params">()</span></span> / <span class="function"><span class="title">frexpf</span><span class="params">()</span></span> / <span class="function"><span class="title">frexpl</span><span class="params">()</span></span> ----浮点数分解尾数和二为底的指数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sin</span><span class="params">()</span></span> / <span class="function"><span class="title">sinf</span><span class="params">()</span></span> / <span class="function"><span class="title">sinl</span><span class="params">()</span></span> ----求正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sinh</span><span class="params">()</span></span> / <span class="function"><span class="title">sinhf</span><span class="params">()</span></span> / <span class="function"><span class="title">sinhl</span><span class="params">()</span></span> ----求双曲正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cos</span><span class="params">()</span></span> / <span class="function"><span class="title">cosf</span><span class="params">()</span></span> / <span class="function"><span class="title">cosl</span><span class="params">()</span></span> ----求余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cosh</span><span class="params">()</span></span> / <span class="function"><span class="title">coshf</span><span class="params">()</span></span> / <span class="function"><span class="title">coshl</span><span class="params">()</span></span> ----求双曲余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">tan</span><span class="params">()</span></span> / <span class="function"><span class="title">tanf</span><span class="params">()</span></span> / <span class="function"><span class="title">tanl</span><span class="params">()</span></span> ----求正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">tanh</span><span class="params">()</span></span> / <span class="function"><span class="title">tanhf</span><span class="params">()</span></span> / <span class="function"><span class="title">tanhl</span><span class="params">()</span></span> ----求双曲正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">asin</span><span class="params">()</span></span> / <span class="function"><span class="title">asinf</span><span class="params">()</span></span> / <span class="function"><span class="title">asinl</span><span class="params">()</span></span> ----求反正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">asinh</span><span class="params">()</span></span> / <span class="function"><span class="title">asinhf</span><span class="params">()</span></span> / <span class="function"><span class="title">asinhl</span><span class="params">()</span></span> ----求反双曲正弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">acos</span><span class="params">()</span></span> / <span class="function"><span class="title">acosf</span><span class="params">()</span></span> / <span class="function"><span class="title">acosl</span><span class="params">()</span></span> ----求反余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">acosh</span><span class="params">()</span></span> / <span class="function"><span class="title">acoshf</span><span class="params">()</span></span> / <span class="function"><span class="title">acoshl</span><span class="params">()</span></span> ----求反双曲余弦值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atan</span><span class="params">()</span></span> / <span class="function"><span class="title">atanf</span><span class="params">()</span></span> / <span class="function"><span class="title">atanl</span><span class="params">()</span></span> ----求反正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atan2</span><span class="params">()</span></span> / <span class="function"><span class="title">atan2f</span><span class="params">()</span></span> / <span class="function"><span class="title">atan2l</span><span class="params">()</span></span> ----求坐标值的反正切值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">atanh</span><span class="params">()</span></span> / <span class="function"><span class="title">atanhf</span><span class="params">()</span></span> / <span class="function"><span class="title">atanhl</span><span class="params">()</span></span> ----求反双曲正切值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>转自 简书 <a href="http://www.jianshu.com/p/0ca725ecf7f7" target="_blank" rel="external">http://www.jianshu.com/p/0ca725ecf7f7</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-github-iOS-top-100" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/19/github-iOS-top-100/" class="article-date">
  	<time datetime="2015-08-19T15:03:05.000Z" itemprop="datePublished">2015-08-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/19/github-iOS-top-100/">GitHub iOS Top 100 简介</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GitHub_Top_100_简介">GitHub Top 100 简介</h2><p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p>
<p><strong>若有任何疑问可通过微博<a href="http://weibo.com/jinfali" target="_blank" rel="external">@李锦发</a>联系我</strong></p>
<table>
<thead>
<tr>
<th>项目名称</th>
<th>项目信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></td>
<td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td>
</tr>
<tr>
<td>2. <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a></td>
<td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a href="http://stackoverflow.com/users/19679/brad-larson" target="_blank" rel="external">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td>
</tr>
<tr>
<td>3. <a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a></td>
<td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td>
</tr>
<tr>
<td>4. <a href="https://github.com/RestKit/RestKit" target="_blank" rel="external">RestKit</a></td>
<td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td>
</tr>
<tr>
<td>5. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a></td>
<td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a href="http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction" target="_blank" rel="external">文章</a></td>
</tr>
<tr>
<td>6. <a href="https://github.com/facebookarchive/three20" target="_blank" rel="external">three20</a></td>
<td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a href="https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269" target="_blank" rel="external">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="external">Nimbus</a>, 算是 three20 的一个替代品</td>
</tr>
<tr>
<td>7. <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">MBProgressHUD</a></td>
<td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td>
</tr>
<tr>
<td>8. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">MagicalRecord</a></td>
<td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td>
</tr>
<tr>
<td>9. <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a></td>
<td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td>
</tr>
<tr>
<td>10. <a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a></td>
<td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td>
</tr>
<tr>
<td>11. <a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="external">FlatUIKit</a></td>
<td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td>
</tr>
<tr>
<td>12. <a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="external">ASIHTTPRequest</a></td>
<td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td>
</tr>
<tr>
<td>13. <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache</a></td>
<td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td>
</tr>
<tr>
<td>14. <a href="https://github.com/Masonry/Masonry" target="_blank" rel="external">Masonry</a></td>
<td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td>
</tr>
<tr>
<td>15. <a href="https://github.com/facebook/Shimmer" target="_blank" rel="external">Shimmer</a></td>
<td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td>
</tr>
<tr>
<td>16. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" rel="external">SVProgressHUD</a></td>
<td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td>
</tr>
<tr>
<td>17. <a href="https://github.com/jigish/slate" target="_blank" rel="external">Slate</a></td>
<td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td>
</tr>
<tr>
<td>18. <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">JSONKit</a></td>
<td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td>
</tr>
<tr>
<td>19. <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="external">Nimbus</a></td>
<td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td>
</tr>
<tr>
<td>20. <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="external">CocoaLumberjack</a></td>
<td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td>
</tr>
<tr>
<td>21. <a href="https://github.com/facebook/facebook-ios-sdk" target="_blank" rel="external">Facebook SDK for iOS</a></td>
<td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td>
</tr>
<tr>
<td>22. <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a></td>
<td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td>
</tr>
<tr>
<td>23. <a href="https://github.com/supermarin/Alcatraz" target="_blank" rel="external">Alcatraz</a></td>
<td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td>
</tr>
<tr>
<td>24. <a href="https://github.com/Inferis/ViewDeck" target="_blank" rel="external">ViewDeck</a></td>
<td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td>
</tr>
<tr>
<td>25. <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="external">JSQMessagesViewController</a></td>
<td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td>
</tr>
<tr>
<td>26. <a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">FLEX</a></td>
<td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td>
</tr>
<tr>
<td>27. <a href="https://github.com/facebook/xctool" target="_blank" rel="external">Xctool</a></td>
<td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a href="https://travis-ci.org" target="_blank" rel="external">Travis CI</a>, <a href="http://oclint.org" target="_blank" rel="external">OCLint</a> 等测试工具</td>
</tr>
<tr>
<td>28. <a href="https://github.com/OpenEmu/OpenEmu" target="_blank" rel="external">OpenEmu</a></td>
<td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td>
</tr>
<tr>
<td>29. <a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a></td>
<td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td>
</tr>
<tr>
<td>30. <a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="external">RESideMenu</a></td>
<td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td>
</tr>
<tr>
<td>321 <a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a></td>
<td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td>
</tr>
<tr>
<td>31.2<a href="https://github.com/square/PonyDebugger" target="_blank" rel="external">PonyDebugger</a></td>
<td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td>
</tr>
<tr>
<td>33. <a href="https://github.com/jverdi/JVFloatLabeledTextField" target="_blank" rel="external">JVFloatLabeledTextField</a></td>
<td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td>
</tr>
<tr>
<td>34. <a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">SWTableViewCell</a></td>
<td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td>
</tr>
<tr>
<td>35. <a href="https://github.com/levey/AwesomeMenu" target="_blank" rel="external">AwesomeMenu</a></td>
<td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td>
</tr>
<tr>
<td>36. <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a></td>
<td>Reachablity 是用于检测 iOS 设备网络环境的库</td>
</tr>
<tr>
<td>37. <a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter-Xcode</a></td>
<td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td>
</tr>
<tr>
<td>38. <a href="https://github.com/google/physical-web" target="_blank" rel="external">The Physical Web</a></td>
<td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td>
</tr>
<tr>
<td>39. <a href="https://github.com/samuelclay/NewsBlur" target="_blank" rel="external">NewsBlur</a></td>
<td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td>
</tr>
<tr>
<td>40. <a href="https://github.com/cocos2d/cocos2d-spritebuilder" target="_blank" rel="external">Cocos2D-SpriteBuilder</a></td>
<td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td>
</tr>
<tr>
<td>41. <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a></td>
<td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td>
</tr>
<tr>
<td>42. <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">CocoaAsyncSocket</a></td>
<td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td>
</tr>
<tr>
<td>43. <a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="external">TapkuLibrary</a></td>
<td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td>
</tr>
<tr>
<td>44. <a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="external">Canvas</a></td>
<td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td>
</tr>
<tr>
<td>45. <a href="https://github.com/square/SocketRocket" target="_blank" rel="external">SocketRocket</a></td>
<td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td>
</tr>
<tr>
<td>46. <a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="external">ECSlidingViewController</a></td>
<td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td>
</tr>
<tr>
<td>47. <a href="https://github.com/stig/json-framework" target="_blank" rel="external">Json Framework</a></td>
<td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td>
</tr>
<tr>
<td>48. <a href="https://github.com/facebook/Tweaks" target="_blank" rel="external">Tweaks</a></td>
<td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td>
</tr>
<tr>
<td>49. <a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">realm-cocoa</a></td>
<td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td>
</tr>
<tr>
<td>50. <a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="external">BlocksKit</a></td>
<td>一个开源的与 Cocoa 紧密集合的基础性框架</td>
</tr>
<tr>
<td>51. <a href="https://github.com/arashpayan/appirater" target="_blank" rel="external">Appirater</a></td>
<td>一款用于提醒用户给你的 App 打分的工具</td>
</tr>
<tr>
<td>52. <a href="https://github.com/kif-framework/KIF" target="_blank" rel="external">KIF</a></td>
<td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td>
</tr>
<tr>
<td>53. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" rel="external">SlackTextViewController</a></td>
<td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td>
</tr>
<tr>
<td>54. <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">JazzHands</a></td>
<td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td>
</tr>
<tr>
<td>55. <a href="https://github.com/BoltsFramework/Bolts-iOS" target="_blank" rel="external">Bolts-iOS</a></td>
<td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td>
</tr>
<tr>
<td>56. <a href="https://github.com/eczarny/spectacle" target="_blank" rel="external">Spectacle</a></td>
<td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td>
</tr>
<tr>
<td>57. <a href="https://github.com/tombenner/nui" target="_blank" rel="external">nui</a></td>
<td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td>
</tr>
<tr>
<td>58. <a href="https://github.com/Induction/Induction" target="_blank" rel="external">Induction</a></td>
<td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td>
</tr>
<tr>
<td>59. <a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="external">JSONModel</a></td>
<td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td>
</tr>
<tr>
<td>60. <a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="external">DTCoreText</a></td>
<td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td>
</tr>
<tr>
<td>61. <a href="https://github.com/schneiderandre/popping" target="_blank" rel="external">Popping</a></td>
<td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td>
</tr>
<tr>
<td>62. <a href="https://github.com/KrauseFx/TSMessages" target="_blank" rel="external">TSMessages</a></td>
<td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td>
</tr>
<tr>
<td>63. <a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a></td>
<td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td>
</tr>
<tr>
<td>64. <a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="external">MWPhotoBrowser</a></td>
<td>一款简单的 iOS 照片浏览控件</td>
</tr>
<tr>
<td>65. <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">MMDrawerController</a></td>
<td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td>
</tr>
<tr>
<td>66. <a href="https://github.com/escoz/QuickDialog" target="_blank" rel="external">QuickDialog</a></td>
<td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td>
</tr>
<tr>
<td>67. <a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="external">SVPullToRefresh</a></td>
<td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td>
</tr>
<tr>
<td>68. <a href="https://github.com/nothingmagical/cheddar-ios" target="_blank" rel="external">cheddar-ios</a></td>
<td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td>
</tr>
<tr>
<td>69. <a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">XVim</a></td>
<td>一款在 Xcode 上实现了 Vim 功能的插件</td>
</tr>
<tr>
<td>70. <a href="https://github.com/enormego/EGOTableViewPullRefresh" target="_blank" rel="external">EGOTableViewPullRefresh</a></td>
<td>一款提供下拉刷新的控件, 最后更新时间是一年前</td>
</tr>
<tr>
<td>71. <a href="https://github.com/gimenete/iOS-boilerplate" target="_blank" rel="external">iOS-boilerplate</a></td>
<td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td>
</tr>
<tr>
<td>72. <a href="https://github.com/gotosleep/JASidePanels" target="_blank" rel="external">JASidePanels</a></td>
<td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td>
</tr>
<tr>
<td>73. <a href="https://github.com/mattt/FormatterKit" target="_blank" rel="external">FormatterKit</a></td>
<td>收集了很多构思优秀的 NSFormatter 子类</td>
</tr>
<tr>
<td>74. <a href="https://github.com/erichoracek/MSDynamicsDrawerViewController" target="_blank" rel="external">MSDynamicsDrawerViewController</a></td>
<td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td>
</tr>
<tr>
<td>75. <a href="https://github.com/boctor/idev-recipes" target="_blank" rel="external">idev-recipes</a></td>
<td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td>
</tr>
<tr>
<td>76. <a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="external">XMPPFramework</a></td>
<td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td>
</tr>
<tr>
<td>77. <a href="https://github.com/MacGapProject/MacGap1" target="_blank" rel="external">MacGap1</a></td>
<td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td>
</tr>
<tr>
<td>78. <a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">FXBlurView</a></td>
<td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td>
</tr>
<tr>
<td>79. <a href="https://github.com/shu223/iOS7-Sampler" target="_blank" rel="external">iOS7-Sampler</a></td>
<td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>80. <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="external">PromiseKit</a></td>
<td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td>
</tr>
<tr>
<td>81. <a href="https://github.com/facebook/origami" target="_blank" rel="external">Origami</a></td>
<td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td>
</tr>
<tr>
<td>82. <a href="https://github.com/fpillet/NSLogger" target="_blank" rel="external">NSLogger</a></td>
<td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td>
</tr>
<tr>
<td>83. <a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">KSImageNamed-Xcode</a></td>
<td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td>
</tr>
<tr>
<td>84. <a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">PureLayout</a></td>
<td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td>
</tr>
<tr>
<td>85. <a href="https://github.com/tomaz/appledoc" target="_blank" rel="external">AppleDoc</a></td>
<td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td>
</tr>
<tr>
<td>86. <a href="https://github.com/gnachman/iTerm2" target="_blank" rel="external">iTerm2</a></td>
<td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td>
</tr>
<tr>
<td>87. <a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="external">Kiwi</a></td>
<td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td>
</tr>
<tr>
<td>88. <a href="https://github.com/alloy/terminal-notifier" target="_blank" rel="external">terminal-notifier</a></td>
<td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td>
</tr>
<tr>
<td>89. <a href="https://github.com/uranusjr/macdown" target="_blank" rel="external">MacDown</a></td>
<td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td>
</tr>
<tr>
<td>90. <a href="https://github.com/twitter/twui" target="_blank" rel="external">TwUI</a></td>
<td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td>
</tr>
<tr>
<td>91. <a href="https://github.com/honcheng/PaperFold-for-iOS" target="_blank" rel="external">PaperFold for iOS</a></td>
<td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td>
</tr>
<tr>
<td>92. <a href="https://github.com/vfr/Reader" target="_blank" rel="external">Reader</a></td>
<td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td>
</tr>
<tr>
<td>93. <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></td>
<td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td>
</tr>
<tr>
<td>94. <a href="https://github.com/shu223/iOS8-Sampler" target="_blank" rel="external">iOS8-Sampler</a></td>
<td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td>
</tr>
<tr>
<td>95. <a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="external">CocoaHTTPServer</a></td>
<td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td>
</tr>
<tr>
<td>96. <a href="https://github.com/rsms/kod" target="_blank" rel="external">Kod</a></td>
<td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td>
</tr>
<tr>
<td>97. <a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="external">TPKeyboardAvoiding</a></td>
<td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td>
</tr>
<tr>
<td>98. <a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="external">MKNetworkKit</a></td>
<td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td>
</tr>
<tr>
<td>99. <a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="external">PKRevealController</a></td>
<td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td>
</tr>
<tr>
<td>00. <a href="https://github.com/AlanQuatermain/AQGridView" target="_blank" rel="external">AQGridView</a></td>
<td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td>
</tr>
</tbody>
</table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-Photo-album" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/18/iOS-Photo-album/" class="article-date">
  	<time datetime="2015-08-18T14:15:53.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/iOS-Photo-album/">iOS 开发只保存照片到系统相册</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>保存照片到系统相册这个功能很多社交类的APP都有的，今天我们简单讲解一下，如何将图片保存到系统相册（Photo Album）。</p>
<h4 id="创建UIImageView">创建UIImageView</h4><p>创建<code>UIImageView</code>是为了将照片展示出来，我们是要把<code>UIImage</code>保存到系统相册（Photo Album）:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define SCREEN [UIScreen mainScreen].bounds.size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"iOSDevTip"</span>];</span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((SCREEN<span class="variable">.width</span> - <span class="number">300</span>) / <span class="number">2</span>, <span class="number">70</span>, <span class="number">300</span>, <span class="number">150</span>)];</span><br><span class="line">imageView<span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.image</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br></pre></td></tr></table></figure></p>
<h4 id="创建UIButton">创建UIButton</h4><p>创建<code>UIButton</code>并绑定<code>actionClick:</code>事件:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UIButton *button = [[UIButton alloc] init];</span><br><span class="line">button.frame = CGRectMake( <span class="number">100</span>, <span class="number">300</span>, SCREEN.width - <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">[button <span class="string">addTarget:</span>self <span class="string">action:</span><span class="annotation">@selector</span>(<span class="string">actionClick:</span>) <span class="string">forControlEvents:</span>UIControlEventTouchUpInside];</span><br><span class="line">[button <span class="string">setTitleColor:</span>[UIColor blueColor] <span class="string">forState:</span>UIControlStateNormal];</span><br><span class="line">[button <span class="string">setBackgroundColor:</span>[UIColor orangeColor]];</span><br><span class="line">[button <span class="string">setTitle:</span>@<span class="string">"SavePhoto"</span> <span class="string">forState:</span>UIControlStateNormal];</span><br><span class="line">[self.view <span class="string">addSubview:</span>button];</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">actionClick:</span>(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="保存照片到系统相册（Photo_Album）">保存照片到系统相册（Photo Album）</h4><p>在<code>actionClick:</code>方法里调用：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImageWriteToSavedPhotosAlbum<span class="list">(<span class="keyword">self</span>.image, self, @selector<span class="list">(<span class="keyword">image</span><span class="keyword">:didFinishSavingWithError</span><span class="keyword">:contextInfo</span>:)</span>, NULL)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们想知道保存是否成功，所以需要指定回掉方法</p>
<blockquote>
<p>这是SDK提供的默认指定回调方法<br>// Adds a photo to the saved photos album.  The optional completionSelector should have the form:<br>//  - (void)image:(UIImage <em>)image didFinishSavingWithError:(NSError </em>)error contextInfo:(void <em>)contextInfo;<br>UIKIT_EXTERN void UIImageWriteToSavedPhotosAlbum(UIImage </em>image, id completionTarget, SEL completionSelector, void *contextInfo);</p>
</blockquote>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定回调方法</span></span><br><span class="line">- <span class="params">(void)</span>image:<span class="params">(UIImage *)</span>image didFinishSavingWithError:<span class="params">(NSError *)</span>error contextInfo:<span class="params">(void *)</span>contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(!error)</span>&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"save success"</span>)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"save failed"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，我们就知道照片是否保存成功。然后，根据需求来刷新UI线程。demo地址: <a href="https://github.com/worldligang/iOSStrongDemo" target="_blank" rel="external">https://github.com/worldligang/iOSStrongDemo</a> </p>
<blockquote>
<p>本文转自微信号<code>iOSDevTip</code></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-runtime-basic" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/17/iOS-runtime-basic/" class="article-date">
  	<time datetime="2015-08-17T15:24:59.000Z" itemprop="datePublished">2015-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/17/iOS-runtime-basic/">iOS~runtime 基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是Runtime">什么是Runtime</h4><ul>
<li>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target doSomething];</code>会被转化<code>成objc_msgSend(target, @selector(doSomething));</code></li>
<li>OC中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象。实际上一个类本质上也是一个对象，在runtime中用结构体表示。</li>
<li><p>相关的定义：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 描述类中的一个方法</span></span><br><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实例变量</span></span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 类别Category</span></span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 类中声明的属性</span></span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类在runtime中的表示</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类在runtime中的表示</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;<span class="comment">//指针，顾名思义，表示是一个什么，</span></span><br><span class="line">    <span class="comment">//实例的isa指向类对象，类对象的isa指向元类</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class;  <span class="comment">//指向父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">long</span> version;</span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars <span class="comment">//成员变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists; <span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;<span class="comment">//缓存</span></span><br><span class="line">    <span class="comment">//一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols <span class="comment">//协议列表</span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<h4 id="获取列表">获取列表</h4><p>有时候会有这样的需求，我们需要知道当前类中每个属性的名字（比如字典转模型，字典的Key和模型对象的属性名字不匹配）。<br>我们可以通过runtime的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//获取属性列表</span></span><br><span class="line">    objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(propertyList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"property----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:propertyName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法列表</span></span><br><span class="line">    Method *methodList = class_copyMethodList([<span class="keyword">self</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method----&gt;%@"</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取成员变量列表</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList([<span class="keyword">self</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">        Ivar myIvar = ivarList[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *ivarName = ivar_getName(myIvar);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Ivar----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:ivarName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取协议列表</span></span><br><span class="line">    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([<span class="keyword">self</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i; i&lt;count; i++) &#123;</span><br><span class="line">        Protocol *myProtocal = protocolList[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *protocolName = protocol_getName(myProtocal);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"protocol----&gt;%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:protocolName]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Xcode上跑一下看看输出吧，需要给你当前的类写几个属性，成员变量，方法和协议，不然获取的列表是没有东西的。<br>注意，调用这些获取列表的方法别忘记导入头文件<code>#import &lt;objc/runtime.h&gt;</code></p>
<h4 id="方法调用">方法调用</h4><p>让我们看一下方法调用在运行时的过程（参照前文类在runtime中的表示）</p>
<h5 id="如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。">如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。</h5><h5 id="如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。">如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。</h5><ol>
<li>首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行。</li>
<li>如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行</li>
<li>如果没找到，去父类指针所指向的对象中执行1，2.</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用。</li>
<li>如果没有重写拦截调用的方法，程序报错。</li>
</ol>
<h5 id="以上的过程给我带来的启发：">以上的过程给我带来的启发：</h5><ul>
<li>重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法后就不会再去父类中找了。</li>
<li>如果想调用已经重写过的方法的父类的实现，只需使用<code>super</code>这个编译器标识，它会在运行时跳过在当前的类对象中寻找方法的过程。</li>
</ul>
<h4 id="拦截调用">拦截调用</h4><p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。<br>那么什么是拦截调用呢。<br>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写<code>NSObject</code>的四个方法来处理。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="params">(BOOL)</span>resolveClassMethod:<span class="params">(SEL)</span>sel;</span><br><span class="line">+ <span class="params">(BOOL)</span>resolveInstanceMethod:<span class="params">(SEL)</span>sel;</span><br><span class="line"><span class="comment">//后两个方法需要转发到其他的类处理</span></span><br><span class="line">- <span class="params">(id)</span>forwardingTargetForSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(void)</span>forwardInvocation:<span class="params">(NSInvocation *)</span>anInvocation;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</li>
<li>第二个方法和第一个方法相似，只不过处理的是实例方法。</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。</li>
<li>第四个方法是将你调用的不存在的方法打包成<code>NSInvocation</code>传给你。做完你自己的处理后，调用<code>invokeWithTarget:</code>方法让某个target触发这个方法。</li>
</ul>
<h4 id="动态添加方法">动态添加方法</h4><p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢？<br>有一个办法是根据传进来的<code>SEL</code>类型的<code>selector</code>动态添加一个方法。<br>首先从外部隐式调用一个不存在的方法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式调用方法</span></span><br><span class="line">[target <span class="string">performSelector:</span><span class="annotation">@selector</span>(<span class="string">resolveAdd:</span>) <span class="string">withObject:</span>@<span class="string">"test"</span>];</span><br></pre></td></tr></table></figure></p>
<p> 然后，在target对象内部重写拦截调用的方法，动态添加方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runAddMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *string)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"add C IMP "</span>, string);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给本类动态添加一个方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"resolveAdd:"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)runAddMethod, <span class="string">"v@:*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中<code>class_addMethod</code>的四个参数分别是：</p>
<ol>
<li><code>Class cls</code>给哪个类添加方法，本例中是self</li>
<li><code>SEL name</code>添加的方法，本例中是重写的拦截调用传进来的selector。</li>
<li><code>IMP imp</code>方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现。</li>
<li><code>&quot;v@:*&quot;</code>方法的签名，代表有一个参数的方法。</li>
</ol>
<h4 id="关联对象">关联对象</h4><p>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。<br>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。<br>这个时候，runtime的关联属性就发挥它的作用了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个全局变量，用它的地址作为关联对象的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> associatedObjectKey;</span><br><span class="line"><span class="comment">//设置关联对象</span></span><br><span class="line">objc_setAssociatedObject(target, &amp;associatedObjectKey, <span class="string">@"添加的字符串属性"</span>, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>); <span class="comment">//获取关联对象</span></span><br><span class="line"><span class="built_in">NSString</span> *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"AssociatedObject = %@"</span>, string);</span><br></pre></td></tr></table></figure></p>
<p><code>objc_setAssociatedObject</code>的四个参数：</p>
<ol>
<li><code>id object</code>给谁设置关联对象。</li>
<li>·const void *key·关联对象唯一的key，获取时会用到。</li>
<li><code>id value</code>关联对象。</li>
<li><code>objc_AssociationPolicy</code>关联策略，有以下几种策略：<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">    OBJC_ASSOCIATION_ASSIGN</span> = <span class="number">0</span>,</span><br><span class="line"><span class="constant">    OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> = <span class="number">1</span>, </span><br><span class="line"><span class="constant">    OBJC_ASSOCIATION_COPY_NONATOMIC</span> = <span class="number">3</span>,</span><br><span class="line"><span class="constant">    OBJC_ASSOCIATION_RETAIN</span> = <span class="number">01401</span>,</span><br><span class="line"><span class="constant">    OBJC_ASSOCIATION_COPY</span> = <span class="number">01403</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果你熟悉OC，看名字应该知道这几种策略的意思了吧。<br><code>objc_getAssociatedObject</code>的两个参数。</p>
<ol>
<li><code>id object</code>获取谁的关联对象。</li>
<li><code>const void *key</code>根据这个唯一的key获取关联对象。</li>
</ol>
<p>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)addAssociatedObject:(<span class="keyword">id</span>)object&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(getAssociatedObject), object, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取关联对象</span></span><br><span class="line">- (<span class="keyword">id</span>)getAssociatedObject&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>这里面我们把<code>getAssociatedObject</code>方法的地址作为唯一的<code>key</code>，<code>_cmd</code>代表当前调用方法的地址。</p>
<h4 id="方法交换">方法交换</h4><p>方法交换，顾名思义，就是将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法中的代码，反之亦然。<br>话不多说，这是参考Mattt大神在NSHipster上的文章自己写的代码。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIViewController+swizzling.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">swizzling</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//load方法会在类第一次加载的时候被调用</span></span><br><span class="line"><span class="comment">//调用的时间比较靠前，适合在这个方法里做方法交换</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="comment">//方法交换应该被保证，在程序中只会执行一次</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得viewController的生命周期方法的selector</span></span><br><span class="line">        SEL systemSel = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        <span class="comment">//自己实现的将要被交换的方法的selector</span></span><br><span class="line">        SEL swizzSel = <span class="keyword">@selector</span>(swiz_viewWillAppear:);</span><br><span class="line">        <span class="comment">//两个方法的Method</span></span><br><span class="line">        Method systemMethod = class_getInstanceMethod([<span class="keyword">self</span> class], systemSel);</span><br><span class="line">        Method swizzMethod = class_getInstanceMethod([<span class="keyword">self</span> class], swizzSel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span></span><br><span class="line">        <span class="built_in">BOOL</span> isAdd = class_addMethod(<span class="keyword">self</span>, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));</span><br><span class="line">        <span class="keyword">if</span> (isAdd) &#123;</span><br><span class="line">            <span class="comment">//如果成功，说明类中不存在这个方法的实现</span></span><br><span class="line">            <span class="comment">//将被交换方法的实现替换到这个并不存在的实现</span></span><br><span class="line">            class_replaceMethod(<span class="keyword">self</span>, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则，交换两个方法的实现</span></span><br><span class="line">            method_exchangeImplementations(systemMethod, swizzMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swiz_viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    <span class="comment">//这时候调用自己，看起来像是死循环</span></span><br><span class="line">    <span class="comment">//但是其实自己的实现已经被替换了</span></span><br><span class="line">    [<span class="keyword">self</span> swiz_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"swizzle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>在一个自己定义的viewController中重写viewWillAppear<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">viewWillAppear:</span>(BOOL)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">viewWillAppear:</span>animated];</span><br><span class="line">    NSLog(@<span class="string">"viewWillAppear"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run起来看看输出吧！</p>
<p><strong>我的理解:</strong></p>
<ul>
<li>方法交换对于我来说更像是实现一种思想的最佳技术：AOP面向切面编程。</li>
<li>既然是切面，就一定不要忘记，交换完再调回自己。</li>
<li>一定要保证只交换一次，否则就会很乱。</li>
<li>最后，据说这个技术很危险，谨慎使用。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-EGOCache-check-cache-expired" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/16/EGOCache-check-cache-expired/" class="article-date">
  	<time datetime="2015-08-16T15:59:47.000Z" itemprop="datePublished">2015-08-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/16/EGOCache-check-cache-expired/">EGOCache如何检测缓存时间过期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>子曰:学而不思则罔,思而不学则殆。</p>
</blockquote>
<p>在上一篇文章中：EGOCache缓存框架详细讲解 提到EGOCache可以设定缓存过期时间，默认是1天。查看了一下EGOCache源码，设置默认时间：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[self setDefaultTimeoutInterval:86400]</span>;</span><br><span class="line"><span class="comment">//86400 = 24 * 60 * 60 刚好是一天时间。</span></span><br></pre></td></tr></table></figure></p>
<p>EGOCache为什么要提供设定缓存过期时间呢？或者说设定缓存过期时间有什么好处呢？我觉得最大的好处就是可以定时清除缓存。可以设置某一项的缓存时间，很方便管理缓存。</p>
<p>那么问题来了：</p>
<ol>
<li>EGOCache是怎么检测缓存过期时间的呢？</li>
<li>检测到时间过期之后，什么时候触发删除缓存项的？</li>
</ol>
<p>带着这两个问题，我们来继续分析。</p>
<h4 id="你会怎么实现">你会怎么实现</h4><p>记得在公司里，老板经常会举这样的例子：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某同志，刚来我们公司的时候，遇到问题就知道抱怨。从来不知道去思考怎么解决，只知道把问题抛给领导。工作半年下来，成长了很多。现在碰到问题，不仅把问题抛出来，而且还提供了自己的解决方案...</span><br></pre></td></tr></table></figure></p>
<p>类似的例子，相信大家都听过。同样，既然前面我们提出这两个问题，我们也先来思考一下，如果我们来做该怎么解决？</p>
<p>如果让我来写的话，我脑海里初步实现方法有几个：</p>
<ol>
<li>通过定时器来轮询，每隔一段时间检测一次。</li>
<li>写一个while循环来检测。</li>
<li>每次去读取缓存项的时候，判断缓存时间有没有过期。没过期，就返回读取的缓存项；否则，返回nil。</li>
</ol>
<p>当然，还有一些方法，不一一例举了。仔细想想，这些方法弊端很容易显露出来。</p>
<ol>
<li>为了小小的缓存时间，就用定时器轮询，显然是资源浪费</li>
<li>跟方法1差不多。</li>
<li>每次读取的时候判断是否过期，如果一直不读取，app的缓存会越来越大，也不可取。</li>
</ol>
<p>这些方法都被排除了，还有好的方法吗？继续往下看：</p>
<h4 id="EGOCache是怎么实现的？">EGOCache是怎么实现的？</h4><p>仔细查看EGOCache源码，发现在initWithCacheDirectory:方法里，每次初始化EGOCache实例对象的时，会遍历一遍plist文件中所有已存在的缓存项，拿每个缓存项的时间和当前时间作比较，缓存项过期时间早于当前时间，则删除对应缓存文件，并删除 plist 文件中对应 key 的记录。</p>
<p>具体实现代码如下：</p>
<h4 id="读取缓存项信息">读取缓存项信息</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">_cacheInfo</span> = [[<span class="name">NSDictionary</span> <span class="atom">dictionaryWithContentsOfFile</span>:<span class="atom">cachePathForKey</span>(<span class="name">_directory</span>, @<span class="string">"EGOCache.plist"</span>)] <span class="atom">mutableCopy</span>];</span><br><span class="line"></span><br><span class="line"><span class="atom">if</span>(!<span class="name">_cacheInfo</span>) &#123;</span><br><span class="line">    <span class="name">_cacheInfo</span> = [[<span class="name">NSMutableDictionary</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取当前时间的NSTimeInterval">获取当前时间的NSTimeInterval</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval now = <span class="comment">[<span class="comment">[NSDate date]</span> timeIntervalSinceReferenceDate]</span>;</span><br></pre></td></tr></table></figure>
<h4 id="声明removedKeys保存过期的缓存项对应的key">声明removedKeys保存过期的缓存项对应的key</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray* removedKeys = <span class="comment">[<span class="comment">[NSMutableArray alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<h4 id="遍历缓存项信息并判断缓存时间">遍历缓存项信息并判断缓存时间</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">for</span>(NSString* key in _cacheInfo) &#123;</span><br><span class="line">    <span class="comment">//判断缓存项过期时间是否早于当前时间</span></span><br><span class="line">    <span class="tag">if</span>([_cacheInfo[key] timeIntervalSinceReferenceDate] &lt;= now) &#123;</span><br><span class="line">        <span class="comment">//如果缓存项过期时间早于当前时间，移除缓存项</span></span><br><span class="line">        <span class="attr_selector">[[NSFileManager defaultManager]</span> <span class="tag">removeItemAtPath</span><span class="pseudo">:cachePathForKey</span>(_directory, key) <span class="tag">error</span><span class="pseudo">:NULL</span>];</span><br><span class="line">        <span class="comment">//把过期的缓存项对于的key保存到removedKeys里面</span></span><br><span class="line">        <span class="attr_selector">[removedKeys addObject:key]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除过期缓存项对于的key">删除过期缓存项对于的key</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[_cacheInfo removeObjectsForKeys:removedKeys]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>看到这些，是不是觉得人家思路特牛叉，反正，我是觉得这个作者不简单。到这一步就解决了吗？</p>
<h4 id="EGOCache还做了什么？">EGOCache还做了什么？</h4><p>细心的童鞋会发现：EGOCache是个单列类，也就是说整个程序应用周期只初始化一次。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>instancetype<span class="function">)</span>globalCache &#123;</span><br><span class="line">   <span class="keyword"> static</span> id instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> static</span> dispatch_once_t onceToken;</span><br><span class="line">   <span class="function"> dispatch_once(</span>&amp;onceToken, ^&#123;</span><br><span class="line">       <span class="instruction"> instance </span>= <span class="keyword">[</span><span class="keyword">[</span><span class="keyword">[</span>self class] alloc] init];</span><br><span class="line">    &#125;<span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> return </span>instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次初始化的时候去判断了缓存项是否过期，这样做非常正确。思考一个场景：</p>
<ol>
<li>用户打开app，EGOCache被初始化，并判断了缓存项是否过期。</li>
<li>如果刚好有一些缓存项在EGOCache被初始化之后过期。这个时候我们依然可以读到这个缓存项。这就不对了。</li>
</ol>
<p>继续分析EGOCache源码发现，EGOCache在读取一个缓存项的时候，先判断缓存项是否存在，然后读取缓存项（注意：是读取EGOCache初始化的时候没有过期的缓存项，并没有说现在没有过期），最后去判断读取到的缓存项跟当前时间相比是否过期.</p>
<p>具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)hasCacheForKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">    <span class="comment">//读取EGOCache初始化的时候没有过期的缓存项</span></span><br><span class="line">    <span class="built_in">NSDate</span>* date = [<span class="keyword">self</span> dateForKey:key];</span><br><span class="line">    <span class="keyword">if</span>(date == <span class="literal">nil</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//判断读取到的缓存项当前是否过期</span></span><br><span class="line">    <span class="keyword">if</span>([date timeIntervalSinceReferenceDate] &lt; <span class="built_in">CFAbsoluteTimeGetCurrent</span>()) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:cachePathForKey(_directory, key)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDate</span>*)dateForKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">    __block <span class="built_in">NSDate</span>* date = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_frozenCacheInfoQueue, ^&#123;</span><br><span class="line">        date = (<span class="keyword">self</span><span class="variable">.frozenCacheInfo</span>)[key];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EGOCache检测缓存时间过期的思路值得学习，以后遇到类似场景，完全可以借鉴。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-multiple-uiimage-merged" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/12/multiple-uiimage-merged/" class="article-date">
  	<time datetime="2015-08-12T15:45:58.000Z" itemprop="datePublished">2015-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/12/multiple-uiimage-merged/">iOS多张图片合并</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写了两篇关于照片保存的文章：</p>
<p>iOS开发之保存照片到系统相册（Photo Album）<br>iOS开发之保存照片到自己创建的相簿<br>介绍了如何将图片保存到系统相册，也可以将照片保存到自己的相簿。里面还介绍了一个第三方<code>ALAssetsLibrary+CustomPhotoAlbum</code>保存照片的方法。</p>
<p>本篇文章将会介绍如何将多个<code>UIImage</code>合并成一个<code>UIImage</code>。听起来似乎有点晕晕乎乎的，这个可以合并吗？答案是肯定的。我们拿两个<code>UIImage</code>来举例。</p>
<p>创建两个UIImage<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"iOSDevTip"</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CodePush"</span>];</span><br></pre></td></tr></table></figure></p>
<p>创建UIImage的方法有很多种，我们就简单的通过imageNamed:方法来创建。</p>
<hr>
<p>合并之后的size<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGSize <span class="built_in">size</span> = CGSizeMake(image1.<span class="built_in">size</span>.<span class="variable">width</span> + image2.<span class="built_in">size</span>.<span class="variable">width</span>, image1.<span class="built_in">size</span>.<span class="variable">height</span>);</span><br></pre></td></tr></table></figure></p>
<p>合并两个<code>UIImage</code>，需要计算合并之后的<code>size</code>。假设这两个<code>UIImage</code>的高度是是相同的，把他们的宽度相加，得到合并之后的<code>UIImage</code>的<code>size</code>。</p>
<hr>
<p>合并方法</p>
<p>有了UIImage和size接下来就是把两个<code>UIImage</code>合并，方法如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> UIGraphicsBeginImageContext(<span class="built_in">size</span>);</span><br><span class="line">[image1 drawInRect:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, image1.<span class="built_in">size</span>.<span class="variable">width</span>, <span class="built_in">size</span>.<span class="variable">height</span>)];</span><br><span class="line">[image2 drawInRect:CGRectMake(image1.<span class="built_in">size</span>.<span class="variable">width</span>, <span class="number">0</span>, image2.<span class="built_in">size</span>.<span class="variable">width</span>, <span class="built_in">size</span>.<span class="variable">height</span>)];</span><br><span class="line">UIImage *togetherImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure></p>
<p>通过上述的代码，就可以实现两个<code>UIImage</code>的合并。` 这个小功能还挺有用的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-baidumapsdk" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/09/baidumapsdk/" class="article-date">
  	<time datetime="2015-04-08T23:58:30.000Z" itemprop="datePublished">2015-04-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/09/baidumapsdk/">集成百度地图sdk出现的问题记录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-_Undefined_symbols_for_architecture_x86_64:_“_OBJCCLASS$_BMKMapManager”,_referenced_from:">1. Undefined symbols for architecture x86_64:   “_OBJC<em>CLASS</em>$_BMKMapManager”, referenced from:</h3><p>在<code>Other linker Flags</code> 加入 -ObjC -all_load -lbaidumapapi</p>
<h3 id="2-_manager_start_failed">2. manager start failed</h3><p>Xcode 6上遇到manager start failed<br>原因:info.plipst中设置Bundle display name<br>*这个要跟申请key的时候保持一致！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 键盘
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>