<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="keywords" content="键盘的记忆,iOS学习,html5,混合开发">
  
  <title>键盘的记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客,记录重要知识,iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="键盘的记忆">
<meta property="og:url" content="http://blog.onecat.cc/index.html">
<meta property="og:site_name" content="键盘的记忆">
<meta property="og:description" content="写博客,记录重要知识,iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="键盘的记忆">
<meta name="twitter:description" content="写博客,记录重要知识,iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="键盘的记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">键盘</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">键盘</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">键盘</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-iOS-9适配" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/10/iOS-9适配/" class="article-date">
  	<time datetime="2015-09-10T01:40:52.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/iOS-9适配/">iOS 9适配</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/ChenYilong/iOS9AdaptationTips/blob/master/README.md" target="_blank" rel="external">iOS9适配</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS，iOS9/">iOS，iOS9</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-13个小技巧帮你征服Xcode" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/09/13个小技巧帮你征服Xcode/" class="article-date">
  	<time datetime="2015-09-08T22:47:07.000Z" itemprop="datePublished">2015-09-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/09/13个小技巧帮你征服Xcode/">13个小技巧帮你征服Xcode</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文由CocoaChina翻译组成员唧唧歪歪（博客）翻译自David McGraw的博客</p>
<p>原文：13 Xcode Tips That Will Help You Conquer Xcode<br>当谈论到iOS开发工具时，有一个肯定是所有iOS开发者都熟悉的，那就是Xcode。Xcode是使所有令人赞叹的iOS app成为可能的驱动力。</p>
<p>Xcode<br>能帮助我们完成非常多的事情，但是这也有点让人头疼。对于新手来说，可能会觉得Xcode太过繁重了。而对那些有几年使用经验的人来说，还是在不停地学习<br>一些细节来提高生产力。我对新手的建议就是不要想着一下就能学完关于Xcode的所有知识。关注当下最重要的部分，然后再根据经验慢慢拓展到新的知识。</p>
<p>在本文中，我会提到一些能帮助你提高生产力的内容。这里面有些内容可能讲过就忘了，但有些应该能解决你经常遇到的问题。</p>
<ul>
<li>你将会学到如何自定义Xcode来提高生产力</li>
<li>你将会学到一些功能来帮助你管理代码</li>
<li>你将会学到一些提示来帮助你总体把控工程开发</li>
</ul>
<h3 id="Xcode_Behaviors">Xcode Behaviors</h3><p>Behaviors是一种神奇的东西，能让Xcode根据你的操作，自动执行一些后续操作。想象一下，你正在运行程序，遇到了一个断点或者错误。默认情况下，Xcode会自动打开调试窗口、在当前标签页跳转到出错的代码处，完全打乱了编辑器。现在我们通过设置来阻止这种情况发生。</p>
<p><img src="/images/1430192054157251.png" alt="1430192054157251.png"></p>
<p>打开Xcode 偏好设置，能看到一个叫Behaviors的选项卡。在这里我们可以定义不同种类的状态改变时Xcode的行为，例如当构建开始时Xcode要做什么、当构建成功或失败时Xcode又要做什么。你可以让Xcode播放声音、打开新的标签页、显示导航等等。</p>
<p>针对本例，我们想要改变app运行时的Xcode的一些行为。当app因为断点或错误暂停时，我们想要做以下的事情：</p>
<ul>
<li>播放声音（Hero音效对我来说不错，但是你可以换成其他的，包括自定义声音）</li>
<li>显示debug标签页</li>
<li>显示debug导航</li>
<li>调试区域同时显示变量和控制台</li>
</ul>
<p><img src="/images/1430192094727065.png" alt="1430192094727065.png"></p>
<p>在这里我选择打开一个新的标签页，是因为不想让Xcode改变我当前的工作状态。这样我就能轻松回到之前写代码的位置。另外我也没有关闭Xcode为调试打开的一些窗格，整个的体验是集中在单独的标签页中。</p>
<p>你可以花些时间来探索Xcode其他的行为，根据自己的开发风格找到最合适的。你可能觉得Xcode的某些默认行为很烦人，或许在Behaviors中你就能把它关掉。</p>
<h3 id="管理设备和模拟器">管理设备和模拟器</h3><p>你有没有想过，你其实可以管理Xcode中设备下拉框里的设备列表呢？<br><img src="/images/1430192160188997.jpg" alt="1430192160188997.jpg"></p>
<p>再想想读取设备中的数据库，从而验证表里的数据是否都设置正确了。你是否还遇到过，Xcode的下拉框里一个模拟器都没有了？现在打开Window &gt; Devices。</p>
<p><img src="/images/1430192168486298.png" alt="1430192168486298.png"></p>
<p>在这里你能看到已连接的设备和可用的模拟器。如果你需要添加或移除模拟器，就点击左下角的+按钮（移除点击—按钮）。如果模拟器都找不到了，你可以到这来恢复它们。</p>
<p><img src="/images/1430192199681247.jpg" alt="1430192199681247.jpg"></p>
<p>最后，这里另一个有用的功能就是可以下载app的 container。</p>
<p><img src="/images/1430192296134696.jpg" alt="1430192296134696.jpg"></p>
<p>过去你可能通过访问模拟器文件夹来获取数据，但是真机怎么办呢？现在获取保存的照片、数据库文件等等都变得非常容易了，你可以下载一个包含有documents、libarary和temp文件夹的container，这样就能获取设备上的数据了。</p>
<h3 id="更新app的显示名称">更新app的显示名称</h3><p>开发者们经常遇到的一个就是，创建的工程显示的名字不是自己想要的。我经常看到有些人重新命名和重构（refactor）整个工程，来显示正确的名称。如果你知道在工程的<code>info.plist</code>里添加一个key就能改变app显示名称了，那你肯定很高兴。这个key就是Bundle display<br>name。<br><img src="/images/1430192522399034.jpg" alt="1430192522399034.jpg"></p>
<h3 id="提高可读性_&amp;_Xcode扩展">提高可读性 &amp; Xcode扩展</h3><p>现在有很多插件都可以提高Xcode的生产力。一些开发者甚至创建了一些非常好的主题来替换Xcode默认主题。说实话，默认主题看起来还是挺不舒服的。那我们怎么样才能轻松地获取到这些插件呢？现在就去alcatraz.io，下载一个非常好用的Xcode包管理器吧。</p>
<p><img src="/images/1430192537680935.png" alt="1430192537680935.png"></p>
<p>下面是一些我最近用到的插件：</p>
<ul>
<li>SCXcodeMinimap：这个插件和Sublime Text中的那个看起来像。它能够显示一个编辑器的缩略图，轻松地查看、滚动代码。</li>
<li>RevealPlugin：如果你使用Reveal的话，这个插件能快速启动Reveal。</li>
<li>RealmPlugin：Realm的模型对象的模板文件。（译注：Realm是一个面向移动设备的数据库。）</li>
<li>VVDocumenter-Xcode：帮助你快速生成一个方法的注释。</li>
<li>AdjustFontSize：当你展示代码时，你可能需要快速放大字体，这个插件能让你通过command+加减号来调整字体大小。</li>
<li>Lin：为NSLocalizedString显示代码补全。</li>
</ul>
<p>有一个正在开发的本地化插件Rephrase，值得关注。当它发布之后，就有可能成为另一个节约时间的利器啊。</p>
<p>我目前使用的主题是Dusk，我坚信这个才是默认主题。还有很多颜色主题，你都可以通过Alcatraz来下载。</p>
<h3 id="下载文档和旧版模拟器">下载文档和旧版模拟器</h3><p>当你安装了一个新版本的Xcode后，你可能会发现你没有之前iOS系统的模拟器了。当测试app时这就是个问题了。你可以在偏好设置中的下载选项卡中安装旧版模拟器。</p>
<p>你可以在这下载旧版模拟器，在Window &gt; Devices中管理它们。你还可以下载Xcode没有预载的文档。<br><img src="/images/1430192594304148.png" alt="1430192594304148.png"></p>
<h3 id="组织源文件">组织源文件</h3><p>通过源文件上方的一个下拉框，你能查看到所有的属性和方法。<br><img src="/images/1430192618307958.jpg" alt="1430192618307958.jpg"><br>当你点击这个位置时，下拉框会显示这个文件的详细信息。在源代码中你还可以使用例如// FIXME: 或者 // TODO: 或者 // MARK: 来添加标记。<br><img src="/images/1430192640707944.jpg" alt="1430192640707944.jpg"></p>
<h3 id="快速打开文件">快速打开文件</h3><p>有时你可能需要打开一个新文件，但同时还要保留当前文件。有下面几种办法。</p>
<p>你可以打开assistant editor，然后在那里显示文件。点击View &gt; Assistant Editor &gt; Show Assistant Editor。</p>
<p>你可以双击想要打开的文件。这会打开一个新的窗口。</p>
<p>你可以通过 Option+Shift+点击，这会弹出一个框，让你选择在哪里打开文件。</p>
<p><img src="/images/1430192667909313.jpg" alt="1430192667909313.jpg"></p>
<h3 id="跳转到文档">跳转到文档</h3><p>能快速跳转到文档将会节省很多时间。你可能正在写UITableViewDelegate，但是不记得所有相关方法。你可以通过在符号上Command+点击，快速跳转到文档。</p>
<h3 id="生成文档">生成文档</h3><p>下载并安装插件VVDocumenter-Xcode，你就不用手动写注释代码了。只需输入三个斜杠///就能快速生成注释。</p>
<p><img src="/images/1430192726326115.gif" alt="1430192726326115.gif"></p>
<p>另一个好处就是在Xcode的文档预览中，这些注释也可以显示出来。在一个方法上Option+点击，就能预览文档。<br><img src="/images/1430192743746178.jpg" alt="1430192726326115.gif"></p>
<h3 id="创建代码片段">创建代码片段</h3><p>如果你经常需要输入格式完全一样的代码，那代码片段就很有用了。例如，我有一个代码片段，它能自动填充一个新的tableView或者<br>collectionView类，并且还有我需要的delegate方法。我还有一些小型片段来帮助我快速生成typealias、singleton、<br>gcd等等的代码。</p>
<p>要生成代码片段，在file inspector中打开snippent panel。<br><img src="/images/1430192768559247.jpg" alt="1430192768559247.jpg"></p>
<p>在编辑器中输入想要创建的片段。注意，如果需要占位符的话，输入 &lt;#placeholder-name#&gt;。选中代码，按住一秒，然后拖进代码片段区域。</p>
<p><img src="/images/1430192784492226.jpg" alt="1430192784492226.jpg"></p>
<p>然后你可以编辑片段来添加更多细节。最重要的一点就是“完成快捷键”。在编辑器中输入该关键字，就能选择片段了。或者你可以把代码片段从该区域拖到编辑器中。</p>
<p>过两天我会收集整理我所有的片段并分享出来。</p>
<h3 id="用Chisel改进调试">用Chisel改进调试</h3><p>Facebook开发了一套LLDB命令来让调试更容易一些。如果你还没有Chisel的话，现在就去Github安装。为了让你能明白Chisel到底是干嘛的，下面我列出了一些我喜欢的命令。这些命令省了我不少时间和脑子去记住那些语法。</p>
<ul>
<li>pviews：递归打印key window上的view。</li>
<li>visualize：在Mac上的预览应用中打开UIImage、CGImageRef、UIView和CALayer。</li>
<li>show/hide:显示或隐藏指定的view或者layer。</li>
<li>border/unborder：显示或隐藏view/layer的边框，从而找到它在哪。</li>
</ul>
<p>Chisel还有很多命令，在lldb中输入help来查看内建和用户定义的命令。</p>
<h3 id="版本编辑器">版本编辑器</h3><p>如果你需要查看一下修改了文件中的那些内容，你可以利用Xcode内建的版本编辑器，而不是复杂的Git。<br><img src="/images/1430192852614373.jpg" alt="1430192852614373.jpg"></p>
<p>你可以通过点击右上角的双箭头按钮来快速打开版本编辑器，或者通过View &gt; Version Editor &gt; Show Version Editor来打开。想象一下，有很多不需要提交的测试代码，在版本编辑器中都会显示出来，并且能让你快速放弃这些修改。你完全可以用source control的界面来干这个，但用版本编辑器是最简单的了。</p>
<h3 id="6个值得记住与设置的快捷键">6个值得记住与设置的快捷键</h3><p>有些快捷键默认没有设置，我建议你打开Preferences &gt; Key Bindings ，根据需要自行修改。</p>
<ul>
<li>Command + / ：注释/取消注释代码</li>
<li>Command + [ 或者 ] ：向前或向后缩进代码</li>
<li>Command + 左右方向键：移动光标到行首或行尾</li>
<li>Control + s ：选择单词（译注：默认没有设置。Key Bindings 对应的key是 Select Word）</li>
<li>Option + Command + e：（根据当前范围遍及选中的单词）（译注：默认没有设置，也不知道到底是个什么效果。）</li>
<li>Option + 左右方向键：按单词移动光标</li>
<li>esc：显示/隐藏自动补全弹出框。</li>
</ul>
<p>还有很多很多快捷键，找到适合你的风格的，活学活用。</p>
<h3 id="要点">要点</h3><p>在这篇文章中我们提到了关于你最常用到的工具——Xcode的一些内容。我展示的大部分内容都是为了提高我的生产力。我并不是想要追求单纯的快（你不会看见<br>我只用一个键盘），而是把自己从那些反复出现的问题中解放出来。当你有更多的经验时，你就能找到最适合你的方式。这才是关键。看看怎么样能把你在这篇文章<br>中学到的内容应用起来吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xcode/">Xcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS开发最佳实践总结-下" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/06/iOS开发最佳实践总结-下/" class="article-date">
  	<time datetime="2015-09-05T22:52:39.000Z" itemprop="datePublished">2015-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/06/iOS开发最佳实践总结-下/">iOS开发最佳实践总结(下)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/futurice/ios-good-practices" target="_blank" rel="external">点这里查看英文版</a><br>接上篇</p>
<h4 id="网络请求">网络请求</h4><p><strong>传统方法：使用自定义回调 block</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GigStore.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^FetchGigsBlock)(<span class="built_in">NSArray</span> *gigs, <span class="built_in">NSError</span> *error);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fetchGigsForArtist:(Artist *)artist completion:(FetchGigsBlock)completion</span><br><span class="line"></span><br><span class="line"><span class="comment">// GigsViewController.m</span></span><br><span class="line"></span><br><span class="line">[[GigStore sharedStore] fetchGigsForArtist:artist completion:^(<span class="built_in">NSArray</span> *gigs, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// Do something with gigs</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// :(</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>这样虽可行，但是如果要发起几个链式请求，很容易导致回调深渊。</p>
<p><strong>Reactive 的方法：使用 RAC signal</strong><br>如果你身陷回调深渊，可以看看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa (RAC)</a>。这是一个多功能、多用途的库，它可以改变<a href="https://github.com/jspahrsummers/GroceryList" target="_blank" rel="external">整个 app</a>  的写法。但你也可以仅在适合用它的时候，零散地用一用。</p>
<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank" rel="external">Teehan+Lax</a>以及<a href="http://nshipster.com/reactivecocoa/" target="_blank" rel="external">NSHipster</a>很好地介绍了 RAC 概念（以及整个 FRP 的概念）。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GigStore.h</span></span><br><span class="line"></span><br><span class="line">- <span class="params">(RACSignal *)</span>gigsForArtist:<span class="params">(Artist *)</span>artist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GigsViewController.m</span></span><br><span class="line"></span><br><span class="line">[[GigStore sharedStore] gigsForArtist:artist]</span><br><span class="line">    subscribeNext:^<span class="params">(NSArray *gigs)</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with gigs</span></span><br><span class="line">    &#125; error:^<span class="params">(NSError *error)</span> &#123;</span><br><span class="line">        <span class="comment">// :(</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>在这里我们可以把 gig 信号与其他信号结合，因此可以在展示 gig 之前做一些修改、过滤等处理。</p>
<h4 id="Assets">Assets</h4><p>使用 <a href="https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/Recipe.html" target="_blank" rel="external">Asset catalogs</a> 是管理工程中视觉素材的最好方法。这里既可以添加 iPhone 和 iPad 共用的素材，也可以添加针对特定设备（4寸屏 iPhone，iPhone Retina，iPad 等等）的素材，并且会根据名称来自动提供恰当的素材。教会你的设计师（们）怎么在这里添加并 commit 素材，可以帮你节省许多时间，再也不用把素材从邮件或者别的什么渠道导进代码库里了。同时，这样做也可以让他们即刻看到自己的改动，可以根据需要进行迭代。</p>
<p><strong>使用位图</strong><br>Asset catalog 只会暴露出一套图片的名字，省略了每张图片实际的文件名。这样，类似button_large@2x.png这类文件的命名空间仅限于 asset 内部，很好地避免了 asset 的命名冲突。然而，命名 asset 时遵循一些原则可以让生活更轻松：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IconCheckmarkHighlighted<span class="class">.png</span> <span class="comment">// Universal, non-Retina</span></span><br><span class="line">IconCheckmarkHighlighted@<span class="number">2</span>x<span class="class">.png</span> <span class="comment">// Universal, Retina</span></span><br><span class="line">IconCheckmarkHighlighted~iphone<span class="class">.png</span> <span class="comment">// iPhone, non-Retina</span></span><br><span class="line">IconCheckmarkHighlighted@<span class="number">2</span>x~iphone<span class="class">.png</span> <span class="comment">// iPhone, Retina</span></span><br><span class="line">IconCheckmarkHighlighted-<span class="number">568</span>h@<span class="number">2</span>x~iphone<span class="class">.png</span> <span class="comment">// iPhone, Retina, 4-inch</span></span><br><span class="line">IconCheckmarkHighlighted~ipad<span class="class">.png</span> <span class="comment">// iPad, non-Retina</span></span><br><span class="line">IconCheckmarkHighlighted@<span class="number">2</span>x~ipad<span class="class">.png</span> <span class="comment">// iPad, Retina</span></span><br></pre></td></tr></table></figure></p>
<p>其中的<code>-568h</code>、<code>@2x</code>、<code>~iphone</code>以及<code>~ipad</code>这些标示符本身不是必需的，但是如果在文件名里加上它们，把文件拖动到 asset 时就能自动落到正确的“格子”上，因此能避免难以察觉的错误拖放。</p>
<p><strong>使用矢量图</strong><br>你可以把设计师设计的原始的<a href="http://martiancraft.com/blog/2014/09/vector-images-xcode6/" target="_blank" rel="external">矢量图 (PDFs)</a>放进 asset catalog，让 Xcode 来自动生成位图。这样能减少工程的复杂度（减少文件个数）。</p>
<h4 id="编码风格">编码风格</h4><p><strong>命名</strong></p>
<p>Apple 非常注意在 API 中保持命名一致性，有时候有点过于冗长了。做 Cocoa 开发时要遵循<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Apple的命名规范</a>，这样能让加入项目的新人轻松许多。</p>
<p>以下是几条看了就能用上的基本规则：</p>
<p>以 <em>动词</em> 开头的方法表示它执行的操作会造成一些影响，但是不返回任何值。</p>
<p><code>- (void)loadView; - (void)startAnimating;</code></p>
<p>相反的是，以 <em>名词</em> 开头的方法返回一个对象，但不会造成额外的影响。</p>
<p><code>- (UINavigationItem *)navigationItem; + (UILabel *)labelWithText:(NSString *)text;</code></p>
<p>尽可能地区分这两种方法会有很多好处，也就是说，如果一个方法是处理数据的，就不要让它造成额外的影响，反过来也一样。这样可以让造成影响的代码块保持紧凑，因此可以帮助理解代码，并且有利于 debug。</p>
<p><strong>代码结构</strong></p>
<p><a href="http://nshipster.com/pragma/" target="_blank" rel="external">Pragma marks</a>是给方法分组很好的方法，特别是在 view controller 中。下面是一个在 view controller 中常见的结构：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"SomeModel.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SomeView.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SomeController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SomeStore.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SomeHelper.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;SomeExternalLibrary/SomeExternalLibraryHeader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> XYZFooStringConstant = <span class="string">@"FoobarConstant"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> XYZFooFloatConstant = <span class="number">1234.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XYZFooViewController</span> () &lt;<span class="title">XYZBarDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) Foo *foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XYZFooViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Lifecycle</span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFoo:(Foo *)foo;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - View Lifecycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Layout</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)makeViewConstraints;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Public Interface</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startFooing;</span><br><span class="line">- (<span class="keyword">void</span>)stopFooing;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - User Interaction</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foobarButtonTapped;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - XYZFoobarDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foobar:(Foobar *)foobar didSomethingWithFoo:(Foo *)foo;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Internal Helpers</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)displayNameForFoo:(Foo *)foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>最重要的是要让这些分块标记在工程里所有的类里保持一致。</p>
</blockquote>
<h4 id="External_Style_Guides">External Style Guides</h4><p><strong>其他风格指南</strong></p>
<p>Futurice（作者所在的公司）并没有公司范围的编码风格指南。不过，仔细研究一下其他开发社区的 Objective-C 风格指南会非常有用，尽管有些部分可能是只对特定公司有效或者比较主观的。</p>
<ul>
<li><a href="https://github.com/github/objective-c-style-guide" target="_blank" rel="external">GitHub</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml" target="_blank" rel="external">Google</a></li>
<li><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">The New York Times</a></li>
<li><a href="https://github.com/raywenderlich/objective-c-style-guide" target="_blank" rel="external">Ray Wenderlich</a></li>
<li><a href="https://gist.github.com/soffes/812796" target="_blank" rel="external">Sam Soffes</a></li>
<li><a href="http://lukeredpath.co.uk/blog/2011/06/28/my-objective-c-style-guide/" target="_blank" rel="external">Luke Redpath</a></li>
</ul>
<h4 id="诊断">诊断</h4><p><strong>编译警告</strong></p>
<p>建议你尽量把编译警告都打开，并且像对待 <em>error</em> 一样对待 <em>warning</em>。<a href="https://speakerdeck.com/hasseg/the-compiler-is-your-friend" target="_blank" rel="external">这份幻灯片</a>论证了这一点。幻灯片里同时还讲了如何在特定文件里或者特定的代码段里忽略特定的 <em>warning</em>。</p>
<p>一句话，在 build setting 的 “Other Warning Flags” 里至少要加入以下两个值：</p>
<ul>
<li><code>-Wall</code> （开启非常多额外的 warning）</li>
<li><code>-Wextra</code> （开启许多额外的 warning）<br>同时打开 build setting 里的 “Treat warnings as errors” 。</li>
</ul>
<p><strong>Clang 静态分析器</strong></p>
<p>Clang 编译器（也就是 XCode 使用的编译器）有一个 静态分析器(static analyer) ，用来执行代码控制流和数据流的分析，可以发现许多编译器检查不出的问题。</p>
<p>你可以在 Xcode 的 Product → Analyze 里手动运行分析器。</p>
<p>分析器可以运行“shallow”和“deep”两种模式。后者要慢得多，但是有跨方法的控制流分析以及数据流分析，因此能发现更多问题。</p>
<p>建议：</p>
<p>开启分析器的 全部 检查（方法是在 build setting 的“Static Analyzer”部分开启所有选项）</p>
<p>在 build setting 里，对 release 的 build 配置开启 “Analyze during ‘Build’” 。（真的，一定要这样做——你不会记得手动跑分析器的。）</p>
<p>把 build setting 里的 “Mode of Analysis for ‘Analyze’” 设为 Shallow (faster)</p>
<p>把 build setting 里的 “Mode of Analysis for ‘Build’” 设为 Deep</p>
<h5 id="Faux_Pas"><a href="http://fauxpasapp.com/" target="_blank" rel="external">Faux Pas</a></h5><p>由我们的员工 <a href="https://twitter.com/AliRantakari" target="_blank" rel="external">Ali Rantakari</a> 创作的 Faux Pas 是一个出色的静态 error 检测工具。它能分析你的代码库，找出你全然不知的错误。在发布任何 iOS（或 Mac）app 之前务必要运行它一次！</p>
<p>(Note: all Futurice employees get a free license to this — just ask Ali.)</p>
<p>(注意：所有 Futurice 的员工都能得到一份免费的许可——只要问 Ali 要就行了。)</p>
<p><strong>Debugging</strong></p>
<p>当 app crash 的时候，默认情况下 Xcode 并不会进入 debugger。要想进入 debugger，添加一个 Exception Breakpoint（点击 Xcode 的 Debug Navigator 底部的“+”号），遇到 exception 的时候就会暂停执行。在大部分情况下，你都能看到导致 exception 的那行代码。这种方法会捕捉到任何 exception，包括已经做了处理的 exception。如果 Xcode 常常会停在正常的 exception（比如第三方库里的）上，选择 Edit Breakpoint 然后在 Exception 下拉框选择 Objective-C 可以减轻这种情况。</p>
<p>在 view 的 debug 方面，<a href="http://revealapp.com/" target="_blank" rel="external">Reveal</a> 和 <a href="http://sparkinspector.com" target="_blank" rel="external">Spark Inspector </a>是两个强大的可视化检查器，可以节约你大量的时间，尤其是用 Auto Layout 时想知道消失的视图去哪儿了的情况。<a href="https://developer.apple.com/library/ios/recipes/xcode_help-debugger/using_view_debugger/using_view_debugger.html" target="_blank" rel="external">Xcode 也免费提供了一个类似的东西</a>，不过只支持 iOS 8+，并且略有些不够完善。</p>
<p><strong>评估</strong></p>
<p>Xcode 自带一套评估工具，叫做 Instruments。它包含众多的评估内存使用、CPU、网络连接、图像等方面的工具。它本身是个庞然大物，但一个比较简单直接的用途是用 Allocations instrument 来检测内存泄露。只需在 Xcode 中选择 Product &gt; Profile ，选择 Allocations instrument，点击 Record 按钮，然后从 Allocation Summary 中过滤出一些有用的字符串，比如 app 里你自己写的类的类名前缀。在 Persistant 一栏中的计数显示了每个对象有多少个实例。如果某个类的实例个数一直胡乱增长，就说明有内存泄露。</p>
<p>另外值得注意的是 Instrument 有一个 Automation 工具，用来把 UI 交互录制为 JavaScript 文件并且重放。<a href="https://github.com/jonathanpenn/ui-auto-monkey" target="_blank" rel="external">UI Auto Monkey</a> 是一个脚本，它借助 Automation 在你的 app 上随机点击、清扫、旋转，对压力测试/浸泡测试可能会有帮助。</p>
<p><strong>统计</strong></p>
<p>强烈推荐在你的 app 里加上一个统计框架，它能帮助你看到用户实际上是怎么用你的 app 的。X 功能有价值吗？按钮 Y 太难找到了吗？要回答这些问题，可以把点击事件、计时以及其他可测的信息发送到一个能收集并可视化这些信息的服务，比如<a href="http://www.google.com/tagmanager/" target="_blank" rel="external">Google Tag Manager</a>。Google Tag Manager 比 Google Analytics 更灵活一些，它在 app 和 Analytics 之间插了一个数据层，因此不须更新 app 就可以通过 web service 更改数据逻辑。</p>
<p>一种很好的做法是加一个轻量的辅助 class，比如 <code>XYZAnalyticsHelper</code>，用来把 app 内部的 model 和数据格式（XYZModel，NSTimeInterval 等）翻译成以字符串为主的数据层。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">pushAddItemEventWithItem:</span>(XYZItem *)item <span class="string">editMode:</span>(XYZEditMode)editMode</span><br><span class="line">&#123;</span><br><span class="line">    NSString *editModeString = [self <span class="string">nameForEditMode:</span>editMode];</span><br><span class="line"></span><br><span class="line">    [self <span class="string">pushToDataLayer:</span>@&#123;</span><br><span class="line">        @<span class="string">"event"</span>: <span class="string">"addItem"</span>,</span><br><span class="line">        @<span class="string">"itemIdentifier"</span>: item.identifier,</span><br><span class="line">        @<span class="string">"editMode"</span>: editModeString</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样有一个额外的好处，就是可以在需要时清除掉整个统计框架，而 app 其余的部分不会受任何影响。</p>
<h4 id="Crash_Logs">Crash Logs</h4><p><strong>崩溃日志</strong></p>
<p>首先应该让 app 把崩溃日志发送到某个服务器上，这样你才能看得到。可以自己实现这个功能（用PLCrashReporter结合自己的后台），但推荐使用已有的服务，比如下面这些：</p>
<ul>
<li><a href="http://www.crashlytics.com" target="_blank" rel="external">Crashlytics</a></li>
<li><a href="http://hockeyapp.net" target="_blank" rel="external">HockeyApp</a></li>
<li><a href="https://www.crittercism.com" target="_blank" rel="external">Crittercism</a></li>
<li><a href="https://mint.splunk.com" target="_blank" rel="external">Splunk MINTexpress</a></li>
</ul>
<p>设置好这些之后，要确保每次发布都要 保存 Xcode archive (<code>.xcarchive</code>) 。Archive 里包含编译出的二进制文件以及 debug symbol（<code>dSYM</code>），你需要这些数据来解析这个版本 app 的崩溃报告。</p>
<h4 id="编译构建">编译构建</h4><p><strong>编译配置</strong><br>即使最简单的 app 也有不同的构建方式。Xcode 提供的最基本的区别是 <code>debug</code> 和 <code>release</code> 模式。后者的编译时优化要强很多，代价是损失了 <code>debug</code> 的可能性。苹果建议你开发时使用 <code>debug</code> 模式，提交到 App Store 的包用 <code>release</code> 模式编译。默认的模式（在 Xcode 里的运行/停止按钮旁边的下拉菜单可以更改）就是这么设置的，Run 用 <code>debug</code> ，Archive 用 <code>release</code> 。</p>
<p>不过，对于真实的应用，这样还是过于简单了。你可以——不，是应该有几套不同的环境，分别用于测试、更新和其他与服务相关的操作。每套环境都可以有自己的 base URL，log 级别，bundle identifier（这样就可以同时安装），provision profile 等。因此，简单的 debug/release 不能满足要求。你可以在 Xcode 工程设置的“Info”一栏里添加更多的编译配置。</p>
<p><strong>编译配置的xcconfig文件</strong></p>
<p>编译配置一般是在 Xcode 的界面里设置的，不过你也可以使用 配置文件 （“<code>.xcconfig</code> 文件”）来设置。这样做的好处是：</p>
<ul>
<li><p>你可以添加注释来进行解释；</p>
</li>
<li><p>你可以 <code>#include</code> 其他编译配置文件，帮助避免重复：</p>
<ul>
<li><p>如果你有一些所有配置通用的设置，添加一个<code>Common.xcconfig</code>文件，然后把它 <code>#include</code> 到其他文件里；</p>
</li>
<li><p>比如说你想要加一个在“<code>Debug</code>”基础上开启编译优化的配置，只需 <code>#include &quot;MyApp_Debug.xcconfig&quot;</code>，然后覆盖相应的设置</p>
</li>
</ul>
</li>
<li><p>合并和解决冲突更简单一些。</p>
</li>
</ul>
<p>更多关于本话题的信息，可以参考<a href="https://speakerdeck.com/hasseg/xcode-configuration-files" target="_blank" rel="external">这些幻灯片</a>。</p>
<p><strong>Targets</strong></p>
<p>Target 的概念比 project 低一个级别，也就是说，一个 project 可以有数个 target，这些 target 的设置可以覆盖 project 的设置。粗略地说，每个 target 对应代码库里的“一个 app”。举个例子，你可能针对不同国家的 App Store 有不同的 app（都是从同一个代码库编译出来的）。每个 app 都需要开发/更新/release 的编译配置，因此用编译配置来处理会比 target 更好一些。一个 app 只有一个 target 完全不足为奇。</p>
<p><strong>Schemes</strong></p>
<p>Scheme 告诉 Xcode 在 <code>Run</code>、<code>Test</code>、<code>Profile</code>、<code>Analyze</code> 和 <code>Archive</code>时分别应该干什么。基本上，以上每个操作的 <code>scheme</code> 对应一个 <code>target</code> 和一套编译配置。你也可以传递启动参数，比如 app 运行的语言（对于测试本地化很方便！）或者设置一些 <code>debug</code> 用的诊断 <code>flag。</code></p>
<p>Scheme 的推荐命名方式是 <code>MyApp (&lt;Language&gt;) [Environment]</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MyApp</span> (English)<span class="sqbracket"> [Development]</span></span><br><span class="line"><span class="keyword">MyApp</span> (German)<span class="sqbracket"> [Development]</span></span><br><span class="line"><span class="keyword">MyApp</span><span class="sqbracket"> [Testing]</span></span><br><span class="line"><span class="keyword">MyApp</span><span class="sqbracket"> [Staging]</span></span><br><span class="line"><span class="keyword">MyApp</span><span class="sqbracket"> [App Store]</span></span><br></pre></td></tr></table></figure>
<p>对于大部分环境其中的语言是不需要的，因为 app 有可能通过 Xcode 之外的途径安装，比如 TestFlight，这样启动参数就会被忽略。这种情况下，只能手动设置设备语言来测试本地化。</p>
<h4 id="部署">部署</h4><p>把应用安装到 iOS 设备上可算不上简单直接。尽管如此，在这里会介绍几个核心概念；理解这些概念，会对你的部署有很大的帮助。</p>
<p><strong>签名</strong></p>
<p>只要你想把应用跑在真实的设备上（相对于模拟器而言），你就需要在编译时用一个苹果颁发的 <em>证书 来签名</em>。每个证书对应一对公钥/私钥，私钥保存在你的 Mac 的钥匙串中。证书有两种：</p>
<ul>
<li><strong>开发证书</strong>：<br>团队里的每个开发者都可以有自己的开发证书，是通过请求获得的。Xcode 可以自动完成这项工作，<em>不过最好还是不要点击那个神奇的“Fix issue”按钮</em>，而是自己做一遍来理解这个过程到底做了什么。</li>
</ul>
<blockquote>
<p>要把开发环境打的包安装到设备上就需要开发证书。</p>
</blockquote>
<ul>
<li><strong>分发证书</strong>： 可以有多个，不过最好还是限制为每个组织一个，然后通过内部渠道分享它相关联的密钥。</li>
</ul>
<blockquote>
<p>要发布到 App Store 或者企业的内部“app store”，就需要这个证书。</p>
</blockquote>
<p><strong>Provisioning</strong></p>
<p>除了证书之外，还有 <code>provisioning profiles</code> ，它就是<em>关联证书和设备的一环</em>。它同样有两种，分别用于开发和分发这两种不同目的：</p>
<ul>
<li><strong>Development provisioning profile</strong>: 它包括被授权安装、运行 app 的设备列表。同时它与一个或多个开发证书相关联，每个开发证书对应一个可以使用这个 profile 的开发者。</li>
</ul>
<blockquote>
<p>这种 profile 可以与特定 app 绑定，但是对于开发的用途，大部分用通配的 profile 即可，App ID 以星号（*）结尾。</p>
</blockquote>
<ul>
<li><p><strong>Distribution provisioning profile</strong>:<br>有 3 种分发的途径，每种都有一种不同的使用情景。每个 <code>distribution profile</code> 与一个分发证书相关联，证书过期即失效。</p>
<ul>
<li><p><strong>Ad-Hoc</strong>: 与开发证书相同，它包含可以安装 app 的设备白名单。这种 profile 可以用来在每年最多 100 个设备上做 beta 测试。想要更为顺畅的体验，增加至 1000 个不同的用户，你可以使用苹果新推出的<a href="https://developer.apple.com/testflight/" target="_blank" rel="external">TestFlight</a>服务。<a href="http://blog.supertop.co/post/108759935377/app-developer-friends-try-testflight" target="_blank" rel="external">Supertop 上对它的优势和问题有一个很好的总结</a>。</p>
</li>
<li><p><strong>App Store</strong>: 这种 <em>profile</em> 没有设备列表，因为任何人都可以通过苹果的官方分发渠道安装 app。发布到 App Store 会需要这种 <em>profile。</em></p>
</li>
<li><p><strong>Enterprise</strong>: 如同 App Store 类型一样，没有设备白名单，任何人都可以通过企业的内部“app store”来安装 app。</p>
</li>
</ul>
</li>
</ul>
<p>要把所有的证书和 <em>profile</em> 同步到你的机器上，到 Xcode 的 Preferences 里的 Accounts，在这里添加你的 Apple ID，然后双击 team 名称。底部有一个刷新按钮，但有时需要重启 Xcode 才能正常刷新。</p>
<p><strong>Debugging Provisioning</strong></p>
<p>有时候你需要 <code>debug</code> 一个 <code>provisioning</code> 问题。例如，Xcode 可能拒绝把包安装到设备上，因为设备不在（development 或 ad-hoc 的）<code>profile</code> 的设备列表上。在这种情况下，你可以使用 Craig Hockenberry 优秀的<a href="https://github.com/chockenberry/Provisioning" target="_blank" rel="external">Provisioning</a>插件，定位到<code>~/Library/MobileDevice/Provisioning Profiles</code>，选择<code>.mobileprovision</code>文件然后按空格键，启动 Finder 的快速搜索功能。它会展示出非常丰富的信息，包括设备、授权、证书 和 App ID 等。</p>
<p><strong>上传</strong></p>
<p><a href="https://itunesconnect.apple.com" target="_blank" rel="external">iTunes Connect</a> 是苹果 App Store 上 app 的管理平台。要上传一个包，Xcode 6 需要用一个开发者账号的 Apple ID 来签名。这里如果你有多个开发者账号，想要分别上传他们的 app，可能遇到一些麻烦，因为不知为何 <code>一个特定的 Apple ID 只能与一个 iTunes Connect 账号相关联</code> 。一个替代方法是，为每个 iTunes Connect 账号都创建一个新的 Apple ID，然后使用 Application Loader 代替 Xcode 来上传包。这样就把打包签名与上传 <code>.app</code>文件的过程解耦了。</p>
<p>上传包之后，保持耐心，可能一个小时后这个版本的 app 才会出现在 Builds 一栏。当它出现以后，你可以把它与 app 的版本信息链接起来，然后提交审核。</p>
<h4 id="App内购买（IAP）">App内购买（IAP）</h4><p>验证 app 内购买的收据时，请记得进行以下检查：</p>
<ul>
<li><strong>真伪性</strong>: 购买收据确实来自苹果；</li>
<li><strong>完整性</strong>: 收据没有被篡改；</li>
<li><strong>应用匹配</strong>: 收据里的 bundle ID 符合你的 app 的 bundle ID；</li>
<li><strong>产品匹配</strong>: 收据里的 product ID 符合你预期的 product ID；</li>
<li><strong>最新性</strong>: 你之前没有见过相同的收据 ID</li>
</ul>
<blockquote>
<p>设计你的 IAP 系统时，尽量把售卖的内容存储在 server 端，然后仅当收到有效的、通过以上所有检查的收据后，才把内容提供给 client 端。这样的设计阻碍了常规的盗版机制，并且——既然验证是在 server 端进行的——你可以利用苹果的 HTTP 收据验证服务，而不是自己解析收据的 PKCS #7 / ASN.1 格式。</p>
</blockquote>
<p>关于这个话题的更多信息，可以参考Futurice blog: <a href="http://futurice.com/blog/validating-in-app-purchases-in-your-ios-app" target="_blank" rel="external">在你的 iOS app 里验证 app 内购买</a>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS开发最佳实践总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/05/iOS开发最佳实践总结/" class="article-date">
  	<time datetime="2015-09-05T15:20:18.000Z" itemprop="datePublished">2015-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/05/iOS开发最佳实践总结/">iOS开发最佳实践总结(上)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/futurice/ios-good-practices" target="_blank" rel="external">点这里查看英文版</a></p>
<p>这份文档就像软件项目一样，如果我们不维护它就会逐渐腐坏。欢迎大家跟我们一起来维护它——只需提交 issue 或者发 pull request 即可！</p>
<p>对其他移动平台感兴趣？也许我们的<a href="https://github.com/futurice/android-best-practices" target="_blank" rel="external">《Android 开发最佳实践》</a>以及<a href="https://github.com/futurice/windows-app-development-best-practices" target="_blank" rel="external">《Windows App 开发 最佳实践》</a>能满足你。</p>
<h4 id="为什么要写这篇文档？">为什么要写这篇文档？</h4><p>iOS 开发在上手时可能会有些令人生畏。无论是 Objective-C 还是 Swift 在别处都没有广泛的应用，iOS 这个平台几乎对一切都有一套不同的叫法，而尝试把你的代码跑在真机上的过程难免磕磕碰碰。这份持续更新的文档就是来帮你的，无论你是 Cocoa 王国的新手，或是想知道“最佳做法”是什么，都可以一读。下文仅供参考，如果你有理由采取不同的做法，不用顾虑，只管做吧！</p>
<h4 id="上手">上手</h4><h4 id="Xcode">Xcode</h4><p><a href="https://developer.apple.com/xcode/" target="_blank" rel="external">Xcode</a> 是绝大部分 iOS 开发者选择的 IDE，也是唯一一个苹果官方支持的 IDE。也有一些其他选择，最著名的可能要数 <a href="https://www.jetbrains.com/objc/" target="_blank" rel="external">AppCode</a> 了。但除非你已经对 iOS 游刃有余，否则还是用 Xcode 吧。尽管 Xcode 有一些缺点，它现在还算是相当实用的！</p>
<p>要安装 Xcode，只需在 <a href="https://itunes.apple.com/us/app/xcode/id497799835" target="_blank" rel="external">Mac 的 App Score</a> 上下载即可。它自带最新版的 SDK 和 iOS 模拟器，其他版本可以在 Preferences &gt; Downloads 处安装。</p>
<h4 id="建立工程">建立工程</h4><p>开始一个新的 iOS 项目时，一个常见的问题是：用代码写界面还是用 Storyboard、xib 画界面。在现有的应用里，这两种做法都占有一席之地。你需要考虑以下几点：</p>
<h5 id="用代码写界面有哪些好处？">用代码写界面有哪些好处？</h5><ul>
<li>Storyboard 的 XML 结构很复杂，所以如果用 Storyboard ，合并代码时很容易冲突，比起用代码写的界面要麻烦许多。</li>
<li>It’s easier to structure and reuse views in code, thereby keeping your codebase DRY.</li>
<li>用代码写界面时，构建和重用 view 更加方便，因此能保持你的 codebase 遵循DRY 原则。</li>
<li>所有的信息都集中在一处。如果用 Interface Builder，你还得到处点开各种检查器，才能找到你要设置的属性。</li>
</ul>
<h5 id="用_Storyboard_画界面有哪些好处？">用 Storyboard 画界面有哪些好处？</h5><ul>
<li>对技术不太熟悉的人也可以画 Storyboard，调整颜色、layout 约束，为项目做出直接贡献。不过，要做这些需要工程已经建好，并且也要了解一些基本知识。</li>
<li>开发迭代会更快，因为不需要 build 工程就能预览到做出的改动。<ul>
<li>在 Xcode 6 中，在 Storyboard 里终于能看到自定义的字体和 UI 控件样式了。这让你在设计时能更好地了解界面的最终外观。</li>
<li>从 iOS 8 开始，你可以用<a href="http://blog.futurice.com/adaptive-view-ios8" target="_blank" rel="external">Size Classes</a>来设计同时支持各种屏幕尺寸的界面，省去了很多重复工作。</li>
</ul>
</li>
</ul>
<h5 id="gitignore_文件">gitignore 文件</h5><p>要为一个项目添加版本控制，最好第一步就弄一个恰当的.gitignore文件。这样一来，不需要的文件（例如用户设置、临时文件等等）就不会进入 repository 了。幸运的是，Github 帮我们同时准备好了 <a href="https://github.com/github/gitignore/blob/master/Objective-C.gitignore" target="_blank" rel="external">Objective-C 版</a>  和 <a href="https://github.com/github/gitignore/blob/master/Swift.gitignore" target="_blank" rel="external">Swift 版</a>。</p>
<h5 id="CocoaPods">CocoaPods</h5><p>如果你准备在工程里引入外部依赖（例如第三方库），CocoaPods提供了快速而便捷的集成方法。安装方法如下：<br><code>sudo gem install cocoapods</code><br>To get started, move inside your iOS project folder and run<br>开始的第一步是进入你的工程目录，然后运行<br><code>pod init</code><br>这样会创建一个 Podfile，在这里集中管理所有的依赖。把你的依赖添加到 Profile 里，然后运行<br><code>pod install</code></p>
<p>来安装这些库，并且把它们和你自己的工程一起放进一个 workspace 里。在 commit 的时候，一般推荐把依赖在你的 repo 里安装好之后再 commit，最好不要让每个开发者 checkout 之后还要自己跑一遍<code>pod install</code>.</p>
<p>要注意，从此以后，打开工程的时候就要打开<code>.xcworkspace</code>文件了，不要再打开<code>.xcproject</code>，否则代码编译不通过。下面这条命令<br><code>pod update</code><br>会把所有的 pod 都更新到 Podfile 允许的最新版本。你可以使用一系列的<a href="http://guides.cocoapods.org/syntax/podfile.html#pod" target="_blank" rel="external">符号</a>来准确指定你对版本的要求。</p>
<h4 id="工程结构">工程结构</h4><p>既然把这些数以百计的源文件都保存在同一目录下，根据工程结构来建立一个目录结构是个好主意。例如，你可以使用以下的结构：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ Models</span><br><span class="line">├─ Views</span><br><span class="line">├─ Controllers</span><br><span class="line">├─ Stores</span><br><span class="line">├─ Helpers</span><br></pre></td></tr></table></figure></p>
<p>首先，在 Xcode 的 Project Navigator（左边栏）里，把这些目录建立为 group（小小的黄色“文件夹”），建在与工程的同名的 group 下。然后，把每一个 group 与工程路径下实际的文件夹链接起来，方法是选中 group，打开右边栏的 File Inspector，点击小小的灰色文件夹 icon，然后在工程目录下创建一个新的子文件夹，名称与 group 相同。</p>
<h5 id="本地化">本地化</h5><p>从最开始就要把所有的文案放在本地化文件里。这不仅有利于翻译，也能让你更快地找到面向用户的文字。你可以在 build scheme 里添加一个 launch 参数，指定在某种语言下启动 app，例如：<br><code>-AppleLanguages (Finnish)</code><br>对于更复杂的翻译，比如与名词的数量有关的复数形式（如 “1 person” 对应 “3 people”），你应该使用.stringsdict 格式来替换普通的localizable.strings文件。只要你能习惯这种奇特的语法，你就拥有了一个强大的工具，可以根据需要（例如俄语或阿拉伯语的规则）把名词变为“一个”、“一些”、“少数”和“许多”等复数形式。</p>
<p>更多关于本地化的信息，请参考 2012 年 2 月 HelsinkiOS 大会上的这些幻灯片。其中的大部分演讲至少到 2014 年 10 月为止仍然是不过时的。</p>
<h5 id="常量">常量</h5><p>把整个 app 范围的常量定义在一个<code>Constants.h</code>文件里，然后在 prefix header 里加入这个文件。</p>
<p>相比使用 <code>#define</code> 定义的预处理宏，使用真正的常量更好：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> XYZBrandingFontSizeSmall = <span class="number">12.0</span>f;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> XYZAwesomenessDeliveredNotificationName = <span class="string">@"foo"</span>;</span><br></pre></td></tr></table></figure></p>
<p>真正的常量是类型安全的，拥有更明确的作用域，不能在后续的代码中重新定义也不能取消定义，并且在 debugger 中可用。</p>
<h5 id="分支策略">分支策略</h5><p>App 发布的时候把 release 代码从原有的分支上隔离出来，并且加上适当的 tag，是很好的做法，对于向公众分发（比如通过 App Store）的 app 这一点尤其重要。同时，涉及到大量 commit 的 feature 应该在独立的分支上完成。git-flow是一个帮助你遵守这些原则的工具。它只是在 Git 的分支和 tag 命令上简单加了一层包装，就可以帮助维护一套适当的分支结构，对于团队协作尤为有用。所有的开发都应该在 feature 对应的分支上完成（小改动在develop分支上），给 release 打上 app 版本的 tag，然后 commit 到 master 分支时只能用下面这条命令：<br><code>git flow release finish &lt;version&gt;</code></p>
<h4 id="Common_Libraries">Common Libraries</h4><h5 id="常用的库">常用的库</h5><p>一般来说，在工程里添加外部依赖要谨慎。当然，眼下某个第三方库能漂亮地解决你的问题，但或许不久之后就陷入了维护的泥淖，最后随着下一版 OS 的发布全线崩溃。另一种情况是，原先只能通过引用外部库来实现的 feature，突然官方 API 也支持了。在设计良好的项目里，把第三方库替换为官方的实现花不了多少功夫，但在将来会大有裨益。永远要优先考虑用苹果官方的框架（也是最好的框架）来解决问题！</p>
<p>因此，这一章有意写得比较简短。下面介绍的第三方库主要用来减少模板代码（例如 Auto Layout）或者用来解决复杂的、需要大量测试的问题，例如计算日期。随着你对 iOS 越来越精通，务必要四处看看它们的源码，熟悉它们所使用的底层框架。你会发现做好这些就能减轻许多重担了。</p>
<h5 id="AFNetworking">AFNetworking</h5><p>大约 99.95% 的 iOS 开发者都使用这个网络库。尽管NSURLSession已经非常强大了，但一旦涉及到实际管理请求队列时，AFNetworking仍然立于不败之地，而现代的 app 基本都会有这个需求。</p>
<h5 id="DateTools">DateTools</h5><p>一条常识是，不要自己写日期计算。幸运的是，有 DateTools 这样一个基于 MIT 协议、充分测试过的第三方库，基本能满足所有日期方面的要求。</p>
<h5 id="Auto_Layout_相关的库">Auto Layout 相关的库</h5><p>如果你习惯用代码写 view，你很可能用过这两种诡异的语法——常规的NSLayoutConstraint工厂，以及所谓的可视化语言。前者极其冗长，而后者是基于字符串的，完全躲过了编译检查。</p>
<p>而 Masonry 的解决方法是：引入自己定义的 DSL 来创建、更新和替换约束。Swift 有一个类似的库 Cartography，是建立在这门语言强大的运算符重载基础上的。保守一些的库有 FLKAutoLayout，它对原生 API 加了一层整洁而不奇异的包装。</p>
<h4 id="架构">架构</h4><ul>
<li><p><a href="http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store" target="_blank" rel="external">Model-View-Controller-Store (MVCS)</a></p>
<ul>
<li><p>这是苹果默认的架构(MVC)上增加了一个 Store 层，用来吐出 Model，处理网络请求、缓存等。</p>
</li>
<li><p>每个 Store 暴露给 view controller 的或者是RACSignal，或者是返回值为void、参数带有自定义的 completion block 的方法。</p>
</li>
</ul>
</li>
<li><p><a href="http://www.objc.io/issue-13/mvvm.html" target="_blank" rel="external">Model-View-ViewModel (MVVM)</a></p>
<ul>
<li><p>MVVM 是为了解决“巨大的 view controller”而生，它把UIViewController的子类看做 View 层的一部分，用 ViewModel 维护所有的状态来给 ViewController 瘦身。</p>
</li>
<li><p>对于 Cocoa 开发者是一个很新的概念，但是正在引起 越来越多的关注</p>
</li>
</ul>
</li>
<li><p><a href="http://www.objc.io/issue-13/viper.html" target="_blank" rel="external">View-Interactor-Presenter-Entity-Routing (VIPER)</a></p>
<ul>
<li>相当特别的架构，大型项目可能值得参考，尤其是即使用 <code>MVVM</code>还是比较凌乱，以及对需要重点考虑可测试性的情况。</li>
</ul>
</li>
</ul>
<h5 id="“通知”_模型">“通知” 模型</h5><p>以下是组件之间互发通知的一些常见手段：</p>
<ul>
<li><strong>Delegation</strong>: (一对一) 苹果官方经常用这个模式（有些人认为用得太泛滥了）。主要用于回传，比如从模态框回传数据。</li>
<li><strong>Callback blocks</strong>: (一对一) 耦合更松，同时能让相关联的代码在一起。并且，消息发出者数量很多时比 delegation 更方便。</li>
<li><strong>Notification Center</strong>: (一对多) 可能是一个对象给多个观察者发出“通知”时最常用的方法。耦合非常松，甚至可以把通知发到全局，不需要对调度者的引用。</li>
<li><strong>Key-Value Observing (KVO)</strong>: (一对多) 不需要被观测的对象主动“发出通知”，只需要被观测的键（属性）支持 Key-Value Coding (KVC) 。这种模式比较含混，而且标准 API 比较繁复，所以一般不推荐使用。</li>
<li><strong>Signals</strong>: (一对多) 这是<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>的核心，它允许结合关键内容的链式调用，用这种方法逃离回调深渊（嵌套过多的回调）。</li>
</ul>
<h5 id="Models">Models</h5><p>要确保你的 model 是不可变的，它们用来把远程 API 的语义和类型转换为 app 适用的语义和类型。Github 的 <a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a> 是个不错的选择。</p>
<h5 id="Views">Views</h5><p>使用 Auto Layout 布局时，要记得在 View 类里加上：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)requiresConstraintBasedLayout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不然，系统可能不会如期调用<code>-updateConstraints</code>，而导致奇怪的 bug。</p>
<p>Controllers</p>
<p>要使用依赖注入，也就是说，应该把 Controller 需要的数据用参数传进来，而不要把所有状态信息都保存在单例里。后者仅当这些状态 的确 是全局的情况下才适用。</p>
<p><code>+ [[FooDetailsViewController alloc] initWithFoo:(Foo *)foo];</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Swift学习-从Objective-C到Swift" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/04/Swift学习-从Objective-C到Swift/" class="article-date">
  	<time datetime="2015-09-04T12:54:50.000Z" itemprop="datePublished">2015-09-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/04/Swift学习-从Objective-C到Swift/">Swift学习: 从Objective-C到Swift</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Swift学习:_从Objective-C到Swift">Swift学习: 从Objective-C到Swift</h3><p>这篇文章是自己学习Swift的笔记与深化。希望这篇文章能够帮助已经有Objective-C经验的开发者更快地学习Swift。同时也品味到Swift的精妙之处。</p>
<p>结论放在开头:</p>
<p>我认为Swift比Objective-C更优雅,更安全同时也更现代,更性感。</p>
<p>文章组织脉络：</p>
<ol>
<li>从Objective-C到Swift的语法差异。我们熟悉的Objective-C特性在Swift中如何展现。</li>
<li>从Objective-C到Swift的进步改进。研究对比Swift在安全性,易用性上的提升,给我们带来的新编程范式。</li>
</ol>
<h4 id="1-属性(property)和实例变量(instance_variable)">1.属性(property)和实例变量(instance variable)</h4><h4 id="Objective-C_property_in_Swift_world">Objective-C property in Swift world</h4><p>在Cocoa世界开发的过程中,我们最常打交道的是property.<br>典型的声明为:<br><code>@property (strong,nonatomic) NSString *string;</code></p>
<p>而在Swift当中,摆脱了C的包袱后,变得更为精炼,我们只需直接在类中声明即可<br><code>class Shape {    var name = &quot;shape&quot;}</code><br>注意到这里,我们不再需要<code>@property</code>指令,而在Objective-C中,我们可以指定property的attribute,例如strong,weak,readonly等。<br>而在Swift的世界中,我们通过其他方式来声明这些property的性质。</p>
<p>需要注意的几点:</p>
<ul>
<li><code>strong</code>: 在Swift中是默认的</li>
<li><code>weak</code>: 通过weak关键词申明<br><code>weak var delegate: UITextFieldDelegate?</code></li>
<li><code>readonly</code>,<code>readwrie</code>  直接通过声明变量<code>var</code>,声明常量<code>let</code>的方式来指明</li>
<li><code>copy</code> 通过<code>@NSCopying</code>指令声明。</li>
</ul>
<h3 id="值得注意的是String,Array和Dictionary在Swift是以值类型(value_type)而不是引用类型(reference_type)出现,因此它们在赋值,初始化,参数传递中都是以拷贝的方式进行（简单来说,String,Array,Dictionary在Swift中是通过struct实现的）">值得注意的是String,Array和Dictionary在Swift是以值类型(value type)而不是引用类型(reference type)出现,因此它们在赋值,初始化,参数传递中都是以拷贝的方式进行（简单来说,String,Array,Dictionary在Swift中是通过struct实现的）</h3><blockquote>
<p>延伸阅读：Value and Reference Types</p>
</blockquote>
<ul>
<li><code>nonatomic</code>,<code>atomic</code> 所有的Swift properties 都是nonatomic。但是我们在线程安全上已经有许多机制,例如NSLock,GCD相关API等。个人推测原因是苹果想把这一个本来就用的很少的特性去掉,线程安全方面交给平时我们用的更多的机制去处理。</li>
</ul>
<p>然后值得注意的是,在Objective-C中,我们可以跨过property直接与instance variable打交道,而在Swift是不可以的。</p>
<p>例如：我们可以不需要将someString声明为property,直接使用即可。即使我们将otherString声明为property,我们也可以直接用_otherString来使用property背后的实例变量。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSString</span> *someString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* otherString;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,我们不能直接与instance variable打交道。也就是我们声明的方式简化为简单的一种,简单来说在Swift中,我们只与property打交道。</p>
<blockquote>
<p>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly</p>
</blockquote>
<h4 id="小结">小结</h4><ul>
<li><p>因此之前使用OC导致的像巧哥指出的开发争议就不再需要争执了,在Swift的世界里,我们只与property打交道。</p>
</li>
<li><p>并且我们在OC中<code>init</code>和<code>dealloc</code>不能使用属性<code>self.property = XXX</code>来进行设置的情况得以解决和统一。</p>
</li>
</ul>
<p>(不知道这一条规定,在init直接用self.property = value 的同学请自觉阅读iOS夯实：内存管理)</p>
<p>：）</p>
<p>个人觉得这看似小小一点变动使Swift开发变得更加安全以及在代码的风格更为统一与稳定。</p>
<h4 id="Swift_property延伸：">Swift property延伸：</h4><ul>
<li><code>Stored Properties</code>和<code>Computed properties</code></li>
</ul>
<p>在Swift中,property被分为两类：<code>Stored Properties</code>和<code>Computed properties</code><br>简单来说,就是stored properties 能够保存值,而conmuted properties只提供getter与setter,利用stored properties来生成自己的值。个人感觉Computed properties更像方法,而不是传统意义的属性。但是这样一个特性存在,使得我们更容易组织我们的代码。</p>
<blockquote>
<p>延伸阅读：computed property vs function</p>
</blockquote>
<ul>
<li><code>Type Properties</code></li>
</ul>
<p>Swift提供了语言级别定义类变量的方法。</p>
<blockquote>
<p>In C and Objective-C, you define static constants and variables associated with a type as global static variables.In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</p>
</blockquote>
<p>在Objective-C中,我们只能通过单例,或者static变量加类方法来自己构造类变量：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span></span></span><br><span class="line">+ (<span class="keyword">int</span>) value;</span><br><span class="line">+ (<span class="keyword">void</span>) setValue:(<span class="keyword">int</span>)val;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Model</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">+ (<span class="keyword">int</span>) value</span><br><span class="line">&#123; <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; <span class="keyword">return</span> value; &#125; &#125;</span><br><span class="line">+ (<span class="keyword">void</span>) setValue:(<span class="keyword">int</span>)val</span><br><span class="line">&#123; <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; value = val; &#125; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSDictionary</span>*) dictionary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo.m</span></span><br><span class="line">+(<span class="built_in">NSDictionary</span>*) dictionary</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">NSDictionary</span>* fooDict = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        <span class="comment">// create dict</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fooDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在Swift中我们通过清晰的语法便能定义类变量：</p>
<p>通过static定义的类变量无法在子类重写,通过class定义的类变量则可在子类重写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;    </span><br><span class="line">    static <span class="variable"><span class="keyword">var</span> storedTypeProperty</span> = <span class="string">"Some value."</span></span><br><span class="line">    static <span class="variable"><span class="keyword">var</span> computedTypeProperty</span>: <span class="typename">Int</span> &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="typename">Int &#123;  </span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时利用类变量我们也有了更优雅的单例模式实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">singletonClass</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = singletonClass()</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 这就阻止其他对象使用这个类的默认的'()'初始化方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift单例模式探索：The Right Way to Write a Singleton</p>
<ul>
<li>延伸：<br>目前Swift支持的type propertis中的Stored Properties类型不是传统意义上的类变量(class variable)，暂时不能通过class 关键词定义,通过static定义的类变量类似java中的类变量,是无法被继承的,父类与子类的类变量指向的都是同一个静态变量。</li>
</ul>
<blockquote>
<p>延伸阅读： Class variables not yet supported</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">storedTypeProperty</span> </span>= <span class="string">"Some value."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2.0 </span></span><br><span class="line"><span class="built_in">Error</span>: Class stored properties not yet supported <span class="keyword">in</span> classes</span><br></pre></td></tr></table></figure>
<p>通过编译器抛出的错误信息,相信在未来的版本中会完善Type properties。</p>
<h4 id="2-控制流">2.控制流</h4><p>Swift与Objective-C在控制流的语法上关键词基本是一致的,但是扩展性和安全性得到了很大的提升。</p>
<p>主要有三种类型的语句</p>
<ol>
<li>if,switch和新增的guard</li>
<li>for,while</li>
<li>break,continue<br>主要差异有：</li>
</ol>
<h4 id="关于if">关于if</h4><h5 id="语句里的条件不再需要使用()包裹了。">语句里的条件不再需要使用()包裹了。</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">number</span> = <span class="number">23</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">number</span> &lt; <span class="number">10</span> &#123;  </span><br><span class="line">  print(<span class="string">"The number is small"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是后面判断执行的的代码必须使用{}包裹住。<br>为什么呢,在C,C++等语言中,如果后面执行的语句只有语句,我们可以写成:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = <span class="number">23</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">number</span> &lt; <span class="number">10</span>)</span><br><span class="line">   NSLog(<span class="string">"The number is small"</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是如果有时要在后面添加新的语句,忘记添加{},灾难就很可能发送。</p>
<p>：） 像苹果公司自己就犯过这样的错误。下面这段代码就是著名的goto fail错误,导致了严重的安全性问题。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = SSLHashSHA1<span class="built_in">.</span>update(<span class="subst">&amp;</span>hashCtx, <span class="subst">&amp;</span>signedParams)) != <span class="number">0</span>)    goto fail;    goto fail;  <span class="comment">// :)注意 这不是Python的缩减</span></span><br><span class="line"><span class="attribute">...</span> other checks <span class="attribute">...</span></span><br><span class="line">fail:</span><br><span class="line">  <span class="attribute">...</span> buffer frees (cleanups) <span class="attribute">...</span>    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure></p>
<p>：）<br>最终在Swift,苹果终于在根源上消除了可能导致这种错误的可能性。</p>
<h5 id="if_后面的条件必须为Boolean表达式">if 后面的条件必须为Boolean表达式</h5><p>也就是不会隐式地与0进行比较,<code>下面这种写法是错误的</code>,因为number并不是一个boolean表达式,number != 0才是。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">number</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关于for">关于for</h4><p>for循环在Swift中变得更方便,更强大。</p>
<p>得益于Swift新添加的范围操作符<code>...</code>与 <code>...&lt;</code><br>我们能够将之前繁琐的for循环：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt;= 5; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>, i)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改写为：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="built_in">index</span> <span class="type">in</span> <span class="number">1.</span>.<span class="number">.5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">index</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然,熟悉Python的亲们知道Python的range函数很方便,我们还能自由选择步长。<br>像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(<span class="number">1</span>,<span class="number">5</span>) <span class="preprocessor">#代表从<span class="number">1</span>到<span class="number">5</span>(不包含<span class="number">5</span>)[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;&gt;&gt; range(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>) #代表从<span class="number">1</span>到<span class="number">5</span>，间隔<span class="number">2</span>(不包含<span class="number">5</span>)[<span class="number">1</span>, <span class="number">3</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>虽然在《The Swift Programming Language》里面没有提到类似的用法,但是在Swift中我们也有优雅的方法办到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> index in <span class="title">stride</span><span class="params">(from: <span class="number">1</span>, through: <span class="number">5</span>, by: <span class="number">2</span>)</span> </span>&#123; </span><br><span class="line">   print(index)</span><br><span class="line">&#125;<span class="comment">// through是包括5</span></span><br></pre></td></tr></table></figure></p>
<p>然后对字典的遍历也增强了.在Objective-c的快速枚举中我们只能对字典的键进行枚举。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *<span class="variable">key</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">key</span> in someDictionary)&#123;</span><br><span class="line">     NSLog(@<span class="string">"Key: %@, Value %@"</span>, <span class="variable">key</span>, [someDictionary objectForKey: <span class="variable">key</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,通过tuple我们可以同时枚举key与value:<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dictionary = [<span class="string">"firstName"</span>:<span class="string">"Mango"</span>,<span class="string">"lastName"</span>:<span class="string">"Fang"</span>]</span><br><span class="line"><span class="keyword">for</span> (key,<span class="keyword">value</span>) <span class="keyword">in</span> dictionary&#123;</span><br><span class="line">    print(key+<span class="string">" "</span>+<span class="keyword">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关于Switch">关于Switch</h4><p>Swich在Swift中也得到了功能的增强与安全性的提高。</p>
<h5 id="不需要Break来终止往下一个Case执行">不需要Break来终止往下一个Case执行</h5><p><strong>也就是下面这两种写法是等价的</strong></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">character</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:        <span class="keyword">print</span>(<span class="string">"A"</span>)    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:        <span class="keyword">print</span>(<span class="string">"B"</span>)    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">print</span>(<span class="string">"character"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">character</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:        <span class="keyword">print</span>(<span class="string">"A"</span>)    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:        <span class="keyword">print</span>(<span class="string">"B"</span>)</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">print</span>(<span class="string">"character"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种改进避免了忘记写break造成的错误,自己深有体会,曾经就是因为漏写了break而花了一段时间去debug。</p>
<p>如果我们想不同值统一处理,使用逗号将值隔开即可。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some <span class="built_in">value</span> <span class="built_in">to</span> consider &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">value</span> <span class="number">1</span>,<span class="built_in">value</span> <span class="number">2</span>:</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Switch支持的类型">Switch支持的类型</h5><p>在OC中,Swtich只支持int类型,char类型作为匹配。<br>而在Swift中,Switch支持的类型大大的拓宽了。实际上,苹果是这么说的。</p>
<blockquote>
<p>A switch statement supports any kind of data</p>
</blockquote>
<p>这意味在开发中我们能够能够对字符串,浮点数等进行匹配了。<br>之前在OC繁琐的写法就可以进行改进了:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Six"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:6]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Seven"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:7]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Eight"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:8]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Nine"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:9]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> carName&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Six"</span>:        self.vaule = <span class="number">6</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Seven"</span>:        self.vaule = <span class="number">7</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Eight"</span>:        self.vaule = <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Night"</span>:        self.vaule = <span class="number">9</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-函数">3.函数</h4><p>对于在OC中,方法有两种类型,类方法与实例方法。方法的组成由方法名,参数,返回值组成。<br>在Swift中函数的定义基本与OC一样。</p>
<p>主要区别为：<br>通过<code>func</code>关键词定义函数<br>返回值在<code>-&gt;</code>关键词后标注<br>各举一个类方法与实例方法例子。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="comment">(UIColor*)</span>blackColor</span><br><span class="line">- <span class="comment">(void)</span>addSubview:<span class="comment">(UIView *)</span>view</span><br></pre></td></tr></table></figure></p>
<p>对应的swift版本<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class func <span class="function"><span class="title">blackColor</span><span class="params">()</span></span> -&gt; UIColor <span class="comment">//类方法, 通过 class func 关键词声明    </span></span><br><span class="line">func <span class="function"><span class="title">addSubview</span><span class="params">(view: UIView)</span></span> <span class="comment">//实例方法</span></span><br></pre></td></tr></table></figure></p>
<h5 id="改进：">改进：</h5><ul>
<li>在Swift中,函数的最重要的改进就是函数作为一等公民(first-class),和对象一样可以作为参数进行传递,可以作为返回值,函数式编程也成为了Swift支持的编程范式。</li>
</ul>
<blockquote>
<p>In computer science, a programming language is said to have first-class functions if it treats functions as first-class citizens. Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures</p>
</blockquote>
<p>让我们初略感受一下函数式编程的魅力:<br>举一个例子,我们要筛选出一个数组里大于4的数字。<br>在OC中我们可能会用快速枚举来进行筛选。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *oldArray = <span class="constant">@[</span><span class="constant">@1</span>,<span class="constant">@2</span>,<span class="constant">@3</span>,<span class="constant">@4</span>,<span class="constant">@5</span>,<span class="constant">@6</span>,<span class="constant">@7</span>,<span class="constant">@8</span>,<span class="constant">@9</span>,<span class="constant">@10]</span><span class="comment">;</span></span><br><span class="line">NSMutableArray *newArray<span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (NSNumber* <span class="built_in">number</span> <span class="keyword">in</span> oldArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">number</span> compare:<span class="constant">@4]</span> == NSOrderedDescending ) &#123;</span><br><span class="line">        [newArray addObject:<span class="built_in">number</span>]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,我们用两行代码解决这个问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let oldArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]let newArray = oldArray.filter(&#123;$<span class="number">0</span> &gt; <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>进一步了解Swift的函数式编程可以通过这篇优秀的博客Functional Reactive Programming in Swift</p>
</blockquote>
<ul>
<li>个人觉得另外一个很棒的改进是：<code>Default parameter values</code></li>
</ul>
<p>在我们的项目中,经常会不断进行功能的增添。为了新增特性,许多方法在开发的过程中不断变动。举一个例子：我们开始有一个tableViewCell,它的设置方法一开始简单地需要一个Model参数：</p>
<p><code>func configureCellWithModel(Model: model)</code><br>不久之后,我们想对部分Cell增添一个设置背景颜色的功能。方法需要再接收多一个参数：<br><code>func configureCellWithModel(Model: model,color:UIColor)</code></p>
<p>这个时候方法改变,所以涉及到这些方法的地方都需要修改。给我们造成的困扰<br>  一是：需要做许多重复修改的工作。<br>  二是：无法做得很好的扩展和定制,有些地方的cell需要设置颜色,有些不需要。但是在OC里,我们只能对所有的cell都赋值。你可能觉得我们可以写两个方法,一个接收颜色参数,一个不接受。但是我们知道这不是一个很好的解决方法,会造成冗余的代码,维护起来也不方便。</p>
<p>而在Swift中,<code>default parameter values</code>的引入让我们能够这样修改我们的代码：<br><code>func configureCellWithModel(Model: model,color:UIColor = UIColor.whiteColor())</code><br>这样的改进能让我们写出的代码更具向后兼容性,减少了我们的重复工作量,减少了犯错误的可能性。</p>
<h4 id="4-类与初始化（Initializers）">4.类与初始化（Initializers）</h4><ul>
<li>文件结构与访问控制<br>在swift中,一个类不再分为<code>interface</code>（.h）与<code>implementation</code>(.m)两个文件实现,直接在一个.swift文件里进行处理。好处就是我们只需管理一份文件,以往两头奔波修改的情况就得到解放了,也减少了头文件与实现文件不同步导致的错误。</li>
</ul>
<p>这时我们会想到,那么我们如何来定义私有方法与属性呢,在OC中我们通过在<code>class extension</code>中定义私有属性,在.m文件定义私有方法。</p>
<p>而在Swift中,我们通过<code>Access Control</code>来进行控制。</p>
<blockquote>
<p>properties, types, functions等能够进行版本控制的统称为实体。</p>
<ul>
<li>Public：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或Framework是可以被任何人使用时，你可以将其设置为public级别。</li>
<li>Internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或Framework作为内部结构使用时，你可以将其设置为internal级别。</li>
<li>Private：只能在当前源文件中使用的实体，称为私有实体。使用private级别，可以用作隐藏某些功能的实现细节</li>
</ul>
</blockquote>
<p>一个小技巧,如果我们有一系列的私有方法,我们可以把它们组织起来,放进一个extension里,这样就不需要每个方法都标记private,同时也便于管理组织代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Private</span></span><br><span class="line">private <span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">privateFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>创建对象与alloc和init<br>关于初始化,在Swift中创建一个对象的语法很简洁：只需在类名后加一对圆括号即可。<br><code>var shape = Shape()</code><br>而在Swift中,<code>initializer</code>也与OC有所区别,Swift的初始化方法不返回数据。而在OC中我们通常返回一个self指针。</li>
</ul>
<blockquote>
<p>Unlike Objective-C initializers, Swift initializers do not return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</p>
</blockquote>
<p>Swift的初始化方法让我们只关注对象的初始化。之前在OC世界中为什么要self = [super init]？。这种问题得以避免。Swift帮助我们处理了alloc的过程。也让我们的代码更简洁明确。</p>
<p>而在Swift中,<code>init</code>也有了更严格的规则。</p>
<ul>
<li>对于所有<code>Stored Properties</code>,都必须在对象被创建出来前设置好。也就是我们必须在<code>init</code>方法中赋好值,或是直接给属性提供一个默认值。</li>
</ul>
<p>如果有property可以被允许在初始出来时没有值,也就是需要在创建出来后再赋值,或是在程序运行过程都可能不会被赋值。那么这个property必须被声明为<code>optional</code>类型。该类型的属性会在init的时候初始化为nil.</p>
<ul>
<li>initializer严格分为<code>Designated Initializer</code>和<code>Convenience Initializer</code><br>并且有语法定义。</li>
</ul>
<p>而在Objective-C中没有明确语法标记哪个初始化方式是convenience方法。</p>
<blockquote>
<p>关于Designated Initializer可参阅之前的:Objective-C 拾遗：designated initializer</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="title">statements</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">convenience</span> <span class="title">init</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="title">statements</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-枚举与结构体">5.枚举与结构体</h4><ul>
<li>枚举<br>在Swift中,枚举是一等公民。(first-class)。能够拥有方法,computed properties等以往只有类支持的特性。</li>
</ul>
<p>在C中,枚举为每个成员指定一个整型值。而在Swift中,枚举更强大和灵活。我们不必给枚举成员提供一个值。如果我们想要为枚举成员提供一个值(raw value),我们可以用字符串,字符,整型或浮点数类型。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="name">CompassPoint</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> Northcase Southcase Eastcase West</span><br><span class="line">&#125;  </span><br><span class="line"><span class="name">var</span> <span class="name">directionToHead</span> = CompassPoint.West</span><br></pre></td></tr></table></figure></p>
<ul>
<li>结构体</li>
</ul>
<p>Struct在Swift中和类有许多相同的地方,可以定义属性,方法,初始化方法,可通过extension扩展等。<br>不同的地方在于struct是值类型.在传递的过程中都是通过拷贝进行。</p>
<p>在这里要提到在前面第一节处提到了<code>String</code>,<code>Array</code>和<code>Dictionary</code>在Swift是以值类型出现的。这背后的原因就是<code>String</code>,<code>Array</code>,<code>Dictionary</code>在Swift中是通过Struct实现的。而之前在Objective-C它们都是通过class实现的。</p>
<p>Swift中强大的Struct使得我们能够更多与值类型打交道。Swift的值类型增强了<code>不可变性(Immutabiliity)</code>。而不可变性提升了我们代码的稳定性,多线程并发的安全性。</p>
<p>在WWDC2014《Advanced iOS Application Architecture and Patterns》中就有一节的标题是Simplify with immutability。</p>
<blockquote>
<p>延伸阅读：WWDC心得：Advanced iOS Application Architecture and Patterns</p>
</blockquote>
<h4 id="6-协议（Protocols）">6.协议（Protocols）</h4><p>语法:</p>
<p>在Objective-C中我们这么声明Protocol:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SampleProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)someMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>而在Swift中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Swift遵循协议:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SampleProtocol</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么之前Objective-C的protocol中,我们可以标志optional。那在Swift中呢？</p>
<p>遗憾的是,目前纯Swift的protocol还不支持optional。但根据苹果官方论坛的一位员工的回答,未来Swift是会支持的</p>
<blockquote>
<p>Optional methods in protocols are limited to @objc protocols only because we haven’t implemented them in native protocols yet. This is something we plan to support. We’ve gotten a number of requests for abstract/pure virtual classes and methods too.<br>— Joe Groff<br>Source: <a href="https://devforums.apple.com/message/1051431#1051431" target="_blank" rel="external">https://devforums.apple.com/message/1051431#1051431</a></p>
</blockquote>
<p><code>protocol</code>和<code>delegate</code>是紧密联系的。那么我们在Swift中如何定义Delegate呢？<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol MyDelegate : <span class="keyword">class</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123; </span><br><span class="line">   weak <span class="keyword">var</span> <span class="keyword">delegate</span> : MyDelegate?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到上面的protocol定义后面跟着的class。这意味着该protocol只能被class类型所遵守。<br>并且只有遵守了class protocol的delegate才能定义为weak。这是因为在Swift中,除了class能够遵守协议,枚举和结构同样能够遵守协议。而枚举和结构是值类型,不存在内存管理的问题。因此只需要class类型的变量声明为weak即可。</p>
<p>利用Swift的optional chaining,我们能够很方便的检查delegate是否为Nil,是否有实现某个方法:</p>
<p>以前我们要在Objective-C这样检查：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataSource &amp;&amp; [<span class="keyword">self</span>.dataSource <span class="symbol">respondsToSelector:</span><span class="variable">@selector</span>(<span class="symbol">titleForSegmentAtIndex:</span>)]) &#123;</span><br><span class="line">        thisSegmentTitle = [<span class="keyword">self</span>.dataSource <span class="symbol">titleForSegmentAtIndex:</span>index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Swift中,非常的优雅简洁。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> thisSementTitle = dataSource?.titleFroSegmentAtIndex?<span class="params">(index)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新特性:</p>
<p>在Swift中,protocol变得更加强大,灵活：</p>
<ol>
<li><p>class,enum,structure都可以遵守协议。</p>
</li>
<li><p>Extension也能遵守协议。利用它,我们不需要继承,也能够让系统的类也遵循我们的协议。</p>
</li>
</ol>
<p>例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">myProtocol</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>:<span class="title">myProtocol</span></span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还能够用这个特性来组织我们的代码结构,如下面的代码所示,将UITableViewDataSource的实现移到了Extension。使代码更清晰。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - UITableViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyViewcontroller</span>: <span class="title">UITableViewDataSource</span> </span>&#123; <span class="comment">// table view data source methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Protocol Oriented Programming<br>随着Swift2.0的发布,面向协议编程正式也加入到了Swift的编程范式。Cool.<br>这种编程方式通过怎样的语法特性支撑的呢？<br>那就是我们能够对协议进行扩展,也就是我们能够提供协议的默认实现,能够为协议添加新的方法与实现。<br>用前面的myProtocol为例子,我们在Swift里这样为它提供默认实现。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">myProtocol</span></span>&#123;</span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello world!"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们还能对系统原有的protocol进行扩展,大大增强了我们的想象空间。Swift2.0的实现也有很多地方用extension protocol的形式进行了重构。</p>
<p>面向协议编程能够展开说很多,在这里这简单地介绍了语法。</p>
<blockquote>
<p>有兴趣的朋友可以参考下面的资料：<br>Session 408: Protocol-Oriented Programming in Swift<br>IF YOU’RE SUBCLASSING, YOU’RE DOING IT WRONG.</p>
</blockquote>
<h4 id="7-Swift与Cocoa">7.Swift与Cocoa</h4><p>一门语言的的强大与否,除了自身优秀的特性外,很大一点还得依靠背后的框架。Swift直接采用苹果公司经营了很久的Cocoa框架。现在我们来看看使用Swift和Cocoa交互一些需要注意的地方。</p>
<ol>
<li>id与AnyObject<br>在Swift中,没有id类型,Swift用一个名字叫AnyObject的protocol来代表任意类型的对象。</li>
</ol>
<p><code>id myObject = [[UITableViewCell alloc]init];</code><br><code>var myObject: AnyObject = UITableViewCell()</code><br>我们知道id的类型直到运行时才能被确定,如果我们向一个对象发送一条不能响应的消息,就会导致crash。</p>
<p>我们可以利用Swift的语法特性来防止这样的错误:<br><code>myObject.method?()</code><br>如果myObject没有这个方法,就不会执行,类似检查delegate是否有实现代理方法。</p>
<p>在Swift中,在AnyObject上获取的property都是optional的。</p>
<ol>
<li><p>闭包<br>OC中的block在Swift中无缝地转换为闭包。函数实际上也是一种特殊的闭包。</p>
</li>
<li><p>错误处理<br>之前OC典型的错误处理步骤:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line"> <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/path/to/file"</span>];</span><br><span class="line"> <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"> <span class="built_in">BOOL</span> success = [fileManager removeItemAtURL:URL error:&amp;error];</span><br><span class="line"> <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error<span class="variable">.domain</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在Swift中：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = NSFileManager.defaultManager() </span><br><span class="line"><span class="keyword">let</span> URL = NSURL.fileURLWithPath(<span class="string">"/path/to/file"</span>) <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> fileManager.removeItemAtURL(URL)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> NSError &#123;  <span class="keyword">print</span>(<span class="string">"Error: \(error.domain)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>KVO。<br>Swift支持KVO。但是KVO在Swift,个人觉得是不够优雅的,KVO在Swift只限支持继承NSObject的类,有其局限性,在这里就不介绍如何使用了。</li>
</ol>
<p>网上也出现了一些开源库来解决这样的问题。有兴趣可以参考一下:</p>
<blockquote>
<p>Observable-Swift</p>
</blockquote>
<p>KVO 在OS X中有Binding的能力,也就是我们能够将两个属性绑定在一起,一个属性变化,另外一个属性也会变化。对与UI和数据的同步更新很有帮助,也是MVVM架构的需求之一。之前已经眼馋这个特性很久了,虽然Swift没有原生带来支持,Swift支持的泛型编程给开源界带来许多新的想法。下面这个库就是实现binding的效果。</p>
<blockquote>
<p>Bond</p>
</blockquote>
<h4 id="8-总结">8.总结</h4><p>到这里就基本介绍完Swift当中最基本的语法和与Objective-C的对比和改进。</p>
<p>事实上Swift的世界相比OC的世界还有很多新鲜的东西等待我们去发现和总结,Swift带来的多范式编程也将给我们编程的架构和代码的组织带来更来的思考。而Swift也是一个不断变化,不断革新的语言。相信未来的发展和稳定性会更让我们惊喜。这篇文章也将随着Swift的更新而不断更新,同时限制篇幅,突出重点。</p>
<p>希望这篇文章能够给各位同行的小伙伴们快速了解和学习Swift提供一点帮助。有疏漏错误的地方欢迎直接提出。感谢。</p>
<blockquote>
<p>转自 <a href="https://github.com/100mango/zen" target="_blank" rel="external">https://github.com/100mango/zen</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift/">swift</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-详解CALayer-和-UIView的区别和联系" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/03/详解CALayer-和-UIView的区别和联系/" class="article-date">
  	<time datetime="2015-09-03T12:45:12.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/03/详解CALayer-和-UIView的区别和联系/">详解CALayer 和 UIView的区别和联系</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>前面发了一篇iOS 面试的文章，在说到 UIView 和 CALayer 的区别和联系的时候，被喵神指出没有切中要点，所以这里就 CALayer 和 UIView 这个问题重新整理了下。这里会先分条解释，最后会在文章的结尾给出概括性总结。</p>
<h4 id="1-首先UIView可以响应事件，Layer不可以-">1.首先UIView可以响应事件，Layer不可以.</h4><p>UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。</p>
<p>在 UIResponder中定义了处理各种事件和事件传递的接口, 而 CALayer直接继承 NSObject，并没有相应的处理事件的接口。</p>
<p>下面列举一些处理触摸事件的接口</p>
<ul>
<li>– touchesBegan:withEvent:</li>
<li>– touchesMoved:withEvent:</li>
<li>– touchesEnded:withEvent:</li>
<li>– touchesCancelled:withEvent:<br>其实还有一些运动和远程控制事件等等，这里就不一一列举了。</li>
</ul>
<p>下面的两篇文章详细介绍了 iOS 事件的处理和传递</p>
<p>参考链接：</p>
<ol>
<li><a href="http://blog.csdn.net/chun799/article/details/8223612" target="_blank" rel="external">http://blog.csdn.net/chun799/article/details/8223612</a></li>
<li><a href="http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html" target="_blank" rel="external">http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html</a></li>
</ol>
<h4 id="2-View和CALayer的Frame映射及View如何创建CALayer-">2.View和CALayer的Frame映射及View如何创建CALayer.</h4><p>一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属性。（PS:center有些特列）为了证明这些，我做了如下的测试。</p>
<p>首先我自定义了两个类CustomView,CustomLayer分别继承 UIView 和 CALayer</p>
<p>在 CustomView 中重写了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [CustomLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenter:(<span class="built_in">CGPoint</span>)center</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setCenter:center];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setBounds:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在 CustomLayer中同样重写这些方法。只是 <code>setCenter</code>方法改成<code>setPosition</code>方法</p>
<p>我在两个类的初始化方法中都打下了断点<img src="/images/Snip20150820_12.png" alt="image"></p>
<p>首先我们会发现，我们在 [view initWithFrame] 的时候调用私有方法【UIView _createLayerWithFrame】去创建 CALayer。</p>
<p>然后我在创建 View 的时候，在 Layer 和 View 中Frame 相关的所有方法中都加上断点，可以看到大致如下的调用顺序如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[UIView _createLayerWithFrame]</span><br><span class="line">[Layer setBounds:bounds]</span><br><span class="line">[UIView setFrame：Frame]</span><br><span class="line">[Layer setFrame:frame]</span><br><span class="line">[Layer setPosition:position]</span><br><span class="line">[Layer setBounds:bounds]</span><br></pre></td></tr></table></figure></p>
<p>我发现在创建的过程只有调用了 Layer 的设置尺寸和位置的然而并没有调用View 的 <code>SetCenter</code> 和 <code>SetBounds</code> 方法。<br>然后我发现当我修改了 view的 <code>bounds.size</code> 或者 <code>bounds.origin</code> 的时候也只会调用上边 Layer的一些方法。所以我大胆的猜一下，View 的 Center 和 Bounds 只是直接返回layer 对应的 Position 和 Bounds.</p>
<p>View中frame getter方法，bounds和center，UIView并没有做什么工作；它只是简单的各自调用它底层的CALayer的frame，bounds和position方法。</p>
<p>关于 Frame 的理解参考：<a href="http://www.cocoachina.com/industry/20131209/7498.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20131209/7498.html</a></p>
<h4 id="3-UIView主要是对显示内容的管理而_CALayer_主要侧重显示内容的绘制。">3.UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制。</h4><p>我在 UIView 和 CALayer 分别重写了父类的方法。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[UIView drawRect:rect]</span><span class="comment">//UIView    </span></span><br><span class="line"></span><br><span class="line"><span class="attr_selector">[CALayer display]</span><span class="comment">//CALayer</span></span><br></pre></td></tr></table></figure></p>
<p>然后我在上面两个方法加了断点，可以看到如下的执行。<br><img src="/images/Snip20150820_11.png" alt="image"></p>
<p>可以看到 UIView 是 CALayer 的CALayerDelegate，我猜测是在代理方法内部[UIView(CALayerDelegate) drawLayer:inContext]调用 UIView 的 DrawRect方法，从而绘制出了 UIView 的内容.</p>
<h4 id="4-在做_iOS_动画的时候，修改非_RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。">4.在做 iOS 动画的时候，修改非 RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。</h4><p>对于每一个 UIView 都有一个 layer,把这个 layer 且称作RootLayer,而不是 View 的根 Layer的叫做 非 RootLayer。我们对UIView的属性修改时时不会产生默认动画，而对单独 layer属性直接修改会，这个默认动画的时间缺省值是0.25s.<br>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对为什么会这样做出了一个解释：</p>
<blockquote>
<p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p>
</blockquote>
<p>是因为任何可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 CAAction)。</p>
<p>layer 通过向它的 delegate 发送 actionForLayer:forKey: 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>
<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。</li>
<li>它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。</li>
<li>它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。<br>当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</li>
</ol>
<p>这部分的具体内容参考：<a href="http://objccn.io/issue-12-4/" target="_blank" rel="external">http://objccn.io/issue-12-4/</a></p>
<h3 id="总结">总结</h3><p>总接来说就是如下几点：</p>
<ul>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ul>
<h4 id="参考链接">参考链接</h4><p><a href="http://blog.csdn.net/weiwangchao_/article/details/7771538" target="_blank" rel="external">http://blog.csdn.net/weiwangchao_/article/details/7771538</a></p>
<blockquote>
<p>转自 <a href="http://www.jianshu.com/p/079e5cf0f014" target="_blank" rel="external">http://www.jianshu.com/p/079e5cf0f014</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS开发之UITableView性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/31/iOS开发之UITableView性能优化/" class="article-date">
  	<time datetime="2015-08-31T15:28:25.000Z" itemprop="datePublished">2015-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/iOS开发之UITableView性能优化/">iOS开发之UITableView性能优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面已经说过UITableView中的单元格cell是在显示到用户可视区域后创建的，那么如果用户往下滚动就会继续创建显示在屏幕上的单元格，如果用户向上滚动返回到查看过的内容时同样会重新创建之前已经创建过的单元格。如此一来即使UITableView的内容不是太多，如果用户反复的上下滚动，内存也会瞬间飙升，更何况很多时候UITableView的内容是很多的（例如微博展示列表，基本向下滚动是没有底限的）。</p>
<p>前面一节中我们曾经提到过如何优化UIScrollView，当时就是利用有限的UIImageView动态切换其内容来尽可能减少资源占用。同样的，在UITableView中也可以采用类似的方式，只是这时我们不是在滚动到指定位置后更改滚动的位置而是要将当前没有显示的Cell重新显示在将要显示的Cell的位置然后更新其内容。原因就是UITableView中的Cell结构布局可能是不同的，通过重新定位是不可取的，而是需要重用已经不再界面显示的已创建过的Cell。</p>
<p>当然，听起来这么做比较复杂，其实实现起来很简单，因为UITableView已经为我们实现了这种机制。在UITableView内部有一个缓存池，初始化时使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)方法指定一个可重用标识，就可以将这个cell放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的cell然后修改cell内容即可。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark返回每行的单元格</span></span><br><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="comment">//NSIndexPath是一个对象，记录了组和行信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成单元格(组：%i,行%i)"</span>,indexPath<span class="variable">.section</span>,indexPath<span class="variable">.row</span>);</span><br><span class="line">    KCContactGroup *group=_contacts[indexPath<span class="variable">.section</span>];</span><br><span class="line">    KCContact *contact=group<span class="variable">.contacts</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于此方法调用十分频繁，cell的标示声明成静态变量有利于性能优化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier=<span class="string">@"UITableViewCellIdentifierKey1"</span>;</span><br><span class="line">    <span class="comment">//首先根据标识去缓存池取</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    <span class="comment">//如果缓存池没有到则重新创建并放到缓存池中</span></span><br><span class="line">    <span class="keyword">if</span>(!cell)&#123;</span><br><span class="line">        cell=[[<span class="built_in">UITableViewCell</span> alloc]initWithStyle:<span class="built_in">UITableViewCellStyleValue1</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span>=[contact getName];</span><br><span class="line">    cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span>=contact<span class="variable">.phoneNumber</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cell:%@"</span>,cell);</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中已经打印了cell的地址，如果大家运行测试上下滚动UITableView会发现滚动时创建的cell地址是初始化时已经创建的。</p>
<p>这里再次给大家强调两点：</p>
<ul>
<li>-(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)方法调用很频繁，无论是初始化、上下滚动、刷新都会调用此方法，所有在这里执行的操作一定要注意性能；</li>
<li>可重用标识可以有多个，如果在UITableView中有多类结构不同的Cell，可以通过这个标识进行缓存和重新；</li>
</ul>
<blockquote>
<p>转 Kenshin Cui’s Blog</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tableview优化/">tableview优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-html5-audio-使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/30/html5-audio-使用/" class="article-date">
  	<time datetime="2015-08-29T16:02:33.000Z" itemprop="datePublished">2015-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/30/html5-audio-使用/">html5 audio 使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做html5 使用到了audio，发现audio在移动设备上面不能够自动播放<code>autoplay</code>属性没用</p>
<p>求解</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-怎么成为一名黑客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/27/怎么成为一名黑客/" class="article-date">
  	<time datetime="2015-08-27T15:10:14.000Z" itemprop="datePublished">2015-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/27/怎么成为一名黑客/">怎么成为一名黑客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我有不少黑客朋友。他们有的学医，有的学数学，有的学建筑，有的做安全之前的职业是开中巴。恩，当然，也有不少是计算机科班出身的。</p>
<p>这帮人，是怎么成为黑客的？</p>
<h4 id="会动脑">会动脑</h4><ul>
<li><p>最最重要的是「逆向思维」——所谓的「黑掉你，不在你关注的那个点上」（能独立思考，不人云亦云，善挖掘，不从众，懂大众心理，还懂得利用大众心理的「漏洞」）；</p>
</li>
<li><p>在网络攻防中找案例，我顺手搜了一个「自己打自己」的案例：简单一步即可扫描360内部系统安全漏洞（扫描器攻击技巧），出处为乌云：<a href="http://t.cn/RLeNiMY；" target="_blank" rel="external">http://t.cn/RLeNiMY；</a></p>
</li>
<li><p>逆向思维不仅仅适用于「暗黑领域」。实际上，无论你学的是什么，从事的是什么职业，这种思维模式都无比珍贵，拥有它，你有机会成为任意领域的黑客；</p>
</li>
<li><p>在军事上找类比，想想「马奇诺防线」，想想「围魏救赵」，再想想「黑掉你，不在你关注的那个点上」，你是不是领悟到了点什么？</p>
</li>
<li><p>一个漫画（出自 XKCD）：<br><img src="/images/42062-c7873b7151f31d5a.png" alt="图"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安全死宅想象中，自己的安全设计固若金汤：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑加密了，咱得砸个百万美金破掉它！</span><br><span class="line">恶人乙：嚓，想得美，是 <span class="number">4096</span> 位密码耶！</span><br><span class="line">恶人甲：倒霉，认栽吧，撤！</span><br><span class="line"></span><br><span class="line">真实世界里：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑居然加密！拿五美金买个扳手，扁他。扁到他说出密码为止！</span><br><span class="line">恶人乙：好咧。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>扁到他说出密码为止！恩，这就是我最推崇的思维能力（别领会错了，不是暴力，是不受你的规则限制）。</p>
<h4 id="肯学习">肯学习</h4><ul>
<li><p>那个学医的黑客（TK）在微博上说：漏洞产业很像玉石产业。漏洞生于脑，玉石出自矿。矿里有没有玉，要挖一挖。思路可不可行，要试一试。挖出矿石是不是玉，要开窗看。Crash 能不能变成 PoC，要调一调。矿石里的玉多大、什么成色，得整个磨开。PoC 好不好利用，要写成 Exploit。而后玉石雕成器，Exploit 写成真正的工具，会再价值大增；</p>
</li>
<li><p>挖、试、看、调、磨……各位看着各种黑客大赛，几秒攻破某某系统时，有没有想过台上一分钟，台下十年功？</p>
</li>
<li><p>我从业生涯中遇到的，真正笨和天才的人很少。有不少人「以为自己比实际上聪明」地走捷径，反而绕远，不如日拱一卒走得稳健长远；</p>
</li>
<li><p>如果你问：我肯学习，但是该学什么？怎么学？请参见第一条：「会动脑」。</p>
</li>
</ul>
<h4 id="重实践">重实践</h4><ul>
<li><p>纸上得来终觉浅。绝大多数人都是「听过很多道理，依然过不好这一生」的，路要自己走，错误要自己犯，一行行代码要自己写，一个个绕过限制的奇技淫巧要自己苦思冥想。突破了，收获就是自己的；</p>
</li>
<li><p>实践的方法很多，比如长期做一个开源软件（做之前请先动脑想清楚做什么、为什么做、值不值得长期做等一系列问题）、比如写文章记录自己的学习历程、比如把历史上著名的漏洞撸一遍并分享代码和心得……</p>
</li>
</ul>
<h4 id="走正道">走正道</h4><ul>
<li><p>玩黑客攻防这个行当，脑洞一旦开了，很容易发现不少地方可以快速挣钱。但「伸手」之前，请想清楚：会上瘾！尝过轻松来钱的滋味后，再想踏实做事就难了。</p>
</li>
<li><p>常在河边走，哪有不湿鞋。</p>
</li>
</ul>
<blockquote>
<p>转 <a href="http://www.jianshu.com/p/611b32c50fa2" target="_blank" rel="external">http://www.jianshu.com/p/611b32c50fa2</a></p>
</blockquote>
<p>最近一直想破机附近的wifi密码 ^_^</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-AVFoundation和-GPUImage初探" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/26/AVFoundation和-GPUImage初探/" class="article-date">
  	<time datetime="2015-08-26T15:21:58.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/26/AVFoundation和-GPUImage初探/">AVFoundation和 GPUImage初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>
<h4 id="AVFoundation的一些基本概念">AVFoundation的一些基本概念</h4><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。<br><img src="/images/ba81ca29gw1evcbinsawmj20qj0go0tt.jpg" alt="ba81ca29gw1evcbinsawmj20qj0go0tt"></p>
<h4 id="相关类">相关类</h4><ul>
<li>AVAsset</li>
<li>AVAssetTrack</li>
<li>AVComposition</li>
<li>AVVideoComposition</li>
<li>AVAudioMix</li>
<li>AVMutableAudioMixInputParameter</li>
<li>AVMutableVideoCompositionInstrution</li>
<li>AVMutableVideoCompositionLayerInstrution<br>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录<br>制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</li>
</ul>
<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。<br><img src="/images/ba81ca29gw1evcbjm927vj20jm0hsmzv.jpg" alt="ba81ca29gw1evcbjm927vj20jm0hsmzv"><br>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>
<p>typedef struct<br>{<br>CMTimeValue value;<br>CMTimeScale timescale;<br>CMTimeFlags flags;<br>CMTimeEpoch epoch;<br>} CMTime;<br>通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看这里。</p>
<h3 id="进阶">进阶</h3><h4 id="视频的录制">视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、<br>AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。<br><img src="capture.png"><br>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *<span class="keyword">array</span> = [output.metadta mutableCopy];</span><br><span class="line">AVMutableMetadataItem *<span class="literal">item</span> = [[AVMutableMetadataItem alloc] init];</span><br><span class="line"><span class="literal">item</span>.keyspace = ...;</span><br><span class="line"><span class="literal">item</span>.key = ...;</span><br><span class="line"><span class="literal">item</span>.<span class="keyword">value</span> = ...;</span><br><span class="line">[<span class="keyword">array</span> addObject:item];</span><br><span class="line">output.metadata = <span class="keyword">array</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">    session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[session beginConfiguration]</span>;</span><br><span class="line"><span class="comment">//移除某个输入源</span></span><br><span class="line"><span class="comment">//再添加某个输入源</span></span><br><span class="line"><span class="comment">//再为新添加的输入源进行必要的相关设置</span></span><br><span class="line"><span class="comment">//...其他操作</span></span><br><span class="line"><span class="attr_selector">[session commitConfiguration]</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现 captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput<span class="variable">.videoSettings</span> = newSettings;</span><br></pre></td></tr></table></figure>
<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span></span><br><span class="line">- (<span class="keyword">void</span>)yourCustomMethodName&#123;</span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">            session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(session canAddInput:input)&#123;</span><br><span class="line">        [session addInput:input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span>(session canAddOutput:output)&#123;</span><br><span class="line">        [session addOutput:output];</span><br><span class="line">    &#125;</span><br><span class="line">    output<span class="variable">.videoSettings</span> =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">    <span class="comment">//设置帧率(FPS),每秒15帧</span></span><br><span class="line">    output<span class="variable">.minFrameDuration</span> = CMTimeMake(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"CustomQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue)</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用来显示录制的实时画面</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:captureVideoPreviewLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户是否允许启用摄像头</span></span><br><span class="line">    [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Granted access to mediaType</span></span><br><span class="line">            [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">            [session startRunning];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span></span><br><span class="line">                                        message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span></span><br><span class="line">                                       delegate:<span class="keyword">self</span></span><br><span class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></span><br><span class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                    [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];</span><br><span class="line">NSURL *fileURL = ...;    <span class="comment">//存放位置</span></span><br><span class="line"><span class="comment">//指定代理</span></span><br><span class="line">[aMovieFileOutput <span class="string">startRecordingToOutputFileURL:</span>fileURL <span class="string">recordingDelegate:</span>delete];</span><br><span class="line"><span class="comment">//也可以为其指定outputSettings</span></span><br><span class="line">同样代理必须实现协议方法<span class="string">captureOutput:</span><span class="string">didFinishRecordingToOutputFileAtURL:</span><span class="string">fromConnections:</span><span class="string">error:</span>,</span><br></pre></td></tr></table></figure></p>
<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到更多。</p>
<h4 id="视频的剪辑">视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图<br><img src="/images/ba81ca29gw1evcblhcl2ej20p50eyjvj.jpg" alt="ba81ca29gw1evcblhcl2ej20p50eyjvj"></p>
<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。<br>关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见这里。</p>
<p>其中图中1，2，3用到的方法为<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[1]</span></span><br><span class="line"><span class="title">[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]</span></span><br><span class="line"><span class="title">[2]</span></span><br><span class="line"><span class="title">[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]</span><span class="comment">;`</span></span><br><span class="line"><span class="title">[3]</span></span><br><span class="line"><span class="title">[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]</span></span><br></pre></td></tr></table></figure></p>
<p>关于视频的剪辑的代码可以参见苹果给出的官方Demo以及Raywendrich上的两篇文章1,2。</p>
<h3 id="GPUImage">GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<h4 id="分段录制">分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Add</span> audio capture to the session. <span class="type">Adding</span> inputs <span class="keyword">and</span> outputs freezes </span><br><span class="line">//the capture session momentarily, so you can use this <span class="keyword">method</span> to add </span><br><span class="line">//the audio inputs <span class="keyword">and</span> outputs early, <span class="keyword">if</span> you’re going to <span class="type">set</span> the </span><br><span class="line">//audioEncodingTarget later. <span class="type">Returns</span> <span class="type">YES</span> <span class="keyword">is</span> the audio inputs <span class="keyword">and</span> </span><br><span class="line">//outputs were added, <span class="keyword">or</span> <span class="type">NO</span> <span class="keyword">if</span> they had already been added.</span><br><span class="line"></span><br><span class="line">-(<span class="type">BOOL</span>)addAudioInputsAndOutputs;</span><br></pre></td></tr></table></figure>
<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>
<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你分段录制的实现,GPUImageExtend。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>
<h4 id="所见即所得">所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>
<pre><code><span class="number">1.</span>使用GPUImageCropFilter,通过设置其cropRegion来裁出中间<span class="number">540</span>x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在<span class="number">0.0</span>~<span class="number">1.0</span>范围内,比如<span class="number">960</span>x540裁剪至中间<span class="number">540</span>x540部分则cropRegion为(<span class="number">0</span>,((<span class="number">960</span>-<span class="number">540</span>)/<span class="number">2</span>)/<span class="number">960</span>,<span class="number">1</span>,<span class="number">540</span>/<span class="number">960</span>)
<span class="number">2.</span>改变videoComposition的perferTransfom使其只显示中间的<span class="number">540</span>x540。
</code></pre><p>这样就完成了所见即所得。</p>
<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个issue和一些解决办法。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>
<h4 id="总结">总结</h4><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 键盘
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>