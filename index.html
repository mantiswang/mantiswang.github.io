<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>白色键盘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客，记录重要知识，iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="白色键盘">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="白色键盘">
<meta property="og:description" content="写博客，记录重要知识，iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白色键盘">
<meta name="twitter:description" content="写博客，记录重要知识，iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="白色键盘" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">苹果</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">苹果</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">苹果</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Swift学习-从Objective-C到Swift" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/04/Swift学习-从Objective-C到Swift/" class="article-date">
  	<time datetime="2015-09-04T12:54:50.000Z" itemprop="datePublished">2015-09-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/04/Swift学习-从Objective-C到Swift/">Swift学习: 从Objective-C到Swift</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Swift学习:_从Objective-C到Swift">Swift学习: 从Objective-C到Swift</h3><p>这篇文章是自己学习Swift的笔记与深化。希望这篇文章能够帮助已经有Objective-C经验的开发者更快地学习Swift。同时也品味到Swift的精妙之处。</p>
<p>结论放在开头:</p>
<p>我认为Swift比Objective-C更优雅,更安全同时也更现代,更性感。</p>
<p>文章组织脉络：</p>
<ol>
<li>从Objective-C到Swift的语法差异。我们熟悉的Objective-C特性在Swift中如何展现。</li>
<li>从Objective-C到Swift的进步改进。研究对比Swift在安全性,易用性上的提升,给我们带来的新编程范式。</li>
</ol>
<h4 id="1-属性(property)和实例变量(instance_variable)">1.属性(property)和实例变量(instance variable)</h4><h4 id="Objective-C_property_in_Swift_world">Objective-C property in Swift world</h4><p>在Cocoa世界开发的过程中,我们最常打交道的是property.<br>典型的声明为:<br><code>@property (strong,nonatomic) NSString *string;</code></p>
<p>而在Swift当中,摆脱了C的包袱后,变得更为精炼,我们只需直接在类中声明即可<br><code>class Shape {    var name = &quot;shape&quot;}</code><br>注意到这里,我们不再需要<code>@property</code>指令,而在Objective-C中,我们可以指定property的attribute,例如strong,weak,readonly等。<br>而在Swift的世界中,我们通过其他方式来声明这些property的性质。</p>
<p>需要注意的几点:</p>
<ul>
<li><code>strong</code>: 在Swift中是默认的</li>
<li><code>weak</code>: 通过weak关键词申明<br><code>weak var delegate: UITextFieldDelegate?</code></li>
<li><code>readonly</code>,<code>readwrie</code>  直接通过声明变量<code>var</code>,声明常量<code>let</code>的方式来指明</li>
<li><code>copy</code> 通过<code>@NSCopying</code>指令声明。</li>
</ul>
<h3 id="值得注意的是String,Array和Dictionary在Swift是以值类型(value_type)而不是引用类型(reference_type)出现,因此它们在赋值,初始化,参数传递中都是以拷贝的方式进行（简单来说,String,Array,Dictionary在Swift中是通过struct实现的）">值得注意的是String,Array和Dictionary在Swift是以值类型(value type)而不是引用类型(reference type)出现,因此它们在赋值,初始化,参数传递中都是以拷贝的方式进行（简单来说,String,Array,Dictionary在Swift中是通过struct实现的）</h3><blockquote>
<p>延伸阅读：Value and Reference Types</p>
</blockquote>
<ul>
<li><code>nonatomic</code>,<code>atomic</code> 所有的Swift properties 都是nonatomic。但是我们在线程安全上已经有许多机制,例如NSLock,GCD相关API等。个人推测原因是苹果想把这一个本来就用的很少的特性去掉,线程安全方面交给平时我们用的更多的机制去处理。</li>
</ul>
<p>然后值得注意的是,在Objective-C中,我们可以跨过property直接与instance variable打交道,而在Swift是不可以的。</p>
<p>例如：我们可以不需要将someString声明为property,直接使用即可。即使我们将otherString声明为property,我们也可以直接用_otherString来使用property背后的实例变量。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSString</span> *someString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* otherString;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,我们不能直接与instance variable打交道。也就是我们声明的方式简化为简单的一种,简单来说在Swift中,我们只与property打交道。</p>
<blockquote>
<p>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly</p>
</blockquote>
<h4 id="小结">小结</h4><ul>
<li><p>因此之前使用OC导致的像巧哥指出的开发争议就不再需要争执了,在Swift的世界里,我们只与property打交道。</p>
</li>
<li><p>并且我们在OC中<code>init</code>和<code>dealloc</code>不能使用属性<code>self.property = XXX</code>来进行设置的情况得以解决和统一。</p>
</li>
</ul>
<p>(不知道这一条规定,在init直接用self.property = value 的同学请自觉阅读iOS夯实：内存管理)</p>
<p>：）</p>
<p>个人觉得这看似小小一点变动使Swift开发变得更加安全以及在代码的风格更为统一与稳定。</p>
<h4 id="Swift_property延伸：">Swift property延伸：</h4><ul>
<li><code>Stored Properties</code>和<code>Computed properties</code></li>
</ul>
<p>在Swift中,property被分为两类：<code>Stored Properties</code>和<code>Computed properties</code><br>简单来说,就是stored properties 能够保存值,而conmuted properties只提供getter与setter,利用stored properties来生成自己的值。个人感觉Computed properties更像方法,而不是传统意义的属性。但是这样一个特性存在,使得我们更容易组织我们的代码。</p>
<blockquote>
<p>延伸阅读：computed property vs function</p>
</blockquote>
<ul>
<li><code>Type Properties</code></li>
</ul>
<p>Swift提供了语言级别定义类变量的方法。</p>
<blockquote>
<p>In C and Objective-C, you define static constants and variables associated with a type as global static variables.In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</p>
</blockquote>
<p>在Objective-C中,我们只能通过单例,或者static变量加类方法来自己构造类变量：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span></span></span><br><span class="line">+ (<span class="keyword">int</span>) value;</span><br><span class="line">+ (<span class="keyword">void</span>) setValue:(<span class="keyword">int</span>)val;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Model</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">+ (<span class="keyword">int</span>) value</span><br><span class="line">&#123; <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; <span class="keyword">return</span> value; &#125; &#125;</span><br><span class="line">+ (<span class="keyword">void</span>) setValue:(<span class="keyword">int</span>)val</span><br><span class="line">&#123; <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; value = val; &#125; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSDictionary</span>*) dictionary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo.m</span></span><br><span class="line">+(<span class="built_in">NSDictionary</span>*) dictionary</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">NSDictionary</span>* fooDict = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        <span class="comment">// create dict</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fooDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在Swift中我们通过清晰的语法便能定义类变量：</p>
<p>通过static定义的类变量无法在子类重写,通过class定义的类变量则可在子类重写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;    </span><br><span class="line">    static <span class="variable"><span class="keyword">var</span> storedTypeProperty</span> = <span class="string">"Some value."</span></span><br><span class="line">    static <span class="variable"><span class="keyword">var</span> computedTypeProperty</span>: <span class="typename">Int</span> &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="typename">Int &#123;  </span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时利用类变量我们也有了更优雅的单例模式实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">singletonClass</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = singletonClass()</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 这就阻止其他对象使用这个类的默认的'()'初始化方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift单例模式探索：The Right Way to Write a Singleton</p>
<ul>
<li>延伸：<br>目前Swift支持的type propertis中的Stored Properties类型不是传统意义上的类变量(class variable)，暂时不能通过class 关键词定义,通过static定义的类变量类似java中的类变量,是无法被继承的,父类与子类的类变量指向的都是同一个静态变量。</li>
</ul>
<blockquote>
<p>延伸阅读： Class variables not yet supported</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">storedTypeProperty</span> </span>= <span class="string">"Some value."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2.0 </span></span><br><span class="line"><span class="built_in">Error</span>: Class stored properties not yet supported <span class="keyword">in</span> classes</span><br></pre></td></tr></table></figure>
<p>通过编译器抛出的错误信息,相信在未来的版本中会完善Type properties。</p>
<h4 id="2-控制流">2.控制流</h4><p>Swift与Objective-C在控制流的语法上关键词基本是一致的,但是扩展性和安全性得到了很大的提升。</p>
<p>主要有三种类型的语句</p>
<ol>
<li>if,switch和新增的guard</li>
<li>for,while</li>
<li>break,continue<br>主要差异有：</li>
</ol>
<h4 id="关于if">关于if</h4><h5 id="语句里的条件不再需要使用()包裹了。">语句里的条件不再需要使用()包裹了。</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">number</span> = <span class="number">23</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">number</span> &lt; <span class="number">10</span> &#123;  </span><br><span class="line">  print(<span class="string">"The number is small"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是后面判断执行的的代码必须使用{}包裹住。<br>为什么呢,在C,C++等语言中,如果后面执行的语句只有语句,我们可以写成:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = <span class="number">23</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">number</span> &lt; <span class="number">10</span>)</span><br><span class="line">   NSLog(<span class="string">"The number is small"</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是如果有时要在后面添加新的语句,忘记添加{},灾难就很可能发送。</p>
<p>：） 像苹果公司自己就犯过这样的错误。下面这段代码就是著名的goto fail错误,导致了严重的安全性问题。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = SSLHashSHA1<span class="built_in">.</span>update(<span class="subst">&amp;</span>hashCtx, <span class="subst">&amp;</span>signedParams)) != <span class="number">0</span>)    goto fail;    goto fail;  <span class="comment">// :)注意 这不是Python的缩减</span></span><br><span class="line"><span class="attribute">...</span> other checks <span class="attribute">...</span></span><br><span class="line">fail:</span><br><span class="line">  <span class="attribute">...</span> buffer frees (cleanups) <span class="attribute">...</span>    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure></p>
<p>：）<br>最终在Swift,苹果终于在根源上消除了可能导致这种错误的可能性。</p>
<h5 id="if_后面的条件必须为Boolean表达式">if 后面的条件必须为Boolean表达式</h5><p>也就是不会隐式地与0进行比较,<code>下面这种写法是错误的</code>,因为number并不是一个boolean表达式,number != 0才是。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">number</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关于for">关于for</h4><p>for循环在Swift中变得更方便,更强大。</p>
<p>得益于Swift新添加的范围操作符<code>...</code>与 <code>...&lt;</code><br>我们能够将之前繁琐的for循环：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt;= 5; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>, i)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改写为：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="built_in">index</span> <span class="type">in</span> <span class="number">1.</span>.<span class="number">.5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">index</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然,熟悉Python的亲们知道Python的range函数很方便,我们还能自由选择步长。<br>像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(<span class="number">1</span>,<span class="number">5</span>) <span class="preprocessor">#代表从<span class="number">1</span>到<span class="number">5</span>(不包含<span class="number">5</span>)[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&gt;&gt;&gt; range(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>) #代表从<span class="number">1</span>到<span class="number">5</span>，间隔<span class="number">2</span>(不包含<span class="number">5</span>)[<span class="number">1</span>, <span class="number">3</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>虽然在《The Swift Programming Language》里面没有提到类似的用法,但是在Swift中我们也有优雅的方法办到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> index in <span class="title">stride</span><span class="params">(from: <span class="number">1</span>, through: <span class="number">5</span>, by: <span class="number">2</span>)</span> </span>&#123; </span><br><span class="line">   print(index)</span><br><span class="line">&#125;<span class="comment">// through是包括5</span></span><br></pre></td></tr></table></figure></p>
<p>然后对字典的遍历也增强了.在Objective-c的快速枚举中我们只能对字典的键进行枚举。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *<span class="variable">key</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">key</span> in someDictionary)&#123;</span><br><span class="line">     NSLog(@<span class="string">"Key: %@, Value %@"</span>, <span class="variable">key</span>, [someDictionary objectForKey: <span class="variable">key</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,通过tuple我们可以同时枚举key与value:<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dictionary = [<span class="string">"firstName"</span>:<span class="string">"Mango"</span>,<span class="string">"lastName"</span>:<span class="string">"Fang"</span>]</span><br><span class="line"><span class="keyword">for</span> (key,<span class="keyword">value</span>) <span class="keyword">in</span> dictionary&#123;</span><br><span class="line">    print(key+<span class="string">" "</span>+<span class="keyword">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关于Switch">关于Switch</h4><p>Swich在Swift中也得到了功能的增强与安全性的提高。</p>
<h5 id="不需要Break来终止往下一个Case执行">不需要Break来终止往下一个Case执行</h5><p><strong>也就是下面这两种写法是等价的</strong></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">character</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:        <span class="keyword">print</span>(<span class="string">"A"</span>)    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:        <span class="keyword">print</span>(<span class="string">"B"</span>)    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">print</span>(<span class="string">"character"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">character</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:        <span class="keyword">print</span>(<span class="string">"A"</span>)    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:        <span class="keyword">print</span>(<span class="string">"B"</span>)</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">print</span>(<span class="string">"character"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种改进避免了忘记写break造成的错误,自己深有体会,曾经就是因为漏写了break而花了一段时间去debug。</p>
<p>如果我们想不同值统一处理,使用逗号将值隔开即可。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some <span class="built_in">value</span> <span class="built_in">to</span> consider &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">value</span> <span class="number">1</span>,<span class="built_in">value</span> <span class="number">2</span>:</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Switch支持的类型">Switch支持的类型</h5><p>在OC中,Swtich只支持int类型,char类型作为匹配。<br>而在Swift中,Switch支持的类型大大的拓宽了。实际上,苹果是这么说的。</p>
<blockquote>
<p>A switch statement supports any kind of data</p>
</blockquote>
<p>这意味在开发中我们能够能够对字符串,浮点数等进行匹配了。<br>之前在OC繁琐的写法就可以进行改进了:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Six"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:6]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Seven"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:7]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Eight"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:8]</span>;</span><br><span class="line">&#125; <span class="tag">else</span> <span class="tag">if</span> ([cardName <span class="attribute">isEqualToString</span>:@<span class="string">"Nine"</span>]) &#123;</span><br><span class="line">    <span class="attr_selector">[self setValue:9]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> carName&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Six"</span>:        self.vaule = <span class="number">6</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Seven"</span>:        self.vaule = <span class="number">7</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Eight"</span>:        self.vaule = <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Night"</span>:        self.vaule = <span class="number">9</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-函数">3.函数</h4><p>对于在OC中,方法有两种类型,类方法与实例方法。方法的组成由方法名,参数,返回值组成。<br>在Swift中函数的定义基本与OC一样。</p>
<p>主要区别为：<br>通过<code>func</code>关键词定义函数<br>返回值在<code>-&gt;</code>关键词后标注<br>各举一个类方法与实例方法例子。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="comment">(UIColor*)</span>blackColor</span><br><span class="line">- <span class="comment">(void)</span>addSubview:<span class="comment">(UIView *)</span>view</span><br></pre></td></tr></table></figure></p>
<p>对应的swift版本<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class func <span class="function"><span class="title">blackColor</span><span class="params">()</span></span> -&gt; UIColor <span class="comment">//类方法, 通过 class func 关键词声明    </span></span><br><span class="line">func <span class="function"><span class="title">addSubview</span><span class="params">(view: UIView)</span></span> <span class="comment">//实例方法</span></span><br></pre></td></tr></table></figure></p>
<h5 id="改进：">改进：</h5><ul>
<li>在Swift中,函数的最重要的改进就是函数作为一等公民(first-class),和对象一样可以作为参数进行传递,可以作为返回值,函数式编程也成为了Swift支持的编程范式。</li>
</ul>
<blockquote>
<p>In computer science, a programming language is said to have first-class functions if it treats functions as first-class citizens. Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures</p>
</blockquote>
<p>让我们初略感受一下函数式编程的魅力:<br>举一个例子,我们要筛选出一个数组里大于4的数字。<br>在OC中我们可能会用快速枚举来进行筛选。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *oldArray = <span class="constant">@[</span><span class="constant">@1</span>,<span class="constant">@2</span>,<span class="constant">@3</span>,<span class="constant">@4</span>,<span class="constant">@5</span>,<span class="constant">@6</span>,<span class="constant">@7</span>,<span class="constant">@8</span>,<span class="constant">@9</span>,<span class="constant">@10]</span><span class="comment">;</span></span><br><span class="line">NSMutableArray *newArray<span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (NSNumber* <span class="built_in">number</span> <span class="keyword">in</span> oldArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">number</span> compare:<span class="constant">@4]</span> == NSOrderedDescending ) &#123;</span><br><span class="line">        [newArray addObject:<span class="built_in">number</span>]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Swift中,我们用两行代码解决这个问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let oldArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]let newArray = oldArray.filter(&#123;$<span class="number">0</span> &gt; <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>进一步了解Swift的函数式编程可以通过这篇优秀的博客Functional Reactive Programming in Swift</p>
</blockquote>
<ul>
<li>个人觉得另外一个很棒的改进是：<code>Default parameter values</code></li>
</ul>
<p>在我们的项目中,经常会不断进行功能的增添。为了新增特性,许多方法在开发的过程中不断变动。举一个例子：我们开始有一个tableViewCell,它的设置方法一开始简单地需要一个Model参数：</p>
<p><code>func configureCellWithModel(Model: model)</code><br>不久之后,我们想对部分Cell增添一个设置背景颜色的功能。方法需要再接收多一个参数：<br><code>func configureCellWithModel(Model: model,color:UIColor)</code></p>
<p>这个时候方法改变,所以涉及到这些方法的地方都需要修改。给我们造成的困扰<br>  一是：需要做许多重复修改的工作。<br>  二是：无法做得很好的扩展和定制,有些地方的cell需要设置颜色,有些不需要。但是在OC里,我们只能对所有的cell都赋值。你可能觉得我们可以写两个方法,一个接收颜色参数,一个不接受。但是我们知道这不是一个很好的解决方法,会造成冗余的代码,维护起来也不方便。</p>
<p>而在Swift中,<code>default parameter values</code>的引入让我们能够这样修改我们的代码：<br><code>func configureCellWithModel(Model: model,color:UIColor = UIColor.whiteColor())</code><br>这样的改进能让我们写出的代码更具向后兼容性,减少了我们的重复工作量,减少了犯错误的可能性。</p>
<h4 id="4-类与初始化（Initializers）">4.类与初始化（Initializers）</h4><ul>
<li>文件结构与访问控制<br>在swift中,一个类不再分为<code>interface</code>（.h）与<code>implementation</code>(.m)两个文件实现,直接在一个.swift文件里进行处理。好处就是我们只需管理一份文件,以往两头奔波修改的情况就得到解放了,也减少了头文件与实现文件不同步导致的错误。</li>
</ul>
<p>这时我们会想到,那么我们如何来定义私有方法与属性呢,在OC中我们通过在<code>class extension</code>中定义私有属性,在.m文件定义私有方法。</p>
<p>而在Swift中,我们通过<code>Access Control</code>来进行控制。</p>
<blockquote>
<p>properties, types, functions等能够进行版本控制的统称为实体。</p>
<ul>
<li>Public：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或Framework是可以被任何人使用时，你可以将其设置为public级别。</li>
<li>Internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或Framework作为内部结构使用时，你可以将其设置为internal级别。</li>
<li>Private：只能在当前源文件中使用的实体，称为私有实体。使用private级别，可以用作隐藏某些功能的实现细节</li>
</ul>
</blockquote>
<p>一个小技巧,如果我们有一系列的私有方法,我们可以把它们组织起来,放进一个extension里,这样就不需要每个方法都标记private,同时也便于管理组织代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Private</span></span><br><span class="line">private <span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">privateFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>创建对象与alloc和init<br>关于初始化,在Swift中创建一个对象的语法很简洁：只需在类名后加一对圆括号即可。<br><code>var shape = Shape()</code><br>而在Swift中,<code>initializer</code>也与OC有所区别,Swift的初始化方法不返回数据。而在OC中我们通常返回一个self指针。</li>
</ul>
<blockquote>
<p>Unlike Objective-C initializers, Swift initializers do not return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</p>
</blockquote>
<p>Swift的初始化方法让我们只关注对象的初始化。之前在OC世界中为什么要self = [super init]？。这种问题得以避免。Swift帮助我们处理了alloc的过程。也让我们的代码更简洁明确。</p>
<p>而在Swift中,<code>init</code>也有了更严格的规则。</p>
<ul>
<li>对于所有<code>Stored Properties</code>,都必须在对象被创建出来前设置好。也就是我们必须在<code>init</code>方法中赋好值,或是直接给属性提供一个默认值。</li>
</ul>
<p>如果有property可以被允许在初始出来时没有值,也就是需要在创建出来后再赋值,或是在程序运行过程都可能不会被赋值。那么这个property必须被声明为<code>optional</code>类型。该类型的属性会在init的时候初始化为nil.</p>
<ul>
<li>initializer严格分为<code>Designated Initializer</code>和<code>Convenience Initializer</code><br>并且有语法定义。</li>
</ul>
<p>而在Objective-C中没有明确语法标记哪个初始化方式是convenience方法。</p>
<blockquote>
<p>关于Designated Initializer可参阅之前的:Objective-C 拾遗：designated initializer</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="title">statements</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">convenience</span> <span class="title">init</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="title">statements</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-枚举与结构体">5.枚举与结构体</h4><ul>
<li>枚举<br>在Swift中,枚举是一等公民。(first-class)。能够拥有方法,computed properties等以往只有类支持的特性。</li>
</ul>
<p>在C中,枚举为每个成员指定一个整型值。而在Swift中,枚举更强大和灵活。我们不必给枚举成员提供一个值。如果我们想要为枚举成员提供一个值(raw value),我们可以用字符串,字符,整型或浮点数类型。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="name">CompassPoint</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> Northcase Southcase Eastcase West</span><br><span class="line">&#125;  </span><br><span class="line"><span class="name">var</span> <span class="name">directionToHead</span> = CompassPoint.West</span><br></pre></td></tr></table></figure></p>
<ul>
<li>结构体</li>
</ul>
<p>Struct在Swift中和类有许多相同的地方,可以定义属性,方法,初始化方法,可通过extension扩展等。<br>不同的地方在于struct是值类型.在传递的过程中都是通过拷贝进行。</p>
<p>在这里要提到在前面第一节处提到了<code>String</code>,<code>Array</code>和<code>Dictionary</code>在Swift是以值类型出现的。这背后的原因就是<code>String</code>,<code>Array</code>,<code>Dictionary</code>在Swift中是通过Struct实现的。而之前在Objective-C它们都是通过class实现的。</p>
<p>Swift中强大的Struct使得我们能够更多与值类型打交道。Swift的值类型增强了<code>不可变性(Immutabiliity)</code>。而不可变性提升了我们代码的稳定性,多线程并发的安全性。</p>
<p>在WWDC2014《Advanced iOS Application Architecture and Patterns》中就有一节的标题是Simplify with immutability。</p>
<blockquote>
<p>延伸阅读：WWDC心得：Advanced iOS Application Architecture and Patterns</p>
</blockquote>
<h4 id="6-协议（Protocols）">6.协议（Protocols）</h4><p>语法:</p>
<p>在Objective-C中我们这么声明Protocol:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SampleProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)someMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>而在Swift中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Swift遵循协议:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SampleProtocol</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么之前Objective-C的protocol中,我们可以标志optional。那在Swift中呢？</p>
<p>遗憾的是,目前纯Swift的protocol还不支持optional。但根据苹果官方论坛的一位员工的回答,未来Swift是会支持的</p>
<blockquote>
<p>Optional methods in protocols are limited to @objc protocols only because we haven’t implemented them in native protocols yet. This is something we plan to support. We’ve gotten a number of requests for abstract/pure virtual classes and methods too.<br>— Joe Groff<br>Source: <a href="https://devforums.apple.com/message/1051431#1051431" target="_blank" rel="external">https://devforums.apple.com/message/1051431#1051431</a></p>
</blockquote>
<p><code>protocol</code>和<code>delegate</code>是紧密联系的。那么我们在Swift中如何定义Delegate呢？<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol MyDelegate : <span class="keyword">class</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123; </span><br><span class="line">   weak <span class="keyword">var</span> <span class="keyword">delegate</span> : MyDelegate?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到上面的protocol定义后面跟着的class。这意味着该protocol只能被class类型所遵守。<br>并且只有遵守了class protocol的delegate才能定义为weak。这是因为在Swift中,除了class能够遵守协议,枚举和结构同样能够遵守协议。而枚举和结构是值类型,不存在内存管理的问题。因此只需要class类型的变量声明为weak即可。</p>
<p>利用Swift的optional chaining,我们能够很方便的检查delegate是否为Nil,是否有实现某个方法:</p>
<p>以前我们要在Objective-C这样检查：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataSource &amp;&amp; [<span class="keyword">self</span>.dataSource <span class="symbol">respondsToSelector:</span><span class="variable">@selector</span>(<span class="symbol">titleForSegmentAtIndex:</span>)]) &#123;</span><br><span class="line">        thisSegmentTitle = [<span class="keyword">self</span>.dataSource <span class="symbol">titleForSegmentAtIndex:</span>index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Swift中,非常的优雅简洁。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> thisSementTitle = dataSource?.titleFroSegmentAtIndex?<span class="params">(index)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新特性:</p>
<p>在Swift中,protocol变得更加强大,灵活：</p>
<ol>
<li><p>class,enum,structure都可以遵守协议。</p>
</li>
<li><p>Extension也能遵守协议。利用它,我们不需要继承,也能够让系统的类也遵循我们的协议。</p>
</li>
</ol>
<p>例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">myProtocol</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>:<span class="title">myProtocol</span></span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还能够用这个特性来组织我们的代码结构,如下面的代码所示,将UITableViewDataSource的实现移到了Extension。使代码更清晰。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - UITableViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyViewcontroller</span>: <span class="title">UITableViewDataSource</span> </span>&#123; <span class="comment">// table view data source methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Protocol Oriented Programming<br>随着Swift2.0的发布,面向协议编程正式也加入到了Swift的编程范式。Cool.<br>这种编程方式通过怎样的语法特性支撑的呢？<br>那就是我们能够对协议进行扩展,也就是我们能够提供协议的默认实现,能够为协议添加新的方法与实现。<br>用前面的myProtocol为例子,我们在Swift里这样为它提供默认实现。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">myProtocol</span></span>&#123;</span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello world!"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们还能对系统原有的protocol进行扩展,大大增强了我们的想象空间。Swift2.0的实现也有很多地方用extension protocol的形式进行了重构。</p>
<p>面向协议编程能够展开说很多,在这里这简单地介绍了语法。</p>
<blockquote>
<p>有兴趣的朋友可以参考下面的资料：<br>Session 408: Protocol-Oriented Programming in Swift<br>IF YOU’RE SUBCLASSING, YOU’RE DOING IT WRONG.</p>
</blockquote>
<h4 id="7-Swift与Cocoa">7.Swift与Cocoa</h4><p>一门语言的的强大与否,除了自身优秀的特性外,很大一点还得依靠背后的框架。Swift直接采用苹果公司经营了很久的Cocoa框架。现在我们来看看使用Swift和Cocoa交互一些需要注意的地方。</p>
<ol>
<li>id与AnyObject<br>在Swift中,没有id类型,Swift用一个名字叫AnyObject的protocol来代表任意类型的对象。</li>
</ol>
<p><code>id myObject = [[UITableViewCell alloc]init];</code><br><code>var myObject: AnyObject = UITableViewCell()</code><br>我们知道id的类型直到运行时才能被确定,如果我们向一个对象发送一条不能响应的消息,就会导致crash。</p>
<p>我们可以利用Swift的语法特性来防止这样的错误:<br><code>myObject.method?()</code><br>如果myObject没有这个方法,就不会执行,类似检查delegate是否有实现代理方法。</p>
<p>在Swift中,在AnyObject上获取的property都是optional的。</p>
<ol>
<li><p>闭包<br>OC中的block在Swift中无缝地转换为闭包。函数实际上也是一种特殊的闭包。</p>
</li>
<li><p>错误处理<br>之前OC典型的错误处理步骤:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line"> <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"/path/to/file"</span>];</span><br><span class="line"> <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"> <span class="built_in">BOOL</span> success = [fileManager removeItemAtURL:URL error:&amp;error];</span><br><span class="line"> <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error<span class="variable">.domain</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在Swift中：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = NSFileManager.defaultManager() </span><br><span class="line"><span class="keyword">let</span> URL = NSURL.fileURLWithPath(<span class="string">"/path/to/file"</span>) <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> fileManager.removeItemAtURL(URL)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> NSError &#123;  <span class="keyword">print</span>(<span class="string">"Error: \(error.domain)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>KVO。<br>Swift支持KVO。但是KVO在Swift,个人觉得是不够优雅的,KVO在Swift只限支持继承NSObject的类,有其局限性,在这里就不介绍如何使用了。</li>
</ol>
<p>网上也出现了一些开源库来解决这样的问题。有兴趣可以参考一下:</p>
<blockquote>
<p>Observable-Swift</p>
</blockquote>
<p>KVO 在OS X中有Binding的能力,也就是我们能够将两个属性绑定在一起,一个属性变化,另外一个属性也会变化。对与UI和数据的同步更新很有帮助,也是MVVM架构的需求之一。之前已经眼馋这个特性很久了,虽然Swift没有原生带来支持,Swift支持的泛型编程给开源界带来许多新的想法。下面这个库就是实现binding的效果。</p>
<blockquote>
<p>Bond</p>
</blockquote>
<h4 id="8-总结">8.总结</h4><p>到这里就基本介绍完Swift当中最基本的语法和与Objective-C的对比和改进。</p>
<p>事实上Swift的世界相比OC的世界还有很多新鲜的东西等待我们去发现和总结,Swift带来的多范式编程也将给我们编程的架构和代码的组织带来更来的思考。而Swift也是一个不断变化,不断革新的语言。相信未来的发展和稳定性会更让我们惊喜。这篇文章也将随着Swift的更新而不断更新,同时限制篇幅,突出重点。</p>
<p>希望这篇文章能够给各位同行的小伙伴们快速了解和学习Swift提供一点帮助。有疏漏错误的地方欢迎直接提出。感谢。</p>
<blockquote>
<p>转自 <a href="https://github.com/100mango/zen" target="_blank" rel="external">https://github.com/100mango/zen</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS-swift/">iOS,swift</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-详解CALayer-和-UIView的区别和联系" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/03/详解CALayer-和-UIView的区别和联系/" class="article-date">
  	<time datetime="2015-09-03T12:45:12.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/03/详解CALayer-和-UIView的区别和联系/">详解CALayer 和 UIView的区别和联系</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>前面发了一篇iOS 面试的文章，在说到 UIView 和 CALayer 的区别和联系的时候，被喵神指出没有切中要点，所以这里就 CALayer 和 UIView 这个问题重新整理了下。这里会先分条解释，最后会在文章的结尾给出概括性总结。</p>
<h4 id="1-首先UIView可以响应事件，Layer不可以-">1.首先UIView可以响应事件，Layer不可以.</h4><p>UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。</p>
<p>在 UIResponder中定义了处理各种事件和事件传递的接口, 而 CALayer直接继承 NSObject，并没有相应的处理事件的接口。</p>
<p>下面列举一些处理触摸事件的接口</p>
<ul>
<li>– touchesBegan:withEvent:</li>
<li>– touchesMoved:withEvent:</li>
<li>– touchesEnded:withEvent:</li>
<li>– touchesCancelled:withEvent:<br>其实还有一些运动和远程控制事件等等，这里就不一一列举了。</li>
</ul>
<p>下面的两篇文章详细介绍了 iOS 事件的处理和传递</p>
<p>参考链接：</p>
<ol>
<li><a href="http://blog.csdn.net/chun799/article/details/8223612" target="_blank" rel="external">http://blog.csdn.net/chun799/article/details/8223612</a></li>
<li><a href="http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html" target="_blank" rel="external">http://yishuiliunian.gitbooks.io/implementate-tableview-to-understand-ios/content/uikit/1-1-2.html</a></li>
</ol>
<h4 id="2-View和CALayer的Frame映射及View如何创建CALayer-">2.View和CALayer的Frame映射及View如何创建CALayer.</h4><p>一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属性。（PS:center有些特列）为了证明这些，我做了如下的测试。</p>
<p>首先我自定义了两个类CustomView,CustomLayer分别继承 UIView 和 CALayer</p>
<p>在 CustomView 中重写了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [CustomLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenter:(<span class="built_in">CGPoint</span>)center</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setCenter:center];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBounds:(<span class="built_in">CGRect</span>)bounds</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setBounds:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在 CustomLayer中同样重写这些方法。只是 <code>setCenter</code>方法改成<code>setPosition</code>方法</p>
<p>我在两个类的初始化方法中都打下了断点<img src="/images/Snip20150820_12.png" alt="image"></p>
<p>首先我们会发现，我们在 [view initWithFrame] 的时候调用私有方法【UIView _createLayerWithFrame】去创建 CALayer。</p>
<p>然后我在创建 View 的时候，在 Layer 和 View 中Frame 相关的所有方法中都加上断点，可以看到大致如下的调用顺序如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[UIView _createLayerWithFrame]</span><br><span class="line">[Layer setBounds:bounds]</span><br><span class="line">[UIView setFrame：Frame]</span><br><span class="line">[Layer setFrame:frame]</span><br><span class="line">[Layer setPosition:position]</span><br><span class="line">[Layer setBounds:bounds]</span><br></pre></td></tr></table></figure></p>
<p>我发现在创建的过程只有调用了 Layer 的设置尺寸和位置的然而并没有调用View 的 <code>SetCenter</code> 和 <code>SetBounds</code> 方法。<br>然后我发现当我修改了 view的 <code>bounds.size</code> 或者 <code>bounds.origin</code> 的时候也只会调用上边 Layer的一些方法。所以我大胆的猜一下，View 的 Center 和 Bounds 只是直接返回layer 对应的 Position 和 Bounds.</p>
<p>View中frame getter方法，bounds和center，UIView并没有做什么工作；它只是简单的各自调用它底层的CALayer的frame，bounds和position方法。</p>
<p>关于 Frame 的理解参考：<a href="http://www.cocoachina.com/industry/20131209/7498.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20131209/7498.html</a></p>
<h4 id="3-UIView主要是对显示内容的管理而_CALayer_主要侧重显示内容的绘制。">3.UIView主要是对显示内容的管理而 CALayer 主要侧重显示内容的绘制。</h4><p>我在 UIView 和 CALayer 分别重写了父类的方法。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[UIView drawRect:rect]</span><span class="comment">//UIView    </span></span><br><span class="line"></span><br><span class="line"><span class="attr_selector">[CALayer display]</span><span class="comment">//CALayer</span></span><br></pre></td></tr></table></figure></p>
<p>然后我在上面两个方法加了断点，可以看到如下的执行。<br><img src="/images/Snip20150820_11.png" alt="image"></p>
<p>可以看到 UIView 是 CALayer 的CALayerDelegate，我猜测是在代理方法内部[UIView(CALayerDelegate) drawLayer:inContext]调用 UIView 的 DrawRect方法，从而绘制出了 UIView 的内容.</p>
<h4 id="4-在做_iOS_动画的时候，修改非_RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。">4.在做 iOS 动画的时候，修改非 RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会。</h4><p>对于每一个 UIView 都有一个 layer,把这个 layer 且称作RootLayer,而不是 View 的根 Layer的叫做 非 RootLayer。我们对UIView的属性修改时时不会产生默认动画，而对单独 layer属性直接修改会，这个默认动画的时间缺省值是0.25s.<br>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对为什么会这样做出了一个解释：</p>
<blockquote>
<p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p>
</blockquote>
<p>是因为任何可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 CAAction)。</p>
<p>layer 通过向它的 delegate 发送 actionForLayer:forKey: 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>
<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。</li>
<li>它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。</li>
<li>它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。<br>当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</li>
</ol>
<p>这部分的具体内容参考：<a href="http://objccn.io/issue-12-4/" target="_blank" rel="external">http://objccn.io/issue-12-4/</a></p>
<h3 id="总结">总结</h3><p>总接来说就是如下几点：</p>
<ul>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display</li>
<li>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</li>
<li>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</li>
<li>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</li>
</ul>
<h4 id="参考链接">参考链接</h4><p><a href="http://blog.csdn.net/weiwangchao_/article/details/7771538" target="_blank" rel="external">http://blog.csdn.net/weiwangchao_/article/details/7771538</a></p>
<blockquote>
<p>转自 <a href="http://www.jianshu.com/p/079e5cf0f014" target="_blank" rel="external">http://www.jianshu.com/p/079e5cf0f014</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS开发之UITableView性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/31/iOS开发之UITableView性能优化/" class="article-date">
  	<time datetime="2015-08-31T15:28:25.000Z" itemprop="datePublished">2015-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/iOS开发之UITableView性能优化/">iOS开发之UITableView性能优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面已经说过UITableView中的单元格cell是在显示到用户可视区域后创建的，那么如果用户往下滚动就会继续创建显示在屏幕上的单元格，如果用户向上滚动返回到查看过的内容时同样会重新创建之前已经创建过的单元格。如此一来即使UITableView的内容不是太多，如果用户反复的上下滚动，内存也会瞬间飙升，更何况很多时候UITableView的内容是很多的（例如微博展示列表，基本向下滚动是没有底限的）。</p>
<p>前面一节中我们曾经提到过如何优化UIScrollView，当时就是利用有限的UIImageView动态切换其内容来尽可能减少资源占用。同样的，在UITableView中也可以采用类似的方式，只是这时我们不是在滚动到指定位置后更改滚动的位置而是要将当前没有显示的Cell重新显示在将要显示的Cell的位置然后更新其内容。原因就是UITableView中的Cell结构布局可能是不同的，通过重新定位是不可取的，而是需要重用已经不再界面显示的已创建过的Cell。</p>
<p>当然，听起来这么做比较复杂，其实实现起来很简单，因为UITableView已经为我们实现了这种机制。在UITableView内部有一个缓存池，初始化时使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)方法指定一个可重用标识，就可以将这个cell放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的cell然后修改cell内容即可。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark返回每行的单元格</span></span><br><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="comment">//NSIndexPath是一个对象，记录了组和行信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成单元格(组：%i,行%i)"</span>,indexPath<span class="variable">.section</span>,indexPath<span class="variable">.row</span>);</span><br><span class="line">    KCContactGroup *group=_contacts[indexPath<span class="variable">.section</span>];</span><br><span class="line">    KCContact *contact=group<span class="variable">.contacts</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于此方法调用十分频繁，cell的标示声明成静态变量有利于性能优化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier=<span class="string">@"UITableViewCellIdentifierKey1"</span>;</span><br><span class="line">    <span class="comment">//首先根据标识去缓存池取</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    <span class="comment">//如果缓存池没有到则重新创建并放到缓存池中</span></span><br><span class="line">    <span class="keyword">if</span>(!cell)&#123;</span><br><span class="line">        cell=[[<span class="built_in">UITableViewCell</span> alloc]initWithStyle:<span class="built_in">UITableViewCellStyleValue1</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span>=[contact getName];</span><br><span class="line">    cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span>=contact<span class="variable">.phoneNumber</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cell:%@"</span>,cell);</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中已经打印了cell的地址，如果大家运行测试上下滚动UITableView会发现滚动时创建的cell地址是初始化时已经创建的。</p>
<p>这里再次给大家强调两点：</p>
<ul>
<li>-(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)方法调用很频繁，无论是初始化、上下滚动、刷新都会调用此方法，所有在这里执行的操作一定要注意性能；</li>
<li>可重用标识可以有多个，如果在UITableView中有多类结构不同的Cell，可以通过这个标识进行缓存和重新；</li>
</ul>
<blockquote>
<p>转 Kenshin Cui’s Blog</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tableview优化/">tableview优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-html5-audio-使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/30/html5-audio-使用/" class="article-date">
  	<time datetime="2015-08-29T16:02:33.000Z" itemprop="datePublished">2015-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/30/html5-audio-使用/">html5 audio 使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做html5 使用到了audio，发现audio在移动设备上面不能够自动播放<code>autoplay</code>属性没用</p>
<p>求解</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-怎么成为一名黑客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/27/怎么成为一名黑客/" class="article-date">
  	<time datetime="2015-08-27T15:10:14.000Z" itemprop="datePublished">2015-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/27/怎么成为一名黑客/">怎么成为一名黑客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我有不少黑客朋友。他们有的学医，有的学数学，有的学建筑，有的做安全之前的职业是开中巴。恩，当然，也有不少是计算机科班出身的。</p>
<p>这帮人，是怎么成为黑客的？</p>
<h4 id="会动脑">会动脑</h4><ul>
<li><p>最最重要的是「逆向思维」——所谓的「黑掉你，不在你关注的那个点上」（能独立思考，不人云亦云，善挖掘，不从众，懂大众心理，还懂得利用大众心理的「漏洞」）；</p>
</li>
<li><p>在网络攻防中找案例，我顺手搜了一个「自己打自己」的案例：简单一步即可扫描360内部系统安全漏洞（扫描器攻击技巧），出处为乌云：<a href="http://t.cn/RLeNiMY；" target="_blank" rel="external">http://t.cn/RLeNiMY；</a></p>
</li>
<li><p>逆向思维不仅仅适用于「暗黑领域」。实际上，无论你学的是什么，从事的是什么职业，这种思维模式都无比珍贵，拥有它，你有机会成为任意领域的黑客；</p>
</li>
<li><p>在军事上找类比，想想「马奇诺防线」，想想「围魏救赵」，再想想「黑掉你，不在你关注的那个点上」，你是不是领悟到了点什么？</p>
</li>
<li><p>一个漫画（出自 XKCD）：<br><img src="/images/42062-c7873b7151f31d5a.png" alt="图"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安全死宅想象中，自己的安全设计固若金汤：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑加密了，咱得砸个百万美金破掉它！</span><br><span class="line">恶人乙：嚓，想得美，是 <span class="number">4096</span> 位密码耶！</span><br><span class="line">恶人甲：倒霉，认栽吧，撤！</span><br><span class="line"></span><br><span class="line">真实世界里：</span><br><span class="line"></span><br><span class="line">恶人甲：哇靠，丫电脑居然加密！拿五美金买个扳手，扁他。扁到他说出密码为止！</span><br><span class="line">恶人乙：好咧。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>扁到他说出密码为止！恩，这就是我最推崇的思维能力（别领会错了，不是暴力，是不受你的规则限制）。</p>
<h4 id="肯学习">肯学习</h4><ul>
<li><p>那个学医的黑客（TK）在微博上说：漏洞产业很像玉石产业。漏洞生于脑，玉石出自矿。矿里有没有玉，要挖一挖。思路可不可行，要试一试。挖出矿石是不是玉，要开窗看。Crash 能不能变成 PoC，要调一调。矿石里的玉多大、什么成色，得整个磨开。PoC 好不好利用，要写成 Exploit。而后玉石雕成器，Exploit 写成真正的工具，会再价值大增；</p>
</li>
<li><p>挖、试、看、调、磨……各位看着各种黑客大赛，几秒攻破某某系统时，有没有想过台上一分钟，台下十年功？</p>
</li>
<li><p>我从业生涯中遇到的，真正笨和天才的人很少。有不少人「以为自己比实际上聪明」地走捷径，反而绕远，不如日拱一卒走得稳健长远；</p>
</li>
<li><p>如果你问：我肯学习，但是该学什么？怎么学？请参见第一条：「会动脑」。</p>
</li>
</ul>
<h4 id="重实践">重实践</h4><ul>
<li><p>纸上得来终觉浅。绝大多数人都是「听过很多道理，依然过不好这一生」的，路要自己走，错误要自己犯，一行行代码要自己写，一个个绕过限制的奇技淫巧要自己苦思冥想。突破了，收获就是自己的；</p>
</li>
<li><p>实践的方法很多，比如长期做一个开源软件（做之前请先动脑想清楚做什么、为什么做、值不值得长期做等一系列问题）、比如写文章记录自己的学习历程、比如把历史上著名的漏洞撸一遍并分享代码和心得……</p>
</li>
</ul>
<h4 id="走正道">走正道</h4><ul>
<li><p>玩黑客攻防这个行当，脑洞一旦开了，很容易发现不少地方可以快速挣钱。但「伸手」之前，请想清楚：会上瘾！尝过轻松来钱的滋味后，再想踏实做事就难了。</p>
</li>
<li><p>常在河边走，哪有不湿鞋。</p>
</li>
</ul>
<blockquote>
<p>转 <a href="http://www.jianshu.com/p/611b32c50fa2" target="_blank" rel="external">http://www.jianshu.com/p/611b32c50fa2</a></p>
</blockquote>
<p>最近一直想破机附近的wifi密码 ^_^</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-AVFoundation和-GPUImage初探" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/26/AVFoundation和-GPUImage初探/" class="article-date">
  	<time datetime="2015-08-26T15:21:58.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/26/AVFoundation和-GPUImage初探/">AVFoundation和 GPUImage初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>
<h4 id="AVFoundation的一些基本概念">AVFoundation的一些基本概念</h4><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。<br><img src="/images/ba81ca29gw1evcbinsawmj20qj0go0tt.jpg" alt="ba81ca29gw1evcbinsawmj20qj0go0tt"></p>
<h4 id="相关类">相关类</h4><ul>
<li>AVAsset</li>
<li>AVAssetTrack</li>
<li>AVComposition</li>
<li>AVVideoComposition</li>
<li>AVAudioMix</li>
<li>AVMutableAudioMixInputParameter</li>
<li>AVMutableVideoCompositionInstrution</li>
<li>AVMutableVideoCompositionLayerInstrution<br>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录<br>制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</li>
</ul>
<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。<br><img src="/images/ba81ca29gw1evcbjm927vj20jm0hsmzv.jpg" alt="ba81ca29gw1evcbjm927vj20jm0hsmzv"><br>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>
<p>typedef struct<br>{<br>CMTimeValue value;<br>CMTimeScale timescale;<br>CMTimeFlags flags;<br>CMTimeEpoch epoch;<br>} CMTime;<br>通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看这里。</p>
<h3 id="进阶">进阶</h3><h4 id="视频的录制">视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、<br>AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。<br><img src="capture.png"><br>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *<span class="keyword">array</span> = [output.metadta mutableCopy];</span><br><span class="line">AVMutableMetadataItem *<span class="literal">item</span> = [[AVMutableMetadataItem alloc] init];</span><br><span class="line"><span class="literal">item</span>.keyspace = ...;</span><br><span class="line"><span class="literal">item</span>.key = ...;</span><br><span class="line"><span class="literal">item</span>.<span class="keyword">value</span> = ...;</span><br><span class="line">[<span class="keyword">array</span> addObject:item];</span><br><span class="line">output.metadata = <span class="keyword">array</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">    session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[session beginConfiguration]</span>;</span><br><span class="line"><span class="comment">//移除某个输入源</span></span><br><span class="line"><span class="comment">//再添加某个输入源</span></span><br><span class="line"><span class="comment">//再为新添加的输入源进行必要的相关设置</span></span><br><span class="line"><span class="comment">//...其他操作</span></span><br><span class="line"><span class="attr_selector">[session commitConfiguration]</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现 captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput<span class="variable">.videoSettings</span> = newSettings;</span><br></pre></td></tr></table></figure>
<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span></span><br><span class="line">- (<span class="keyword">void</span>)yourCustomMethodName&#123;</span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">            session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(session canAddInput:input)&#123;</span><br><span class="line">        [session addInput:input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span>(session canAddOutput:output)&#123;</span><br><span class="line">        [session addOutput:output];</span><br><span class="line">    &#125;</span><br><span class="line">    output<span class="variable">.videoSettings</span> =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">    <span class="comment">//设置帧率(FPS),每秒15帧</span></span><br><span class="line">    output<span class="variable">.minFrameDuration</span> = CMTimeMake(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"CustomQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue)</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用来显示录制的实时画面</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:captureVideoPreviewLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户是否允许启用摄像头</span></span><br><span class="line">    [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Granted access to mediaType</span></span><br><span class="line">            [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">            [session startRunning];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span></span><br><span class="line">                                        message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span></span><br><span class="line">                                       delegate:<span class="keyword">self</span></span><br><span class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></span><br><span class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                    [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];</span><br><span class="line">NSURL *fileURL = ...;    <span class="comment">//存放位置</span></span><br><span class="line"><span class="comment">//指定代理</span></span><br><span class="line">[aMovieFileOutput <span class="string">startRecordingToOutputFileURL:</span>fileURL <span class="string">recordingDelegate:</span>delete];</span><br><span class="line"><span class="comment">//也可以为其指定outputSettings</span></span><br><span class="line">同样代理必须实现协议方法<span class="string">captureOutput:</span><span class="string">didFinishRecordingToOutputFileAtURL:</span><span class="string">fromConnections:</span><span class="string">error:</span>,</span><br></pre></td></tr></table></figure></p>
<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到更多。</p>
<h4 id="视频的剪辑">视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图<br><img src="/images/ba81ca29gw1evcblhcl2ej20p50eyjvj.jpg" alt="ba81ca29gw1evcblhcl2ej20p50eyjvj"></p>
<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。<br>关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见这里。</p>
<p>其中图中1，2，3用到的方法为<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[1]</span></span><br><span class="line"><span class="title">[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]</span></span><br><span class="line"><span class="title">[2]</span></span><br><span class="line"><span class="title">[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]</span><span class="comment">;`</span></span><br><span class="line"><span class="title">[3]</span></span><br><span class="line"><span class="title">[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]</span></span><br></pre></td></tr></table></figure></p>
<p>关于视频的剪辑的代码可以参见苹果给出的官方Demo以及Raywendrich上的两篇文章1,2。</p>
<h3 id="GPUImage">GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<h4 id="分段录制">分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Add</span> audio capture to the session. <span class="type">Adding</span> inputs <span class="keyword">and</span> outputs freezes </span><br><span class="line">//the capture session momentarily, so you can use this <span class="keyword">method</span> to add </span><br><span class="line">//the audio inputs <span class="keyword">and</span> outputs early, <span class="keyword">if</span> you’re going to <span class="type">set</span> the </span><br><span class="line">//audioEncodingTarget later. <span class="type">Returns</span> <span class="type">YES</span> <span class="keyword">is</span> the audio inputs <span class="keyword">and</span> </span><br><span class="line">//outputs were added, <span class="keyword">or</span> <span class="type">NO</span> <span class="keyword">if</span> they had already been added.</span><br><span class="line"></span><br><span class="line">-(<span class="type">BOOL</span>)addAudioInputsAndOutputs;</span><br></pre></td></tr></table></figure>
<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>
<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你分段录制的实现,GPUImageExtend。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>
<h4 id="所见即所得">所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>
<pre><code><span class="number">1.</span>使用GPUImageCropFilter,通过设置其cropRegion来裁出中间<span class="number">540</span>x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在<span class="number">0.0</span>~<span class="number">1.0</span>范围内,比如<span class="number">960</span>x540裁剪至中间<span class="number">540</span>x540部分则cropRegion为(<span class="number">0</span>,((<span class="number">960</span>-<span class="number">540</span>)/<span class="number">2</span>)/<span class="number">960</span>,<span class="number">1</span>,<span class="number">540</span>/<span class="number">960</span>)
<span class="number">2.</span>改变videoComposition的perferTransfom使其只显示中间的<span class="number">540</span>x540。
</code></pre><p>这样就完成了所见即所得。</p>
<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个issue和一些解决办法。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>
<h4 id="总结">总结</h4><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-UIButton-UIEdgeinsets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/UIButton-UIEdgeinsets/" class="article-date">
  	<time datetime="2015-08-25T15:51:55.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/UIButton-UIEdgeinsets/">UIButton中的三个UIEdgeInsets属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UIEdgeInsets是什么</p>
<p><code>UIEdgeInsets</code>是什么？我们点进去看一下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct UIEdgeInsets &#123;</span><br><span class="line">    CGFloat <span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>;  <span class="comment">// specify amount to inset (positive) for each of the edges. values can be negative to 'outset'</span></span><br><span class="line">&#125; UIEdgeInsets;</span><br><span class="line">UIEdgeInsets是个结构体类型。里面有四个参数，分别是：<span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</span><br></pre></td></tr></table></figure>
<p>哪三个UIEdgeInsets属性</p>
<p>不知道大家发现没有，UIButton里面有三个UIEdgeInsets属性，分别是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> contentEdgeInsets <span class="built_in">UI_APPEARANCE_SELECTOR</span>; <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure></p>
<p>contentEdgeInsets后面有个UI_APPEARANCE_SELECTOR是什么意思呢？</p>
<blockquote>
<p>提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。<br>举例，设置UIButton的contentEdgeInsets属性，可以直接调用：<br><code>[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> titleEdgeInsets;                <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> imageEdgeInsets;                <span class="comment">//default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-谁让APP工程师产生了泡沫？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/谁让APP工程师产生了泡沫？/" class="article-date">
  	<time datetime="2015-08-25T14:54:56.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/谁让APP工程师产生了泡沫？/">谁让APP工程师产生了泡沫？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两年移动互联网比较火，移动APP的开发人员也是比较紧缺。</p>
<p>面试了一个做APP的，能力很一般，态度也比较傲慢。最后感觉肯定不会用这个人了，但是出于验证自己想法的目的，还是很诚恳地以一个决定录取他的态度，和他交谈。</p>
<p>“刚才我问了你一些问题，可能比较偏，或者不是你所擅长的。我也是本着为公司负责的态度，问一些我们经常用到的问题。这一点请见谅。”，我说。</p>
<p>他说：“没事的，问的确实有点偏。实际工作中，根本用不到，用到了现查就行，网上好多例子，复制粘贴都能搞定！”。</p>
<p>我说，我们企业招一个人，你入职一个企业，是一个相互选择的事情。我问完你了，你对我们公司有什么想了解的。</p>
<p>他有点发楞，停顿了一会。我提示他，公司的业务发展，个人的提升空间，你的职业规划？</p>
<p>他说，噢，咱们公司是做什么的？</p>
<p>我回答道，我们主业务是做基于社区的O2O平台的，现在业务有几块，深度垂直做上门推拿服务，打通商家上下游做云商供应链，最终将打造一个庞大的社区服务生态体系。</p>
<p>他似乎没有听懂，依然发楞。</p>
<p>“还有什么想问的吗？”我问。</p>
<p>他似乎早想问，一直不好意思问，但是又不想在这浪费时间了，问道：“公司都有什么福利，年终奖是多少，加班费怎么算……”。</p>
<p>我都一一回答了。</p>
<p>沉默了一会。</p>
<p>我问道：“你能接受的最低待遇是多少？”</p>
<p>他说，就是简历上写的那些。</p>
<p>我死死地盯着他：“如果我给你降一千你愿意吗？”</p>
<p>他摇了摇头。</p>
<p>“降五百呢？”</p>
<p>他回答说：“我已经面试了四五家公司了，他们都要我，我也答应了。现在就是再面试几家，看看哪家更高。所以，我没必要……”，他向我耸肩，然后不说了。</p>
<p>我说，你要的这个数，在我们公司不算高，好多人都拿的比这个多呢。你去过的那几家公司，多少人？</p>
<p>他说，也得有，差不多，估计一百多人吧。</p>
<p>我问，做APP的多少人？</p>
<p>他回答，一两个，有的没有，我去了是第一个。</p>
<p>谁面试的你，我问。</p>
<p>有的是经理，有的是老板，都很希望我能快点入职。</p>
<p>我说，好的，我们会把你面试的情况和你做的作品评估一下，然后再联系你。</p>
<p>他走了。</p>
<p>这不是个例。</p>
<p>大多数年轻人都差不多这样。</p>
<p>他们没房没车没压力，以单纯的收入高低作为亲友间的炫耀和比较的资本。</p>
<p>让我陷入沉思的是，为什么一个近乎只能称得上操作和修理工的人，却顶着一个工程师的名号，可以到处要高价，而且还真有公司愿意给。享受能力所不匹配的东西，这显然是一种病态，结果必定可悲。谁赋予了他们这样的优厚际遇？或者，谁成心想害他们？</p>
<p>答案是这个飞速发展时代和无可奈何的企业。</p>
<p>移动互联网，这五个字可谓炙手可热。互联网+，又让这热度增上三分。好多公司都想搭上这艘船，捞一桶金，弄不巧还会成就一番霸业。</p>
<p>怎么搞？好多人都觉得移动互联网就是个APP。想踏入移动互联网，首先要搞一个APP出来，拿出去好说话嘛！这种想法就像是，我研发个POS机有一家银行了能做金融了一样。你的POS机之所以能刷卡转移资金，是因为后面还有一个银行体系支撑，来了钱给谁，扣的钱从哪里出，是有一套服务做支撑的。这套服务，相比一个POS机而言，大象和蚂蚁的关系。还不明白的话，去五金店买一个淋浴头，在太阳下试试会不会喷水，那个淋浴头就是业务中的APP。</p>
<p>好多小企业老板很明白政治和经济局势，但是不明白技术，他们觉得第一步先需要APP，其他的根据需求再说。于是，他们老板甚至亲自面试，随便聊聊天，要多少给多少就招进来了，先有人开个头再说呗。最后，发现不是这么一回事，有了淋浴头了还需要水管才能喷水，自己建供水系统太大，在小区建使用人群太少，连接卫生间的水管，跟自己又没啥关系。命长公司的干上半年，招的人也不专业，凑合随便弄一个出来，员工感觉老板瞎弄没有成就感，老板也感觉看错了人不出成绩。于是，一拍两散。</p>
<p>出来的这人再换工作，感觉自己没有被完全发挥出来，现在工作经验也涨了，薪水肯定也得涨。于是，又找到一个公司，老板一看，这人以前待遇都那么高，那老板肯定不傻，做了那么久了也有成果，我这又急需要人，再涨一段吧。这个公司干半年，和上一个公司一样循环，直到一个顶点。</p>
<p>这就造成了，个人技术没有实质提高，待遇却虚高。公司支出增加了，回报却没有增加。</p>
<p>这就是泡沫啊，在慢慢膨胀的泡沫。这泡沫在小企业中很明显，在中型以上企业中不明显。第一，因为中型企业都有专业的人才，这些人能判断和规划整个业务体系，不至于盲目。第二，也正是由于规范和专业，所以吸引了很多更看良性成长环境的有志之士。</p>
<p>泡沫，毕竟是泡沫，终有爆破的那一天。这个时间不会很长，3到5年。随着新技术慢慢变旧（当Android和IOS变成和C语言一样老），随着大批量的人才涌入和一些公司退出（十万开发者面对一千岗位），随着很多老板慢慢发现原理和真相（APP真的只是个终端）。我们再来设定一下，曾经那些在小公司频繁蹦来跳去的人，和那些在成熟部门茁壮成长的人，他们命运是不是会发生颠覆性的改变。</p>
<p>互联网行业不同于传统行业，不存在第二。最终的局面是巨头垄断和精细化小企业填补的局面。</p>
<p>其实公司和人历程都一样，都会遇到千奇百怪的事情，但是殊途同归平淡是真，最终都要踏实笃行。你一步一步地走，你眼看别人起高楼，你眼看别人宴宾客，你也眼看别人楼倒塌。</p>
<p>你也可以心想自己建起一座壁垒，固若金汤，经久不衰，称为经典。</p>
<blockquote>
<p>转 <a href="http://www.cnblogs.com/yinrq/p/4745784.html" target="_blank" rel="external">http://www.cnblogs.com/yinrq/p/4745784.html</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-减小iOS应用程序的大小" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/24/减小iOS应用程序的大小/" class="article-date">
  	<time datetime="2015-08-24T15:17:57.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/减小iOS应用程序的大小/">减小iOS应用程序的大小</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195" target="_blank" rel="external">Reducing the size of my App</a></p>
<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>
<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(减小iOS应用程序升级时所需下载的大小)(这与第一次安装使用的工作原理有所不同)。</p>
<h4 id="检查应用程序">检查应用程序</h4><p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>
<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>
<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这不同于升级)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>
<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>
<p>当让我们也可以通过使用: <code>Xcode的Archive命令来构造出.ipa文件——该文件与提交到App Store上的格式基本一致</code>。</p>
<h4 id="检查-ipa文件">检查<code>.ipa</code>文件</h4><p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>
<h4 id="iOS_App_Store相关因素">iOS App Store相关因素</h4><p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>
<blockquote>
<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>
<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>
</blockquote>
<h3 id="Build_Settings">Build Settings</h3><h4 id="编译选项">编译选项</h4><p>将build setting中的<code>Optimization Level</code>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，<code>Fastest, Smallest [-Os]</code>; 将<code>build setting</code> 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>
<blockquote>
<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>
</blockquote>
<h4 id="Target针对较少的CPUs">Target针对较少的CPUs</h4><p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>
<p>要想只设定特定类型的CPUs，可以修改<code>build setting</code>中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>
<h3 id="Assets">Assets</h3><h4 id="对应用程序做一个完整性检查">对应用程序做一个完整性检查</h4><p>利用<code>Inspecting Your App</code>中介绍的流程，对<code>.app bundle</code>做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>
<h4 id="将数据从代码中剥离出来">将数据从代码中剥离出来</h4><p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考iOS App Store Specific Considerations中的完整介绍。)</p>
<h3 id="Image_Assets">Image Assets</h3><h4 id="尽量使用8-bit图片">尽量使用8-bit图片</h4><p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>
<h4 id="针对32-bit的图片尽量使用高压缩的比率">针对32-bit的图片尽量使用高压缩的比率</h4><p>利用Adobe Photoshop的Save For Web可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用pngcrush来压缩.png图片。</p>
<h3 id="Audio_Assets">Audio Assets</h3><h4 id="音频的压缩">音频的压缩</h4><p>参考WWDC中的Audio Development for Games，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
<blockquote>
<p>转自 <a href="http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/" target="_blank" rel="external">破船之家</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS异步图片加载优化与常用开源库分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/" class="article-date">
  	<time datetime="2015-08-23T01:05:05.000Z" itemprop="datePublished">2015-08-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/">iOS异步图片加载优化与常用开源库分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="网络图片显示大体步骤:">网络图片显示大体步骤:</h4><ol>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐</li>
<li>CoreAnimation渲染解压缩过的位图<blockquote>
<p>以上4，5，6，7，8步是在UIImageView的setImage时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一些优化思路：</p>
<ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如SDWebImage使用category）</li>
<li>Core Data vs 文件存储</li>
<li>图片预下载</li>
</ul>
</li>
</ol>
<h4 id="2-1_关于异步图片下载:">2.1 关于异步图片下载:</h4><p><code>fastImageCache</code>主要针对于从磁盘文件读取并展示图片的极端优化，所以并没有集成异步图片下载的功能。这里主要来看看SDWebImage(AFNetWorking的基本类似)的实现方案：</p>
<h5 id="tableView中，异步图片下载任务的管理:">tableView中，异步图片下载任务的管理:</h5><p>我们知道，tableViewCell是有重用机制的，也就是说，内存中只有当前可见的cell数目的实例，滑动的时候，新显示cell会重用被滑出的cell对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<h5 id="SDWebImage提供的UIImageView扩展的解决方案：">SDWebImage提供的UIImageView扩展的解决方案：</h5><p>imageView对象会关联一个下载列表（列表是给AnimationImages用的，这个时候会下载多张图片），当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</p>
<p>同时，SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取<code>LIFO</code>策略的，具体是在添加下载任务的时候，将上次添加的下载任务添加依赖为新添加的下载任务。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">wself.downloadQueue</span> addOperation:operation]<span class="comment">;</span></span><br><span class="line">if <span class="list">(<span class="keyword">wself.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder)</span> &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation<span class="variable">'s</span> dependency</span><br><span class="line">    <span class="list">[<span class="keyword">wself.lastAddedOperation</span> addDependency:operation]<span class="comment">;</span></span><br><span class="line">    wself.lastAddedOperation = operation<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
</blockquote>
<h5 id="另外一种解决方案是：">另外一种解决方案是：</h5><p>imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。</p>
<p>同时，仍然管理一个执行队列，为了避免占用太多的资源，通常会对执行队列设置一个最大的并发量。此外，为了保证LIFO的下载策略，可以自己维持一个等待队列，每次下载任务开始的时候，将后进入的下载任务插入到等待队列的前面。</p>
<p>iOS异步任务一般有3种实现方式:</p>
<ul>
<li>NSOperationQueue</li>
<li>GCD</li>
<li>NSThread<br>这几种方式就不细说了，SDWebImage是通过自定义NSOperation来抽象下载任务的，并结合了GCD来做一些主线程与子线程的切换。具体异步下载的实现，AFNetworking与SDWebImage都是十分优秀的代码，有兴趣的可以深入看看源码。<h4 id="2-2_关于图片解压缩:">2.2 关于图片解压缩:</h4><blockquote>
<p>图片来源 针对app自带的图片，xcode在编译的时候会对png图片进行<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fartori.us%2Foptimized-png-in-xcode%2F" target="_blank" rel="external">优化</a>（据说是通过<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>这个开源的工具来优化），这样在显示的时候就会有一些比较好的体验。 对于从internet上面下载的图片，多数情况下，是需要做解压缩后，才能渲染到屏幕上的。</p>
</blockquote>
</li>
</ul>
<h5 id="通用的解压缩方案">通用的解压缩方案</h5><blockquote>
<p>主体的思路是在子线程，将原始的图片渲染成一张的新的可以字节显示的图片，来获取一个解压缩过的图片</p>
</blockquote>
<p>基本上比较流行的一些开源库都先后支持了在异步线程完成图片的解压缩，并对解压缩过后的图片进行缓存。</p>
<p>这么做的优点是在<code>setImage</code>的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。<br>比如1张50<em>50像素的图片，在<code>retina</code>的屏幕下所占用的空间为`100 </em> 100 * 4 ~ 40KB`</p>
<p>下面的代码是<code>SDWebImage</code>的解决方案:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (image<span class="variable">.images</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not decode animated images</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef));</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = imageSize&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> infoMask = (bitmapInfo &amp; k<span class="built_in">CGBitmapAlphaInfoMask</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> anyNonAlpha = (infoMask == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGBitmapContextCreate doesn't support kCGImageAlphaNone with RGB.</span></span><br><span class="line">    <span class="comment">// https://developer.apple.com/library/mac/#qa/qa1037/_index.html</span></span><br><span class="line">    <span class="keyword">if</span> (infoMask == k<span class="built_in">CGImageAlphaNone</span> &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set noneSkipFirst.</span></span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaNoneSkipFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// Some PNGs tell us they have alpha but only 3 components. Odd.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!anyNonAlpha &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaPremultipliedFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It calculates the bytes-per-row based on the bitsPerComponent and width arguments.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">            imageSize<span class="variable">.width</span>,</span><br><span class="line">            imageSize<span class="variable">.height</span>,</span><br><span class="line">            <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            colorSpace,</span><br><span class="line">            bitmapInfo);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If failed, return undecompressed image</span></span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *decompressedImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:decompressedImageRef scale:image<span class="variable">.scale</span> orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</span><br><span class="line">    <span class="keyword">return</span> decompressedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3_关于字节对齐">2.3 关于字节对齐</h5><p>SDWebImage与AFNetworking都没有对第7点做优化，FastImageCache相对与其他的开源库，则对第5点与第7点做了优化。这里我们谈谈第七点，关于图片数据的字节对齐。</p>
<blockquote>
<p>Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
</blockquote>
<p><img src="1.png"></p>
<p>从代码上来看，主要是在创建上图解码的过程中，<code>CGBitmapContextCreate</code>函数的<code>bytesPerRow</code>参数必须传64的倍数。</p>
<p>比较各个开源框架的代码，可以看到SDWebImage与AFNetworking的该参数都传的是0，即让系统自动来计算该值（那为何系统自动计算的时候不让图片数据字节就字节对齐呢？）。</p>
<h5 id="2-4_关于第3，4点，内存级别拷贝">2.4 关于第3，4点，内存级别拷贝</h5><p>以上3个开源库中，FastImageCache对这一点做了很大的优化，其他的2个开源库则未关注这一点。这一块木有深入研究，就引用一下FastImageCache团队对该点的一些说明。有能力的可以去看看原文章(英文): <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">here</a></p>
<blockquote>
<p>内存映射<br>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高</p>
</blockquote>
<h5 id="2-5_关于第二步图片处理（裁剪，边框等）">2.5 关于第二步图片处理（裁剪，边框等）</h5><p>一般情况下，对于下载下来的图片我们可能想要做一些处理，比如说做一些缩放，裁剪，或者添加圆角等等。</p>
<p>对于比较通用的缩放，或者圆角等功能，可以集成到控件本身。不过，提供一个接口出来，让使用者能够有机会对下载下来的图片做一些其他的特殊处理是有必要的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** SDWebImage</span><br><span class="line"> * Allows <span class="keyword">to</span> transform <span class="keyword">the</span> image immediately <span class="keyword">after</span> <span class="keyword">it</span> has been downloaded <span class="keyword">and</span> just <span class="keyword">before</span> <span class="keyword">to</span> cache <span class="keyword">it</span> <span class="function_start"><span class="keyword">on</span></span> disk <span class="keyword">and</span> memory.</span><br><span class="line"> * NOTE: This method <span class="keyword">is</span> called <span class="keyword">from</span> a <span class="keyword">global</span> queue <span class="keyword">in</span> order <span class="keyword">to</span> <span class="keyword">not</span> <span class="keyword">to</span> block <span class="keyword">the</span> main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param image        The image <span class="keyword">to</span> transform</span><br><span class="line"> * @param imageURL     The url <span class="keyword">of</span> <span class="keyword">the</span> image <span class="keyword">to</span> transform</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> The transformed image object.</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h5 id="2-6_其他（诸如图片预下载，gif支持等等,下载进度条）">2.6 其他（诸如图片预下载，gif支持等等,下载进度条）</h5><p>待补充</p>
<ol>
<li>常用的开源库对比</li>
</ol>
<table>
<thead>
<tr>
<th>tip</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">AFNetworking</th>
<th style="text-align:right">FastImageCache</th>
</tr>
</thead>
<tbody>
<tr>
<td>异步下载图片</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>子线程解压缩</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>子线程图片处理(缩放，圆角等)</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>存储解压缩后的位图</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>内存级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>磁盘级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>UIImageView category</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>减少内存级别的拷贝</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>接口易用性</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:right">*</td>
</tr>
</tbody>
</table>
<p>参考资料<br><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache-github</a><br><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage-github</a><br><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking-github</a><br><a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">File System vs Core Data: the image cache test</a><br><a href="https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/" target="_blank" rel="external">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a><br><a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a><br><a href="http://blog.cnbang.net/tech/2578/?utm_source=tuicool" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 苹果
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>