<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>白色键盘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写博客，记录重要知识，iOS学习">
<meta property="og:type" content="website">
<meta property="og:title" content="白色键盘">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="白色键盘">
<meta property="og:description" content="写博客，记录重要知识，iOS学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白色键盘">
<meta name="twitter:description" content="写博客，记录重要知识，iOS学习">
  
    <link rel="alternative" href="/atom.xml" title="白色键盘" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">苹果</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">苹果</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/images/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">苹果</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-AVFoundation和-GPUImage初探" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/26/AVFoundation和-GPUImage初探/" class="article-date">
  	<time datetime="2015-08-26T15:21:58.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/26/AVFoundation和-GPUImage初探/">AVFoundation和 GPUImage初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>
<h4 id="AVFoundation的一些基本概念">AVFoundation的一些基本概念</h4><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。<br><img src="ba81ca29gw1evcbinsawmj20qj0go0tt.jpg"></p>
<h4 id="相关类">相关类</h4><ul>
<li>AVAsset</li>
<li>AVAssetTrack</li>
<li>AVComposition</li>
<li>AVVideoComposition</li>
<li>AVAudioMix</li>
<li>AVMutableAudioMixInputParameter</li>
<li>AVMutableVideoCompositionInstrution</li>
<li>AVMutableVideoCompositionLayerInstrution<br>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录<br>制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</li>
</ul>
<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。<br><img src="ba81ca29gw1evcbjm927vj20jm0hsmzv.jpg"><br>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>
<p>typedef struct<br>{<br>CMTimeValue value;<br>CMTimeScale timescale;<br>CMTimeFlags flags;<br>CMTimeEpoch epoch;<br>} CMTime;<br>通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看这里。</p>
<h3 id="进阶">进阶</h3><h4 id="视频的录制">视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、<br>AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。<br><img src="capture.png"><br>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *<span class="keyword">array</span> = [output.metadta mutableCopy];</span><br><span class="line">AVMutableMetadataItem *<span class="literal">item</span> = [[AVMutableMetadataItem alloc] init];</span><br><span class="line"><span class="literal">item</span>.keyspace = ...;</span><br><span class="line"><span class="literal">item</span>.key = ...;</span><br><span class="line"><span class="literal">item</span>.<span class="keyword">value</span> = ...;</span><br><span class="line">[<span class="keyword">array</span> addObject:item];</span><br><span class="line">output.metadata = <span class="keyword">array</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">    session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//设置失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[session beginConfiguration]</span>;</span><br><span class="line"><span class="comment">//移除某个输入源</span></span><br><span class="line"><span class="comment">//再添加某个输入源</span></span><br><span class="line"><span class="comment">//再为新添加的输入源进行必要的相关设置</span></span><br><span class="line"><span class="comment">//...其他操作</span></span><br><span class="line"><span class="attr_selector">[session commitConfiguration]</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现 captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput<span class="variable">.videoSettings</span> = newSettings;</span><br></pre></td></tr></table></figure>
<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span></span><br><span class="line">- (<span class="keyword">void</span>)yourCustomMethodName&#123;</span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </span><br><span class="line"></span><br><span class="line">            session<span class="variable">.sessionPreset</span> = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(session canAddInput:input)&#123;</span><br><span class="line">        [session addInput:input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span>(session canAddOutput:output)&#123;</span><br><span class="line">        [session addOutput:output];</span><br><span class="line">    &#125;</span><br><span class="line">    output<span class="variable">.videoSettings</span> =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">    <span class="comment">//设置帧率(FPS),每秒15帧</span></span><br><span class="line">    output<span class="variable">.minFrameDuration</span> = CMTimeMake(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"CustomQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue)</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用来显示录制的实时画面</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:captureVideoPreviewLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户是否允许启用摄像头</span></span><br><span class="line">    [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Granted access to mediaType</span></span><br><span class="line">            [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">            [session startRunning];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span></span><br><span class="line">                                        message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span></span><br><span class="line">                                       delegate:<span class="keyword">self</span></span><br><span class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></span><br><span class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                    [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];</span><br><span class="line">NSURL *fileURL = ...;    <span class="comment">//存放位置</span></span><br><span class="line"><span class="comment">//指定代理</span></span><br><span class="line">[aMovieFileOutput <span class="string">startRecordingToOutputFileURL:</span>fileURL <span class="string">recordingDelegate:</span>delete];</span><br><span class="line"><span class="comment">//也可以为其指定outputSettings</span></span><br><span class="line">同样代理必须实现协议方法<span class="string">captureOutput:</span><span class="string">didFinishRecordingToOutputFileAtURL:</span><span class="string">fromConnections:</span><span class="string">error:</span>,</span><br></pre></td></tr></table></figure></p>
<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到更多。</p>
<h4 id="视频的剪辑">视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图<br><img src="ba81ca29gw1evcblhcl2ej20p50eyjvj.jpg"></p>
<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。<br>关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见这里。</p>
<p>其中图中1，2，3用到的方法为<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[1]</span></span><br><span class="line"><span class="title">[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]</span></span><br><span class="line"><span class="title">[2]</span></span><br><span class="line"><span class="title">[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]</span><span class="comment">;`</span></span><br><span class="line"><span class="title">[3]</span></span><br><span class="line"><span class="title">[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]</span></span><br></pre></td></tr></table></figure></p>
<p>关于视频的剪辑的代码可以参见苹果给出的官方Demo以及Raywendrich上的两篇文章1,2。</p>
<h3 id="GPUImage">GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<h4 id="分段录制">分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">Add</span> audio capture to the session. <span class="type">Adding</span> inputs <span class="keyword">and</span> outputs freezes </span><br><span class="line">//the capture session momentarily, so you can use this <span class="keyword">method</span> to add </span><br><span class="line">//the audio inputs <span class="keyword">and</span> outputs early, <span class="keyword">if</span> you’re going to <span class="type">set</span> the </span><br><span class="line">//audioEncodingTarget later. <span class="type">Returns</span> <span class="type">YES</span> <span class="keyword">is</span> the audio inputs <span class="keyword">and</span> </span><br><span class="line">//outputs were added, <span class="keyword">or</span> <span class="type">NO</span> <span class="keyword">if</span> they had already been added.</span><br><span class="line"></span><br><span class="line">-(<span class="type">BOOL</span>)addAudioInputsAndOutputs;</span><br></pre></td></tr></table></figure>
<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>
<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你分段录制的实现,GPUImageExtend。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>
<h4 id="所见即所得">所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>
<pre><code><span class="number">1.</span>使用GPUImageCropFilter,通过设置其cropRegion来裁出中间<span class="number">540</span>x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在<span class="number">0.0</span>~<span class="number">1.0</span>范围内,比如<span class="number">960</span>x540裁剪至中间<span class="number">540</span>x540部分则cropRegion为(<span class="number">0</span>,((<span class="number">960</span>-<span class="number">540</span>)/<span class="number">2</span>)/<span class="number">960</span>,<span class="number">1</span>,<span class="number">540</span>/<span class="number">960</span>)
<span class="number">2.</span>改变videoComposition的perferTransfom使其只显示中间的<span class="number">540</span>x540。
</code></pre><p>这样就完成了所见即所得。</p>
<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个issue和一些解决办法。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>
<h4 id="总结">总结</h4><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-UIButton-UIEdgeinsets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/UIButton-UIEdgeinsets/" class="article-date">
  	<time datetime="2015-08-25T15:51:55.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/UIButton-UIEdgeinsets/">UIButton中的三个UIEdgeInsets属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UIEdgeInsets是什么</p>
<p><code>UIEdgeInsets</code>是什么？我们点进去看一下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct UIEdgeInsets &#123;</span><br><span class="line">    CGFloat <span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>;  <span class="comment">// specify amount to inset (positive) for each of the edges. values can be negative to 'outset'</span></span><br><span class="line">&#125; UIEdgeInsets;</span><br><span class="line">UIEdgeInsets是个结构体类型。里面有四个参数，分别是：<span class="attribute">top</span>, <span class="attribute">left</span>, <span class="attribute">bottom</span>, <span class="attribute">right</span>。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</span><br></pre></td></tr></table></figure>
<p>哪三个UIEdgeInsets属性</p>
<p>不知道大家发现没有，UIButton里面有三个UIEdgeInsets属性，分别是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> contentEdgeInsets <span class="built_in">UI_APPEARANCE_SELECTOR</span>; <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure></p>
<p>contentEdgeInsets后面有个UI_APPEARANCE_SELECTOR是什么意思呢？</p>
<blockquote>
<p>提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。<br>举例，设置UIButton的contentEdgeInsets属性，可以直接调用：<br><code>[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];</code></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> titleEdgeInsets;                <span class="comment">// default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)          <span class="built_in">UIEdgeInsets</span> imageEdgeInsets;                <span class="comment">//default is UIEdgeInsetsZero</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-谁让APP工程师产生了泡沫？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/谁让APP工程师产生了泡沫？/" class="article-date">
  	<time datetime="2015-08-25T14:54:56.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/谁让APP工程师产生了泡沫？/">谁让APP工程师产生了泡沫？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两年移动互联网比较火，移动APP的开发人员也是比较紧缺。</p>
<p>面试了一个做APP的，能力很一般，态度也比较傲慢。最后感觉肯定不会用这个人了，但是出于验证自己想法的目的，还是很诚恳地以一个决定录取他的态度，和他交谈。</p>
<p>“刚才我问了你一些问题，可能比较偏，或者不是你所擅长的。我也是本着为公司负责的态度，问一些我们经常用到的问题。这一点请见谅。”，我说。</p>
<p>他说：“没事的，问的确实有点偏。实际工作中，根本用不到，用到了现查就行，网上好多例子，复制粘贴都能搞定！”。</p>
<p>我说，我们企业招一个人，你入职一个企业，是一个相互选择的事情。我问完你了，你对我们公司有什么想了解的。</p>
<p>他有点发楞，停顿了一会。我提示他，公司的业务发展，个人的提升空间，你的职业规划？</p>
<p>他说，噢，咱们公司是做什么的？</p>
<p>我回答道，我们主业务是做基于社区的O2O平台的，现在业务有几块，深度垂直做上门推拿服务，打通商家上下游做云商供应链，最终将打造一个庞大的社区服务生态体系。</p>
<p>他似乎没有听懂，依然发楞。</p>
<p>“还有什么想问的吗？”我问。</p>
<p>他似乎早想问，一直不好意思问，但是又不想在这浪费时间了，问道：“公司都有什么福利，年终奖是多少，加班费怎么算……”。</p>
<p>我都一一回答了。</p>
<p>沉默了一会。</p>
<p>我问道：“你能接受的最低待遇是多少？”</p>
<p>他说，就是简历上写的那些。</p>
<p>我死死地盯着他：“如果我给你降一千你愿意吗？”</p>
<p>他摇了摇头。</p>
<p>“降五百呢？”</p>
<p>他回答说：“我已经面试了四五家公司了，他们都要我，我也答应了。现在就是再面试几家，看看哪家更高。所以，我没必要……”，他向我耸肩，然后不说了。</p>
<p>我说，你要的这个数，在我们公司不算高，好多人都拿的比这个多呢。你去过的那几家公司，多少人？</p>
<p>他说，也得有，差不多，估计一百多人吧。</p>
<p>我问，做APP的多少人？</p>
<p>他回答，一两个，有的没有，我去了是第一个。</p>
<p>谁面试的你，我问。</p>
<p>有的是经理，有的是老板，都很希望我能快点入职。</p>
<p>我说，好的，我们会把你面试的情况和你做的作品评估一下，然后再联系你。</p>
<p>他走了。</p>
<p>这不是个例。</p>
<p>大多数年轻人都差不多这样。</p>
<p>他们没房没车没压力，以单纯的收入高低作为亲友间的炫耀和比较的资本。</p>
<p>让我陷入沉思的是，为什么一个近乎只能称得上操作和修理工的人，却顶着一个工程师的名号，可以到处要高价，而且还真有公司愿意给。享受能力所不匹配的东西，这显然是一种病态，结果必定可悲。谁赋予了他们这样的优厚际遇？或者，谁成心想害他们？</p>
<p>答案是这个飞速发展时代和无可奈何的企业。</p>
<p>移动互联网，这五个字可谓炙手可热。互联网+，又让这热度增上三分。好多公司都想搭上这艘船，捞一桶金，弄不巧还会成就一番霸业。</p>
<p>怎么搞？好多人都觉得移动互联网就是个APP。想踏入移动互联网，首先要搞一个APP出来，拿出去好说话嘛！这种想法就像是，我研发个POS机有一家银行了能做金融了一样。你的POS机之所以能刷卡转移资金，是因为后面还有一个银行体系支撑，来了钱给谁，扣的钱从哪里出，是有一套服务做支撑的。这套服务，相比一个POS机而言，大象和蚂蚁的关系。还不明白的话，去五金店买一个淋浴头，在太阳下试试会不会喷水，那个淋浴头就是业务中的APP。</p>
<p>好多小企业老板很明白政治和经济局势，但是不明白技术，他们觉得第一步先需要APP，其他的根据需求再说。于是，他们老板甚至亲自面试，随便聊聊天，要多少给多少就招进来了，先有人开个头再说呗。最后，发现不是这么一回事，有了淋浴头了还需要水管才能喷水，自己建供水系统太大，在小区建使用人群太少，连接卫生间的水管，跟自己又没啥关系。命长公司的干上半年，招的人也不专业，凑合随便弄一个出来，员工感觉老板瞎弄没有成就感，老板也感觉看错了人不出成绩。于是，一拍两散。</p>
<p>出来的这人再换工作，感觉自己没有被完全发挥出来，现在工作经验也涨了，薪水肯定也得涨。于是，又找到一个公司，老板一看，这人以前待遇都那么高，那老板肯定不傻，做了那么久了也有成果，我这又急需要人，再涨一段吧。这个公司干半年，和上一个公司一样循环，直到一个顶点。</p>
<p>这就造成了，个人技术没有实质提高，待遇却虚高。公司支出增加了，回报却没有增加。</p>
<p>这就是泡沫啊，在慢慢膨胀的泡沫。这泡沫在小企业中很明显，在中型以上企业中不明显。第一，因为中型企业都有专业的人才，这些人能判断和规划整个业务体系，不至于盲目。第二，也正是由于规范和专业，所以吸引了很多更看良性成长环境的有志之士。</p>
<p>泡沫，毕竟是泡沫，终有爆破的那一天。这个时间不会很长，3到5年。随着新技术慢慢变旧（当Android和IOS变成和C语言一样老），随着大批量的人才涌入和一些公司退出（十万开发者面对一千岗位），随着很多老板慢慢发现原理和真相（APP真的只是个终端）。我们再来设定一下，曾经那些在小公司频繁蹦来跳去的人，和那些在成熟部门茁壮成长的人，他们命运是不是会发生颠覆性的改变。</p>
<p>互联网行业不同于传统行业，不存在第二。最终的局面是巨头垄断和精细化小企业填补的局面。</p>
<p>其实公司和人历程都一样，都会遇到千奇百怪的事情，但是殊途同归平淡是真，最终都要踏实笃行。你一步一步地走，你眼看别人起高楼，你眼看别人宴宾客，你也眼看别人楼倒塌。</p>
<p>你也可以心想自己建起一座壁垒，固若金汤，经久不衰，称为经典。</p>
<blockquote>
<p>转 <a href="http://www.cnblogs.com/yinrq/p/4745784.html" target="_blank" rel="external">http://www.cnblogs.com/yinrq/p/4745784.html</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-减小iOS应用程序的大小" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/24/减小iOS应用程序的大小/" class="article-date">
  	<time datetime="2015-08-24T15:17:57.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/减小iOS应用程序的大小/">减小iOS应用程序的大小</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195" target="_blank" rel="external">Reducing the size of my App</a></p>
<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>
<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(减小iOS应用程序升级时所需下载的大小)(这与第一次安装使用的工作原理有所不同)。</p>
<h4 id="检查应用程序">检查应用程序</h4><p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>
<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>
<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这不同于升级)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>
<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>
<p>当让我们也可以通过使用: <code>Xcode的Archive命令来构造出.ipa文件——该文件与提交到App Store上的格式基本一致</code>。</p>
<h4 id="检查-ipa文件">检查<code>.ipa</code>文件</h4><p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>
<h4 id="iOS_App_Store相关因素">iOS App Store相关因素</h4><p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>
<blockquote>
<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>
<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>
</blockquote>
<h3 id="Build_Settings">Build Settings</h3><h4 id="编译选项">编译选项</h4><p>将build setting中的<code>Optimization Level</code>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，<code>Fastest, Smallest [-Os]</code>; 将<code>build setting</code> 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>
<blockquote>
<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>
</blockquote>
<h4 id="Target针对较少的CPUs">Target针对较少的CPUs</h4><p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>
<p>要想只设定特定类型的CPUs，可以修改<code>build setting</code>中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>
<h3 id="Assets">Assets</h3><h4 id="对应用程序做一个完整性检查">对应用程序做一个完整性检查</h4><p>利用<code>Inspecting Your App</code>中介绍的流程，对<code>.app bundle</code>做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>
<h4 id="将数据从代码中剥离出来">将数据从代码中剥离出来</h4><p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考iOS App Store Specific Considerations中的完整介绍。)</p>
<h3 id="Image_Assets">Image Assets</h3><h4 id="尽量使用8-bit图片">尽量使用8-bit图片</h4><p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>
<h4 id="针对32-bit的图片尽量使用高压缩的比率">针对32-bit的图片尽量使用高压缩的比率</h4><p>利用Adobe Photoshop的Save For Web可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用pngcrush来压缩.png图片。</p>
<h3 id="Audio_Assets">Audio Assets</h3><h4 id="音频的压缩">音频的压缩</h4><p>参考WWDC中的Audio Development for Games，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
<blockquote>
<p>转自 <a href="http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/" target="_blank" rel="external">破船之家</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS异步图片加载优化与常用开源库分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/" class="article-date">
  	<time datetime="2015-08-23T01:05:05.000Z" itemprop="datePublished">2015-08-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/23/iOS异步图片加载优化与常用开源库分析/">iOS异步图片加载优化与常用开源库分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h4 id="网络图片显示大体步骤:">网络图片显示大体步骤:</h4><ol>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐</li>
<li>CoreAnimation渲染解压缩过的位图<blockquote>
<p>以上4，5，6，7，8步是在UIImageView的setImage时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一些优化思路：</p>
<ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如SDWebImage使用category）</li>
<li>Core Data vs 文件存储</li>
<li>图片预下载</li>
</ul>
</li>
</ol>
<h4 id="2-1_关于异步图片下载:">2.1 关于异步图片下载:</h4><p><code>fastImageCache</code>主要针对于从磁盘文件读取并展示图片的极端优化，所以并没有集成异步图片下载的功能。这里主要来看看SDWebImage(AFNetWorking的基本类似)的实现方案：</p>
<h5 id="tableView中，异步图片下载任务的管理:">tableView中，异步图片下载任务的管理:</h5><p>我们知道，tableViewCell是有重用机制的，也就是说，内存中只有当前可见的cell数目的实例，滑动的时候，新显示cell会重用被滑出的cell对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<h5 id="SDWebImage提供的UIImageView扩展的解决方案：">SDWebImage提供的UIImageView扩展的解决方案：</h5><p>imageView对象会关联一个下载列表（列表是给AnimationImages用的，这个时候会下载多张图片），当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</p>
<p>同时，SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取<code>LIFO</code>策略的，具体是在添加下载任务的时候，将上次添加的下载任务添加依赖为新添加的下载任务。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">wself.downloadQueue</span> addOperation:operation]<span class="comment">;</span></span><br><span class="line">if <span class="list">(<span class="keyword">wself.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder)</span> &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation<span class="variable">'s</span> dependency</span><br><span class="line">    <span class="list">[<span class="keyword">wself.lastAddedOperation</span> addDependency:operation]<span class="comment">;</span></span><br><span class="line">    wself.lastAddedOperation = operation<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
</blockquote>
<h5 id="另外一种解决方案是：">另外一种解决方案是：</h5><p>imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。</p>
<p>同时，仍然管理一个执行队列，为了避免占用太多的资源，通常会对执行队列设置一个最大的并发量。此外，为了保证LIFO的下载策略，可以自己维持一个等待队列，每次下载任务开始的时候，将后进入的下载任务插入到等待队列的前面。</p>
<p>iOS异步任务一般有3种实现方式:</p>
<ul>
<li>NSOperationQueue</li>
<li>GCD</li>
<li>NSThread<br>这几种方式就不细说了，SDWebImage是通过自定义NSOperation来抽象下载任务的，并结合了GCD来做一些主线程与子线程的切换。具体异步下载的实现，AFNetworking与SDWebImage都是十分优秀的代码，有兴趣的可以深入看看源码。<h4 id="2-2_关于图片解压缩:">2.2 关于图片解压缩:</h4><blockquote>
<p>图片来源 针对app自带的图片，xcode在编译的时候会对png图片进行<a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fartori.us%2Foptimized-png-in-xcode%2F" target="_blank" rel="external">优化</a>（据说是通过<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>这个开源的工具来优化），这样在显示的时候就会有一些比较好的体验。 对于从internet上面下载的图片，多数情况下，是需要做解压缩后，才能渲染到屏幕上的。</p>
</blockquote>
</li>
</ul>
<h5 id="通用的解压缩方案">通用的解压缩方案</h5><blockquote>
<p>主体的思路是在子线程，将原始的图片渲染成一张的新的可以字节显示的图片，来获取一个解压缩过的图片</p>
</blockquote>
<p>基本上比较流行的一些开源库都先后支持了在异步线程完成图片的解压缩，并对解压缩过后的图片进行缓存。</p>
<p>这么做的优点是在<code>setImage</code>的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。<br>比如1张50<em>50像素的图片，在<code>retina</code>的屏幕下所占用的空间为`100 </em> 100 * 4 ~ 40KB`</p>
<p>下面的代码是<code>SDWebImage</code>的解决方案:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (image<span class="variable">.images</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not decode animated images</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef));</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = imageSize&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> infoMask = (bitmapInfo &amp; k<span class="built_in">CGBitmapAlphaInfoMask</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> anyNonAlpha = (infoMask == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGBitmapContextCreate doesn't support kCGImageAlphaNone with RGB.</span></span><br><span class="line">    <span class="comment">// https://developer.apple.com/library/mac/#qa/qa1037/_index.html</span></span><br><span class="line">    <span class="keyword">if</span> (infoMask == k<span class="built_in">CGImageAlphaNone</span> &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set noneSkipFirst.</span></span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaNoneSkipFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// Some PNGs tell us they have alpha but only 3 components. Odd.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!anyNonAlpha &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaPremultipliedFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It calculates the bytes-per-row based on the bitsPerComponent and width arguments.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">            imageSize<span class="variable">.width</span>,</span><br><span class="line">            imageSize<span class="variable">.height</span>,</span><br><span class="line">            <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            colorSpace,</span><br><span class="line">            bitmapInfo);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If failed, return undecompressed image</span></span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *decompressedImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:decompressedImageRef scale:image<span class="variable">.scale</span> orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</span><br><span class="line">    <span class="keyword">return</span> decompressedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3_关于字节对齐">2.3 关于字节对齐</h5><p>SDWebImage与AFNetworking都没有对第7点做优化，FastImageCache相对与其他的开源库，则对第5点与第7点做了优化。这里我们谈谈第七点，关于图片数据的字节对齐。</p>
<blockquote>
<p>Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
</blockquote>
<p><img src="1.png"></p>
<p>从代码上来看，主要是在创建上图解码的过程中，<code>CGBitmapContextCreate</code>函数的<code>bytesPerRow</code>参数必须传64的倍数。</p>
<p>比较各个开源框架的代码，可以看到SDWebImage与AFNetworking的该参数都传的是0，即让系统自动来计算该值（那为何系统自动计算的时候不让图片数据字节就字节对齐呢？）。</p>
<h5 id="2-4_关于第3，4点，内存级别拷贝">2.4 关于第3，4点，内存级别拷贝</h5><p>以上3个开源库中，FastImageCache对这一点做了很大的优化，其他的2个开源库则未关注这一点。这一块木有深入研究，就引用一下FastImageCache团队对该点的一些说明。有能力的可以去看看原文章(英文): <a href="https://github.com/path/FastImageCache" target="_blank" rel="external">here</a></p>
<blockquote>
<p>内存映射<br>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用mmap把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高</p>
</blockquote>
<h5 id="2-5_关于第二步图片处理（裁剪，边框等）">2.5 关于第二步图片处理（裁剪，边框等）</h5><p>一般情况下，对于下载下来的图片我们可能想要做一些处理，比如说做一些缩放，裁剪，或者添加圆角等等。</p>
<p>对于比较通用的缩放，或者圆角等功能，可以集成到控件本身。不过，提供一个接口出来，让使用者能够有机会对下载下来的图片做一些其他的特殊处理是有必要的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** SDWebImage</span><br><span class="line"> * Allows <span class="keyword">to</span> transform <span class="keyword">the</span> image immediately <span class="keyword">after</span> <span class="keyword">it</span> has been downloaded <span class="keyword">and</span> just <span class="keyword">before</span> <span class="keyword">to</span> cache <span class="keyword">it</span> <span class="function_start"><span class="keyword">on</span></span> disk <span class="keyword">and</span> memory.</span><br><span class="line"> * NOTE: This method <span class="keyword">is</span> called <span class="keyword">from</span> a <span class="keyword">global</span> queue <span class="keyword">in</span> order <span class="keyword">to</span> <span class="keyword">not</span> <span class="keyword">to</span> block <span class="keyword">the</span> main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param image        The image <span class="keyword">to</span> transform</span><br><span class="line"> * @param imageURL     The url <span class="keyword">of</span> <span class="keyword">the</span> image <span class="keyword">to</span> transform</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> The transformed image object.</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h5 id="2-6_其他（诸如图片预下载，gif支持等等,下载进度条）">2.6 其他（诸如图片预下载，gif支持等等,下载进度条）</h5><p>待补充</p>
<ol>
<li>常用的开源库对比</li>
</ol>
<table>
<thead>
<tr>
<th>tip</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">AFNetworking</th>
<th style="text-align:right">FastImageCache</th>
</tr>
</thead>
<tbody>
<tr>
<td>异步下载图片</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>子线程解压缩</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>子线程图片处理(缩放，圆角等)</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>存储解压缩后的位图</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>内存级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>磁盘级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>UIImageView category</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">NO</td>
</tr>
<tr>
<td>减少内存级别的拷贝</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:right">YES</td>
</tr>
<tr>
<td>接口易用性</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:right">*</td>
</tr>
</tbody>
</table>
<p>参考资料<br><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache-github</a><br><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage-github</a><br><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking-github</a><br><a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">File System vs Core Data: the image cache test</a><br><a href="https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/" target="_blank" rel="external">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a><br><a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a><br><a href="http://blog.cnbang.net/tech/2578/?utm_source=tuicool" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-Cell-图片异步加载优化，缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/" class="article-date">
  	<time datetime="2015-08-22T13:45:29.000Z" itemprop="datePublished">2015-08-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/22/iOS-Cell-图片异步加载优化，缓存机制/">iOS Cell 图片异步加载优化，缓存机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了防止图片多次下载，我们需要对图片做缓存，缓存分为<code>内存缓存</code> <code>沙盒缓存</code>，我们当然两种都要实现。<br>由于<code>tableViewCell</code>是有重用机制的，也就是说，内存中只有当前可见的<code>cell</code>数目的实例，滑动的时候，新显示<code>cell</code>会重用被滑出的<code>cell</code>对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<p><code>所以在我们向下滑动tableview的时候我们需要手动去取消掉下载操作，当用户停止滑动，再去执行下载操作</code>。</p>
<blockquote>
<p>SDWebImage采用的也是这种策略。</p>
</blockquote>
<p>很简单我们只需要监听ScrollView的代理方法(tableview继承自Scrollview)。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户开始拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewWillBeginDragging</span>:(UIScrollView *)<span class="tag">scrollView</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 暂停下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:YES]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  当用户停止拖拽表格时调用</span><br><span class="line"> */</span></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">scrollViewDidEndDragging</span>:(UIScrollView *)<span class="tag">scrollView</span> <span class="tag">willDecelerate</span>:(BOOL)<span class="tag">decelerate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 恢复下载</span></span><br><span class="line">    <span class="attr_selector">[self.queue setSuspended:NO]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而SDWebImage采用的就是这种方式,所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。</p>
<p>下面介绍一下具体的思路。<br>异步下载图片我们用的是NSOperation，并且创建一个全局的queue来管理下载图片的操作。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载操作的队列</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSOperationQueue* queue;</span></span><br></pre></td></tr></table></figure></p>
<p>另外需要两个字典operations、images<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有的下载操作（url是key，operation对象是value）</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* operations;</span></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  存放所有下载完成的图片，用于内存缓存，同样用Url为key</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@property (nonatomic,strong) NSMutableDictionary* images;</span></span><br></pre></td></tr></table></figure></p>
<p>在把图片显示到Cell上之前<br>先判断内存中(images字典中)有没有图片，<br>如果有，则取出url对应的图片来显示，<br>如果没有，再去沙盒缓存中查看，当然存到沙盒中都是NSData。<br>如果沙盒缓存中有，我们取出对应的数据给Cell去显示<br>如果沙盒中也没有图片，我们先显示占位图片。再创建operation去执行下载操作了。<br>当然在创建operation之前，我们要判断这个operation操作是否存在<br>这个时候就用到我们operations这个字典了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出当前URL对应的下载操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span>* operation = <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>];</span><br></pre></td></tr></table></figure></p>
<p>如果没有下载操作，我们才需要真正的去创建operation执行下载。<br>创建好下载操作之后应该把该操作存放到全局队列中去异步执行，同时吧操作放入operations字典中记录下来。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加操作到队列中</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line"><span class="comment">//添加到字典中</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.operations</span>[app<span class="variable">.icon</span>] = operation;</span><br></pre></td></tr></table></figure></p>
<p>下载完成之后：<br>把下载好的图片放到内存中、同时存到沙盒缓存中<br>下面存放到沙盒中的代码可以定义成宏，具体可以下载后面的demo</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (image) &#123; <span class="comment">//防止下载失败为空赋值造成崩溃</span></span><br><span class="line">  vc<span class="variable">.images</span>[app<span class="variable">.icon</span>] = image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下载完成的图片存入沙盒中                    </span></span><br><span class="line">  <span class="comment">// UIImage --&gt; NSData --&gt; File（文件）</span></span><br><span class="line">     <span class="built_in">NSData</span>* ImageData = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSString</span>* CachesPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">     <span class="built_in">NSString</span>* filePath = [CachesPath stringByAppendingPathComponent:[app<span class="variable">.icon</span> lastPathComponent]];</span><br><span class="line"></span><br><span class="line">     [ImageData writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的操作之后回到主线程刷新表格，<br>从operations字典中移除下载操作(防止operations越来越大，同时保证下载失败后，能重新下载)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷新当前行的图片数据</span></span><br><span class="line">  self.tableView <span class="string">reloadRowsAtIndexPaths:</span>@[indexPath] <span class="string">withRowAnimation:</span>UITableViewRowAnimationNone];</span><br></pre></td></tr></table></figure></p>
<p>这里我们不用[self.tableView reloadata]，因为会刷新整个cell，浪费性能。</p>
<p>当然如果你的下载操作里面需要做的事情很多的时候，可以考虑自定义operation。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-GCD实现单一资源的多读写" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/21/GCD实现单一资源的多读写/" class="article-date">
  	<time datetime="2015-08-21T13:17:58.000Z" itemprop="datePublished">2015-08-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/21/GCD实现单一资源的多读写/">GCD实现单一资源的多读写</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在多线程编程中，最常见的场景是如何保证线程安全，比如你可能经常遇到多线程访问某个dic（又或者是array或其他）造成的crash。<br>这篇文章里，我们讨论下如何使用GCD实现多线程读者与写者问题，也即单一资源的线程安全问题。</p>
</blockquote>
<p>首先，还是先将示例代码放出来好了，后面会有一些我遇到过的问题及改进介绍。如果你只想得到一个解决方案，只需要看第一节就OK，当然，也许你也有兴趣看看后面的部分。</p>
<h3 id="解决方案与原理">解决方案与原理</h3><h4 id="ARC版本">ARC版本</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(<span class="string">"ioQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要创建一个私有的队列来处理读写操作。在这里不推荐使用<code>globe_queue</code>, 因为我们通过<code>dispatch_barrier_async</code>来保证写操作的互斥，我们当然不希望写操作阻塞住<code>globe_queue</code>中的其他不相关任务，我们只希望在写的同时，不会有其他的写操作或者读操作。</p>
<blockquote>
<p>同时，也不推荐给队列设置优先级，多数情况下使用default就可以了。而改变优先级往往会造成一些无法预料的问题，比如优先级反转(具体的可以参看参考文献)。</p>
</blockquote>
<p><img src="dispatch_barrier.png"><br>图片来自参考文献<br><code>dispatch_barrier_async</code>的block运行时机是，在它之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行。注意在<code>barrier</code>执行的时候，队列本质上如同一个串行队列，其执行完以后才会恢复到并行队列。</p>
<p>另外一个值得注意的问题是，在写操作的时候，我们使用<code>dispatch_async</code>，而在读操作的时候我们使用<code>dispatch_sync</code>。很明显，这2个操作一个是异步的，一个是同步的。我们不需要使每次程序执行的时候都等待写操作完成，所以写操作异步执行，但是我们需要同步的执行读操作来保证程序能够立刻得到它想要的值。</p>
<p>使用sync的时候需要极其的小心，因为稍不注意，就有可能产生死锁，这可能造成灾难性的后果。你肯定也注意到了在写操作的时候对key进行了copy, 关于此处的解释，插入一段来自参考文献的引用:</p>
<blockquote>
<p>函数调用者可以自由传递一个NSMutableString的key，并且能够在函数返回后修改它。因此我们必须对传入的字符串使用copy操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的NSString类型），调用copy基本上是个空操作。</p>
</blockquote>
<p>到这里整个基本示例代码已经完成，一般情况下能够满足我们的需要。下面来看看在MRC过程中我遇到的一些问题。</p>
<h4 id="关于死锁">关于死锁</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queueA<span class="comment">; // 串行队列</span></span><br><span class="line">dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;    </span><br><span class="line">    dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;        </span><br><span class="line">        foo<span class="list">()</span><span class="comment">;    </span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>造成死锁比较常见的情况可以简化成上面这段代码。<br><code>dispatch_sync</code>会同步的提交工作并在返回前等待其完成。第一个<code>dispatch_sync</code>正在运行并等待它的block完成，但是block不能够完成，它调用了第二个dispatch_sync，而第二个<code>dispatch_sync</code>会等待串行队列中已经存在的第一个任务完成，很明显这个任务无法完成，造成死锁。</p>
<blockquote>
<p>值得注意的是main_queue就是一个串行队列。</p>
</blockquote>
<h3 id="MRC下容易遇到的问题与解决方案">MRC下容易遇到的问题与解决方案</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    [key release];</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看看上面这段代码，基本就是ARC版本转换过来的，看起来没问题。那么究竟是不是真的没问题，我们跑段代码试试看：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//版本一</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;             </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [self getSafeObjectForKey:<span class="type">KEY</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test执行后，很快就会发生crash，读操作的result会发生野指针。<br>如果你有经验的话，可能会发现问题:<br>如果某个线程a刚取出了result值，这次线程b开始执行写操作，造成线程a中的result值成为了一份过期的数据，如果正好线程b的runloop结束，很有可能旧的result内存地址被释放掉,这时线程a中的result就会发生野指针crash。<br>这时候，你可能会采取这样子的修改，代码如下: </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//版本二</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;             </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [[self getSafeObjectForKey:<span class="type">KEY</span>] retain];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">        [<span class="literal">result</span> release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后会发现，仍然会crash，其实问题和上面一样，我们的改动没有真正的解决问题。最好的解决方案是在读操作之前就已经retain住了，看看最终版的代码吧:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//最终版</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [[_dic objectForKey:key] retain];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">result</span> autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意retain过一定要释放掉，不然或造成内存泄露。</p>
</blockquote>
<p>再次验证后发现，程序不会crash了，恭喜。</p>
<blockquote>
<p>转自 <a href="http://luoyibu.com/" target="_blank" rel="external">http://luoyibu.com/</a> </p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GCD/">GCD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS-多线程-GCD" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/iOS-多线程-GCD/" class="article-date">
  	<time datetime="2015-08-20T14:59:25.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/iOS-多线程-GCD/">iOS 多线程-GCD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GCD">GCD</h3><blockquote>
<ul>
<li>全称是Grand Central Dispatch，“伟大的中枢调度器”</li>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>纯C语言，提供了非常多强大的函数</li>
</ul>
</blockquote>
<h4 id="优势">优势</h4><ol>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ol>
<h4 id="基本概念">基本概念</h4><h5 id="任务和队列">任务和队列</h5><p><code>GCD中有2个核心概念</code></p>
<ol>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定制任务:确定想做的事情</span></span><br><span class="line"><span class="comment">// 2.将任务添加到队列中:GCD会自动将队列中的任务取出，放到对应的线程中执行。</span></span><br><span class="line">Tips：任务的取出遵循队列的FIFO原则：先进先出，后进后出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="任务">任务</h4><h5 id="一、执行任务">一、执行任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">queue</span>：队列</span><br><span class="line"> - block：任务</span><br><span class="line"><span class="comment">// 1.用同步的方式执行任务</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用异步的方式执行任务</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.GCD中还有个用来执行任务的函数</span></span><br><span class="line"><span class="comment">// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
<p>注意:<br><code>同步</code>：只能在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</p>
<h4 id="队列">队列</h4><h5 id="一、并发队列（Concurrent_Dispatch_Queue）">一、并发队列（Concurrent Dispatch Queue）</h5><ul>
<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>
<li>并发功能只有在异步（dispatch_async）函数下才有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="comment">// 队列名称 </span></span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr); <span class="comment">// 队列的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用dispatch_get_global_queue函数获得全局的并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_get_global_queue(<span class="keyword">dispatch_queue_priority_t</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="comment">// dispatch_queue_priority_t priority(队列的优先级 )</span></span><br><span class="line"><span class="comment">// unsigned long flags( 此参数暂时无用，用0即可 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获得全局并发队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.全局并发队列的优先级</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span> <span class="comment">// 高</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span> <span class="comment">// 默认（中）</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>) <span class="comment">// 低</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN <span class="comment">// 后台</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="二、串行队列（Serial_Dispatch_Queue）">二、串行队列（Serial Dispatch Queue）</h5><ul>
<li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用dispatch_queue_create函数创建串行队列</span></span><br><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用dispatch_get_main_queue()获得主队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br><span class="line">注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="三、各种队列的执行效果">三、各种队列的执行效果</h5><p><img src="123.png"><br><code>特别注意</code>：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 (线程卡死)</p>
<h4 id="新手易混淆">新手易混淆</h4><blockquote>
<p>有4个术语比较容易混淆：<code>同步</code>、<code>异步</code>、<code>并发</code>、<code>串行</code></p>
<ol>
<li>同步和异步主要影响：能不能开启新的线程<br><code>同步</code>：只是在当前线程中执行任务，不具备开启新线程的能力<br><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力</li>
<li>并发和串行主要影响：任务的执行方式<br><code>并发</code>：多个任务并发（同时）执行<br><code>串行</code>：一个任务执行完毕后，再执行下一个任务</li>
</ol>
</blockquote>
<h4 id="GCD运用">GCD运用</h4><h5 id="一、线程间通信">一、线程间通信</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从子线程回到主线程</span><br><span class="line"><span class="tag">dispatch_async</span>(</span><br><span class="line"><span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行耗时的异步操作...</span></span><br><span class="line">      <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="comment">// 回到主线程，执行UI刷新操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="二、延时执行">二、延时执行</h5><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after<span class="params">(dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2.0</span> * NSEC_PER_SEC)</span>)</span>, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">    // <span class="number">2</span>秒后异步执行这里的代码...</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="三、一次性代码">三、一次性代码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="四、快速迭代">四、快速迭代</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_apply函数能进行快速迭代遍历</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">    <span class="comment">// 执行10次代码，index顺序不确定</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="五、队列组">五、队列组</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</span></span><br><span class="line">dispatch_group_t <span class="keyword">group</span> =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Objective-C-Code-guide" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/Objective-C-Code-guide/" class="article-date">
  	<time datetime="2015-08-19T23:16:41.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/Objective-C-Code-guide/">Objective-C 编码规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录">目录</h3><ul>
<li>语言</li>
<li>代码组织</li>
<li>空格</li>
<li>注释</li>
<li>命名<ul>
<li>下划线</li>
</ul>
</li>
<li>方法</li>
<li>变量</li>
<li>属性特性</li>
<li>点符号语法</li>
<li>字面值</li>
<li>常量</li>
<li>枚举类型</li>
<li>Case语句</li>
<li>私有属性</li>
<li>布尔值</li>
<li>条件语句<ul>
<li>三元操作符</li>
</ul>
</li>
<li>Init方法</li>
<li>类构造方法</li>
<li>CGRect函数</li>
<li>黄金路径</li>
<li>错误处理</li>
<li>单例模式</li>
<li>换行符</li>
<li>Xcode工程</li>
</ul>
<h4 id="语言">语言</h4><p>应该使用US英语.<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure></p>
<p>代码组织<br>在函数分组和<code>protocol/delegate</code>实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Lifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (instancetype)<span class="tag">init</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewWillAppear</span>:(BOOL)<span class="tag">animated</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">didReceiveMemoryWarning</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Custom</span> <span class="tag">Accessors</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">setCustomProperty</span>:(id)<span class="tag">value</span> &#123;&#125;</span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">customProperty</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">IBActions</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">submitData</span>:(id)<span class="tag">sender</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Public</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">publicMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Private</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">privateMethod</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">Protocol</span> <span class="tag">conformance</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITextFieldDelegate</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDataSource</span></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSCopying</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (id)<span class="tag">copyWithZone</span>:(NSZone *)<span class="tag">zone</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="id">#pragma</span> <span class="tag">mark</span> <span class="tag">-</span> <span class="tag">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (NSString *)<span class="tag">description</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><ul>
<li>缩进使用4个空格，确保在Xcode偏好设置来设置。(<a href="http://www.raywenderlich.com]使用2个空格" target="_blank" rel="external">raywenderlich.com</a></li>
<li>方法大括号和其他大括号(<code>if/else/switch/while</code> 等.)总是在同一行语句打开但在新行中关闭。<br>应该:<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用<code>auto-synthesis</code>。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。<br>应该:<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure></p>
<h4 id="注释">注释</h4><p>当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。例外：这不应用在生成文档的注释</p>
<h4 id="命名">命名</h4><p>Apple命名规则尽可能坚持，特别是与这些相关的memory management rules (NARC)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p>应该:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *<span class="built_in">set</span>But;</span><br></pre></td></tr></table></figure></p>
<p>三个字符前缀应该经常用在类和常量命名，但在<code>Core Data</code>的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p>应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure></p>
<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用<code>auto-synthesis</code>，而不是手动编写<code>@ synthesize</code>语句，除非你有一个好的理由。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> varnm;</span><br></pre></td></tr></table></figure></p>
<h3 id="下划线">下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h4 id="方法">方法</h4><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p>应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setExampleText:<span class="params">(NSString *)</span><span class="built_in">text</span> image:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector to:<span class="params">(id)</span>anObject forAllCells:<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>viewWithTag:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width height:<span class="params">(CGFloat)</span>height;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(void)</span>setT:<span class="params">(NSString *)</span><span class="built_in">text</span> i:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector :<span class="params">(id)</span>anObject :<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>taggedView:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width andHeight:<span class="params">(CGFloat)</span>height;</span><br><span class="line">- <span class="params">(instancetype)</span>initWith:<span class="params">(int)</span>width and:<span class="params">(int)</span>height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="变量">变量</h4><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， NSString <em>text 既不是 NSString</em> text 也不是 NSString * text，除了一些特殊情况下常量。</p>
<p><a href="#">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>i</code>nitWithCoder:`, 等…)，dealloc 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里</p>
<p>应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">  NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性特性">属性特性</h4><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure></p>
<h4 id="点符号语法">点符号语法</h4><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里</p>
<p>点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span><span class="variable">.array</span> count];</span><br><span class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span><span class="variable">.array</span><span class="variable">.count</span>;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span><span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="字面值">字面值</h4><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致<code>crash</code>。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="常量">常量</h4><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine CompanyName @<span class="string">"RayWenderlich.com"</span></span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine thumbnailHeight <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="枚举类型">枚举类型</h4><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain,</span><br><span class="line">  RWTLeftMenuTopItemShows,</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123;</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeM<span class="keyword">in</span> = <span class="number">1</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>SizeMax = <span class="number">5</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountM<span class="keyword">in</span> = <span class="number">100</span>,</span><br><span class="line">  RWTP<span class="keyword">in</span>CountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>旧的k-style常量定义应该避免除非编写Core Foundation C的代码。</p>
<p>不应该:<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">  kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">  kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Case语句">Case语句</h4><p>大括号在<code>case</code>语句中并不是必须的，除非编译器强制要求。当一个<code>case</code>语句包含多行代码时，大括号应该加上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Multi-line example using braces</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多次，当相同代码被多个<code>cases</code>使用时，一个<code>fall-through</code>应该被使用。一个<code>fall-through</code>就是在<code>case</code>最后移除<code>break</code>语句，这样就能够允许执行流程跳转到下一个<code>case</code>值。为了代码更加清晰，一个<code>fall-through</code>需要注释一下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ** fall-through! **</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当在<code>switch</code>使用枚举类型时，<code>default</code>是不需要的。例如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="私有属性">私有属性</h4><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="布尔值">布尔值</h4><p>Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1和一个BOOL能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(isAwesome == <span class="literal">true</span>)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p>
<p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, getter=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文字和例子从这里引用Cocoa Naming Guidelines</p>
</blockquote>
<h4 id="条件语句">条件语句</h4><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p>应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="command">  return</span> success;</span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="constant">return</span> success;</span><br></pre></td></tr></table></figure></p>
<h4 id="三元操作符">三元操作符</h4><p>当需要提高代码的清晰性和简洁性时，三元操作符?:才会使用。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p>应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="literal">result</span> = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> isHorizontal = <span class="type">YES</span>;</span><br><span class="line"><span class="literal">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span> = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure></p>
<h4 id="Init方法">Init方法</h4><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用instancetype而不是id<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看关于instancetype的文章Class Constructor Methods</p>
<h4 id="类构造方法">类构造方法</h4><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Airplane</span><br><span class="line">+ (instancetype)airplaneWithType:(RWTAirplaneType)<span class="class"><span class="keyword">type</span>;</span></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>关于更多instancetype信息，请查看NSHipster.com</p>
<h4 id="CGRect函数">CGRect函数</h4><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry:</p>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。<br>应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="黄金路径">黄金路径</h4><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">someMethod</span> &#123;</span><br><span class="line">  <span class="tag">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="错误处理">错误处理</h4><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不应该:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">  // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<h4 id="单例模式">单例模式</h4><p>单例对象应该使用线程安全模式来创建共享实例。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会防止possible and sometimes prolific crashes.</p>
<h4 id="换行符">换行符</h4><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br><span class="line">一行很长的代码应该分成两行代码，下一行用两个空格隔开。</span><br><span class="line"></span><br><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Xcode工程">Xcode工程</h4><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下additional warnings。如果你需要忽略特殊的警告，使用 Clang’s pragma feature。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NSString-tips" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/NSString-tips/" class="article-date">
  	<time datetime="2015-08-19T23:00:20.000Z" itemprop="datePublished">2015-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/NSString-tips/">NSString 实用技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>首字母大写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首字母大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"ligang"</span>;</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,[<span class="built_in">string</span> capitalizedString]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分割字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割字符串</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is a iOSDevTip"</span>;</span><br><span class="line">NSArray *<span class="built_in">array</span> = [<span class="built_in">string</span> componentsSeparatedByString:@<span class="string">"a"</span>];</span><br><span class="line">NSString *string1 = [<span class="built_in">array</span> objectAtIndex:<span class="number">0</span>];</span><br><span class="line">NSString *string2 = [<span class="built_in">array</span> objectAtIndex:<span class="number">1</span>];</span><br><span class="line">NSLog(@<span class="string">"string1:%@  string2:%@"</span>,string1,string2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加字符串</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//追加字符串</span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithStrin<span class="variable">g:</span>@<span class="string">"I Love "</span>];</span><br><span class="line">[<span class="built_in">string</span> appendStrin<span class="variable">g:</span>@<span class="string">"China"</span>];</span><br><span class="line">NSLog(@<span class="string">"string:%@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I China"</span>];</span><br><span class="line">[<span class="built_in">string</span> insertString:@<span class="string">"Love "</span> atIndex:<span class="number">2</span>];</span><br><span class="line">NSLog(@<span class="string">"string: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除字符串</span></span><br><span class="line">NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc] initWithString:@<span class="string">"I love China"</span>];</span><br><span class="line">[<span class="built_in">string</span> deleteCharactersInRange:NSMakeRange(<span class="number">2</span>, <span class="number">4</span>)];</span><br><span class="line">NSLog(@<span class="string">"String1: %@"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否包含前后缀</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否包含前后缀</span></span><br><span class="line"><span class="constant">NSString *string</span> = @<span class="string">"I love China"</span>;</span><br><span class="line"><span class="constant">BOOL isHasI</span> = [<span class="built_in">string</span> hasPrefix:@<span class="string">"I"</span>];</span><br><span class="line"><span class="constant">BOOL isHasChina</span> = [<span class="built_in">string</span> hasSuffix:@<span class="string">"China"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"I love China"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *replaceString = [string stringByReplacingOccurrencesOfString:<span class="string">@"love"</span> withString:<span class="string">@"like"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"replaceString:  %@"</span>,replaceString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除字符串首尾的空格和换行符</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除字符串首尾的空格和换行符</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@" I love China "</span>;</span><br><span class="line"><span class="built_in">NSString</span> *text = [string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text:%@"</span>,text);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字符串是否包含另一个字符串</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string1 = <span class="string">@"This is a iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="string">@"iOSDevTip"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [string1 rangeOfString:string2];</span><br><span class="line"><span class="built_in">NSInteger</span> location = range<span class="variable">.location</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> length = range<span class="variable">.length</span>;</span><br><span class="line"><span class="built_in">NSString</span> *logString = [[<span class="built_in">NSString</span> alloc] initWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Location:%ld,Leight:%ld"</span>,location,length]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"logString:%@"</span>,logString);</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取字符串</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">NSString</span> *<span class="keyword">string </span>= <span class="comment">@"This is a operation string!";</span></span><br><span class="line">//<span class="keyword">substringToIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subToString </span>= [<span class="keyword">string </span><span class="keyword">substringToIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringFromIndex截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *<span class="keyword">subFromString </span>= [<span class="keyword">string </span><span class="keyword">substringFromIndex:6];</span><br><span class="line"></span>//<span class="keyword">substringWithRange截取字符串</span><br><span class="line"></span><span class="label">NSString</span> *rangeString = [<span class="keyword">string </span><span class="keyword">substringWithRange:NSMakeRange(6, </span><span class="number">3</span>)]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写转大写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> lowercaseString];</span><br><span class="line"></span><br><span class="line"><span class="comment">//大写转小写</span></span><br><span class="line">NSString *<span class="built_in">string</span> = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line">[<span class="built_in">string</span> uppercaseString];</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串比较</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//isEqualToString方法比较</span><br><span class="line"><span class="type">NSString</span> *stingOne = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">NSString</span> *stringTwo = @<span class="string">"This is an iOSDevTip!"</span>;</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne isEqualToString:stringTwo];</span><br><span class="line">//compare方法比较</span><br><span class="line"><span class="type">BOOL</span> <span class="literal">result</span> = [stingOne compare:stringTwo] == <span class="type">NSOrderedSame</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>typedef NS_ENUM(NSInteger, NSComparisonResult) {<br>    NSOrderedAscending = -1L,<br>    NSOrderedSame,<br>    NSOrderedDescending<br>};</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 苹果
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>